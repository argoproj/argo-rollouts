{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Argo Rollouts - Kubernetes Progressive Delivery Controller","text":""},{"location":"#what-is-argo-rollouts","title":"What is Argo Rollouts?","text":"<p>Argo Rollouts is a Kubernetes controller and set of CRDs which provide advanced deployment capabilities such as blue-green, canary, canary analysis, experimentation, and progressive delivery features to Kubernetes.</p> <p>Argo Rollouts (optionally) integrates with ingress controllers and service meshes, leveraging their traffic shaping abilities to gradually shift traffic to the new version during an update. Additionally, Rollouts can query and interpret metrics from various providers to verify key KPIs and drive automated promotion or rollback during an update.</p> <p>Here is a demonstration video (click to watch on Youtube):</p> <p></p>"},{"location":"#why-argo-rollouts","title":"Why Argo Rollouts?","text":"<p>The native Kubernetes Deployment Object supports the <code>RollingUpdate</code> strategy which provides a basic set of safety guarantees (readiness probes) during an update. However the rolling update strategy faces many limitations:</p> <ul> <li>Few controls over the speed of the rollout</li> <li>Inability to control traffic flow to the new version</li> <li>Readiness probes are unsuitable for deeper, stress, or one-time checks</li> <li>No ability to query external metrics to verify an update</li> <li>Can halt the progression, but unable to automatically abort and rollback the update</li> </ul> <p>For these reasons, in large scale high-volume production environments, a rolling update is often considered too risky of an update procedure since it provides no control over the blast radius, may rollout too aggressively, and provides no automated rollback upon failures.</p>"},{"location":"#controller-features","title":"Controller Features","text":"<ul> <li>Blue-Green update strategy</li> <li>Canary update strategy</li> <li>Fine-grained, weighted traffic shifting</li> <li>Automated rollbacks and promotions</li> <li>Manual judgement</li> <li>Customizable metric queries and analysis of business KPIs</li> <li>Ingress controller integration: NGINX, ALB, Apache APISIX</li> <li>Service Mesh integration: Istio, Linkerd, SMI</li> <li>Simultaneous usage of multiple providers: SMI + NGINX, Istio + ALB, etc.</li> <li>Metric provider integration: Prometheus, Wavefront, Kayenta, Web, Kubernetes Jobs, Datadog, New Relic, Graphite, InfluxDB</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>kubectl create namespace argo-rollouts\nkubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml\n</code></pre> <p>Follow the full getting started guide to walk through creating and then updating a rollout object.</p>"},{"location":"#how-does-it-work","title":"How does it work?","text":"<p>Similar to the deployment object, the Argo Rollouts controller will manage the creation, scaling, and deletion of ReplicaSets. These ReplicaSets are defined by the <code>spec.template</code> field inside the Rollout resource, which uses the same pod template as the deployment object.</p> <p>When the <code>spec.template</code> is changed, that signals to the Argo Rollouts controller that a new ReplicaSet will be introduced. The controller will use the strategy set within the <code>spec.strategy</code> field in order to determine how the rollout will progress from the old ReplicaSet to the new ReplicaSet. Once that new ReplicaSet is scaled up (and optionally passes an Analysis), the controller will mark it as \"stable\".</p> <p>If another change occurs in the <code>spec.template</code> during a transition from a stable ReplicaSet to a new ReplicaSet (i.e. you change the application version in the middle of a rollout), then the previously new ReplicaSet will be scaled down, and the controller will try to progress the ReplicasSet that reflects the updated <code>spec.template</code> field. There is more information on the behaviors of each strategy in the spec section.</p>"},{"location":"#use-cases-of-argo-rollouts","title":"Use cases of Argo Rollouts","text":"<ul> <li> <p>A user wants to run last-minute functional tests on the new version before it starts to serve production traffic. With the BlueGreen strategy, Argo Rollouts allows users to specify a preview service and an active service. The Rollout will configure the preview service to send traffic to the new version while the active service continues to receive production traffic. Once a user is satisfied, they can promote the preview service to be the new active service. (example)</p> </li> <li> <p>Before a new version starts receiving live traffic, a generic set of steps need to be executed beforehand. With the BlueGreen Strategy, the user can bring up the new version without it receiving traffic from the active service. Once those steps finish executing, the rollout can cut over traffic to the new version.</p> </li> <li> <p>A user wants to give a small percentage of the production traffic to a new version of their application for a couple of hours. Afterward, they want to scale down the new version and look at some metrics to determine if the new version is performant compared to the old version. Then they will decide if they want to roll out the new version for all of the production traffic or stick with the current version. With the canary strategy, the rollout can scale up a ReplicaSet with the new version to receive a specified percentage of traffic, wait for a specified amount of time, set the percentage back to 0, and then wait to rollout out to service all of the traffic once the user is satisfied. (example)</p> </li> <li> <p>A user wants to slowly give the new version more production traffic. They start by giving it a small percentage of the live traffic and wait a while before giving the new version more traffic. Eventually, the new version will receive all the production traffic. With the canary strategy, the user specifies the percentages they want the new version to receive and the amount of time to wait between percentages. (example)</p> </li> <li> <p>A user wants to use the normal Rolling Update strategy from the deployment. If a user uses the canary strategy with no steps, the rollout will use the max surge and max unavailable values to roll to the new version. (example)</p> </li> </ul>"},{"location":"#examples","title":"Examples","text":"<p>You can see more examples of Rollouts at:</p> <ul> <li>The example directory</li> <li>The Argo Rollouts Demo application</li> </ul>"},{"location":"CONTRIBUTING/","title":"Contributing","text":""},{"location":"CONTRIBUTING/#before-you-start","title":"Before You Start","text":"<p>Argo Rollouts is written in Golang. If you do not have a good grounding in Go, try out the tutorial.</p>"},{"location":"CONTRIBUTING/#pre-requisites","title":"Pre-requisites","text":"<p>Install:</p> <ul> <li>docker</li> <li>golang</li> <li>kubectl</li> <li>kustomize &gt;= 4.5.5</li> <li>k3d recommended</li> </ul> <p>Kustomize is required for unit tests (<code>make test</code> is using it), so you must install it locally if you wish to make code contributions to Argo Rollouts.</p> <p>Argo Rollout additionally uses the following tools</p> <ul> <li><code>golangci-lint</code> to lint the project.</li> <li><code>protoc</code> and <code>swagger-codegen</code> to generate proto related files</li> <li><code>yarn</code> to build the UI</li> </ul> <p>Run the following commands to install them:</p> <pre><code># macOS\nbrew install golangci-lint\n\n# linux\ngo get -u github.com/golangci/golangci-lint/cmd/golangci-lint\n</code></pre> <p>Brew users can quickly install the lot:</p> <pre><code>brew install go kubectl kustomize golangci-lint protobuf swagger-codegen k3d\n</code></pre> <p>Set up environment variables (e.g. is <code>~/.bashrc</code>):</p> <pre><code>export GOPATH=~/go\nexport PATH=$PATH:$GOPATH/bin\n</code></pre> <p>Checkout the code:</p> <pre><code>go get -u github.com/argoproj/argo-rollouts\ncd ~/go/src/github.com/argoproj/argo-rollouts\n</code></pre>"},{"location":"CONTRIBUTING/#building","title":"Building","text":"<p><code>go.mod</code> is used, so the <code>go build/test</code> commands automatically install the needed dependencies</p> <p>The <code>make controller</code> command will build the controller.</p> <ul> <li> <p><code>make install-tools-local</code> - Runs scripts to install codegen utility CLIs necessary for codegen.</p> </li> <li> <p><code>make codegen</code> - Runs the code generator that creates the informers, client, lister, and deepcopies from the types.go and modifies the open-api spec.</p> </li> </ul>"},{"location":"CONTRIBUTING/#running-controller-locally","title":"Running Controller Locally","text":"<p>It is much easier to run and debug if you run Argo Rollout in your local machine than in the Kubernetes cluster.</p> <pre><code>cd ~/go/src/github.com/argoproj/argo-rollouts\ngo run ./cmd/rollouts-controller/main.go\n</code></pre> <p>When running locally it will connect to whatever kubernetes cluster you have configured in your kubeconfig. You will need to make sure to install the Argo Rollout CRDs into your local cluster, and have the <code>argo-rollouts</code> namespace.</p>"},{"location":"CONTRIBUTING/#running-unit-tests","title":"Running Unit Tests","text":"<p>To run unit tests:</p> <pre><code>make test\n</code></pre>"},{"location":"CONTRIBUTING/#running-e2e-tests","title":"Running E2E tests","text":"<p>The end-to-end tests need to run against a kubernetes cluster with the Argo Rollouts controller running.</p> <p>Start and prepare your cluster for e2e tests:</p> <pre><code>k3d cluster create\nkubectl create ns argo-rollouts\nkubectl apply -k manifests/crds\nkubectl apply -f test/e2e/crds\n</code></pre> <p>The rollout controller can be started with the command:</p> <pre><code>make start-e2e\n</code></pre> <p>Then run the e2e tests:</p> <pre><code>make test-e2e\n</code></pre> <p>To run a subset of e2e tests, you need to specify the suite with <code>-run</code>, and the specific test regex with <code>-testify.m</code>.</p> <pre><code>E2E_TEST_OPTIONS=\"-run 'TestCanarySuite' -testify.m 'TestCanaryScaleDownOnAbortNoTrafficRouting'\" make test-e2e\n</code></pre>"},{"location":"CONTRIBUTING/#running-the-ui","title":"Running the UI","text":"<p>If you'd like to run the UI locally, you first need a running Rollouts controller. This can be a locally running controller with a k3d cluster, as described above, or a controller running in a remote Kubernetes cluster.</p> <p>In order for the local React app to communicate with the controller and Kubernetes API, run the following to open a port forward to the dashboard:</p> <pre><code>kubectl argo rollouts dashboard\n</code></pre> <p>Note that you can also build the API server and run this instead,</p> <pre><code>make plugin\n./dist/kubectl-argo-rollouts dashboard\n</code></pre> <p>In another terminal, run the following to start the UI:</p> <pre><code>cd ui\nyarn install\nyarn start\n</code></pre>"},{"location":"CONTRIBUTING/#getting-your-feature-accepted","title":"Getting your feature accepted","text":"<p>To be eligible for inclusion in a minor release, a new feature must meet the following criteria before the release\u2019s RC date.</p> <p>If it is a large feature that involves significant design decisions, that feature must be described in a Proposal.</p> <p>The feature PR must include:</p> <ul> <li>Tests (passing)</li> <li>Documentation</li> <li>If necessary, a note in the Upgrading docs for the planned minor release</li> <li>The PR must be reviewed, approved, and merged by an Approver.</li> </ul> <p>If these criteria are not met by the RC date, the feature will be ineligible for inclusion in the RC series or GA for that minor release. It will have to wait for the next minor release.</p>"},{"location":"CONTRIBUTING/#controller-architecture","title":"Controller architecture","text":"<p>Argo Rollouts is actually a collection of individual controllers that handle a specific aspect of Progressive Delivery.</p> <p></p> <p>The controllers are:</p> <ul> <li>Rollout Controller</li> <li>Service Controller</li> <li>Ingress Controller</li> <li>Experiment Controller</li> <li>AnalysisRun Controller</li> </ul>"},{"location":"CONTRIBUTING/#tips","title":"Tips","text":"<ol> <li>You can run the tests using a different kubeconfig by setting the <code>KUBECONFIG</code> environment variable:</li> </ol> <pre><code>KUBECONFIG=~/.kube/minikube make start-e2e\nKUBECONFIG=~/.kube/minikube make test-e2e\n</code></pre> <ol> <li>To run a specific e2e test, set the <code>E2E_TEST_OPTIONS</code> environment variable to specify the test    (or test regex):</li> </ol> <pre><code>make test-e2e E2E_TEST_OPTIONS=\"-testify.m ^TestRolloutRestart$\"\n</code></pre> <ol> <li>The e2e tests are designed to run as quickly as possible, eliminating readiness and termination    delays. However, it is often desired to artificially slow down the tests for debugging purposes,    as well as to understand what the test is doing. To delay startup and termination of pods, set the    <code>E2E_POD_DELAY</code> to an integer value in seconds. This environment variable is often coupled with    <code>E2E_TEST_OPTIONS</code> to debug and slow down a specific test.</li> </ol> <pre><code>make test-e2e E2E_POD_DELAY=10\n</code></pre> <ol> <li>Increasing the timeout. The E2E tests time out waiting on conditions to be met within 60 seconds.    If debugging the rollout controller, it may be useful to increase this timeout while say sitting    at a debugger breakpoint:</li> </ol> <pre><code>make test-e2e E2E_WAIT_TIMEOUT=999999\n</code></pre> <ol> <li>The e2e tests leverage a feature of the controller allowing the controller to be sharded with    a user-specific \"instance id\" label. This allows the tests to operate only on rollouts with the    specified label, and prevents any other controllers (including the system rollout controller),    from also operating on the same set of rollouts. This value can be changed (from the default of    <code>argo-rollouts-e2e</code>), using the <code>E2E_INSTANCE_ID</code> environment variable:</li> </ol> <pre><code>make start-e2e E2E_INSTANCE_ID=foo\nmake test-e2e E2E_INSTANCE_ID=foo\n</code></pre> <p>Alternatively, the e2e tests can be run against the system controller (i.e. without an instance id):</p> <pre><code>make start-e2e E2E_INSTANCE_ID=''\n</code></pre> <ol> <li>Working on CRDs? While editing them directly works when you are finding the shape of things you want, the final CRDs are autogenerated. Make sure to regenerate them by running <code>make gen-crd</code> before submitting PRs. They are controlled by the relevant annotations in the types file:</li> </ol> <p>eg: Analysis Templates are controlled by annotations in <code>pkg/apis/rollouts/v1alpha1/analysis_types.go</code>.</p> <p>Refer to https://book-v1.book.kubebuilder.io/beyond_basics/generating_crd.html and https://book.kubebuilder.io/reference/markers/crd-validation.html for more info on annotations you can use.</p>"},{"location":"CONTRIBUTING/#running-local-containers","title":"Running Local Containers","text":"<p>You may need to run containers locally, so here's how:</p> <p>Create login to Docker Hub, then login.</p> <pre><code>docker login\n</code></pre> <p>Add your username as the environment variable, e.g. to your <code>~/.bash_profile</code>:</p> <pre><code>export IMAGE_NAMESPACE=argoproj\n</code></pre> <p>Build the images:</p> <pre><code>DOCKER_PUSH=true make image\n</code></pre> <p>Update the manifests:</p> <pre><code>make manifests\n</code></pre> <p>Install the manifests:</p> <pre><code>kubectl -n argo-rollouts apply -f manifests/install.yaml\n</code></pre>"},{"location":"CONTRIBUTING/#upgrading-kubernetes-libraries","title":"Upgrading Kubernetes Libraries","text":"<p>Argo Rollouts has a dependency on the kubernetes/kubernetes repo for some of the functionality that has not been pushed into the other kubernetes repositories yet. In order to import the kubernetes/kubernetes repo, all of the associated repos have to pinned to the correct version specified by the kubernetes/kubernetes release. The <code>./hack/update-k8s-dependencies.sh</code> updates all the dependencies to the those correct versions.</p>"},{"location":"CONTRIBUTING/#upgrading-notifications-engine","title":"Upgrading Notifications Engine","text":"<p>Argo Rollouts has a dependency on the argoproj/notifications-engines repo for the notifications functionality and related documentation.</p> <p>This is updated by upgrading the Go library in <code>go.mod</code> by running the commands:</p> <pre><code>go get github.com/argoproj/notifications-engine@LATEST_COMMIT_HASH\ngo mod tidy\n</code></pre> <p>Next the latest notifications documentation can be imported by running:</p> <pre><code>make docs\n</code></pre>"},{"location":"CONTRIBUTING/#documentation-changes","title":"Documentation Changes","text":"<p>Modify contents in <code>docs/</code> directory.</p> <p>Preview changes in your browser by visiting http://localhost:8000 after running:</p> <pre><code>make serve-docs\n</code></pre> <p>To publish changes, run:</p> <pre><code>make release-docs\n</code></pre>"},{"location":"FAQ/","title":"FAQ","text":"<p>Be sure to read the Best practices page as well.</p>"},{"location":"FAQ/#general","title":"General","text":""},{"location":"FAQ/#does-argo-rollouts-depend-on-argo-cd-or-any-other-argo-project","title":"Does Argo Rollouts depend on Argo CD or any other Argo project?","text":"<p>Argo Rollouts is a standalone project. Even though it works great with Argo CD and other Argo projects, it can be used on its own for Progressive Delivery scenarios. More specifically, Argo Rollouts does NOT require that you also have installed Argo CD on the same cluster.</p>"},{"location":"FAQ/#how-does-argo-rollouts-integrate-with-argo-cd","title":"How does Argo Rollouts integrate with Argo CD?","text":"<p>Argo CD understands the health of Argo Rollouts resources via Argo CD\u2019s Lua health check. These Health checks understand when the Argo Rollout objects are Progressing, Suspended, Degraded, or Healthy.  Additionally, Argo CD has Lua based Resource Actions that can mutate an Argo Rollouts resource (i.e. unpause a Rollout).</p> <p>As a result, an operator can build automation to react to the states of the Argo Rollouts resources. For example, if a Rollout created by Argo CD is paused, Argo CD detects that and marks the Application as suspended. Once the new version is verified to be good, the operator can use Argo CD\u2019s resume resource action to unpause the Rollout so it can continue to make progress. </p>"},{"location":"FAQ/#can-we-run-the-argo-rollouts-kubectl-plugin-commands-via-argo-cd","title":"Can we run the Argo Rollouts kubectl plugin commands via Argo CD?","text":"<p>Argo CD supports running Lua scripts to modify resource kinds (i.e. suspending a CronJob by setting the <code>.spec.suspend</code> to true). These Lua Scripts can be configured in the argocd-cm ConfigMap or upstreamed to the Argo CD's resource_customizations directory. These custom actions have two Lua scripts: one to modify the said resource and another to detect if the action can be executed (i.e. A user should not be able to resuming a unpaused Rollout). Argo CD allows users to execute these actions via the UI or CLI.</p> <p>In the CLI, a user (or a CI system) can run <pre><code>argocd app actions run &lt;APP_NAME&gt; &lt;ACTION&gt; \n</code></pre> This command executes the action listed on the application listed.</p> <p>In the UI, a user can click the hamburger button of a resource and the available actions will appear in a couple of seconds. The user can click and confirm that action to execute it.</p> <p>Currently, the Rollout action has two available custom actions in Argo CD: resume and restart.</p> <ul> <li>Resume unpauses a Rollout with a PauseCondition</li> <li>Restart: Sets the RestartAt and causes all the pods to be restarted.</li> </ul>"},{"location":"FAQ/#does-argo-rollout-require-a-service-mesh-like-istio","title":"Does Argo Rollout require a Service Mesh like Istio?","text":"<p>Argo Rollouts does not require a service mesh or ingress controller to be used. In the absence of a traffic routing provider, Argo Rollouts manages the replica counts of the canary/stable ReplicaSets to achieve the desired canary weights. Normal Kubernetes Service routing (via kube-proxy) is used to split traffic between the ReplicaSets. </p>"},{"location":"FAQ/#does-argo-rollout-require-we-follow-gitops-in-my-organization","title":"Does Argo Rollout require we follow GitOps in my organization?","text":"<p>Argo Rollouts is a Kubernetes controller that will react to any manifest change regardless of how the manifest was changed. The manifest can be changed by a Git commit, an API call, another controller or even a manual <code>kubectl</code> command. You can use Argo Rollouts with any traditional CI/CD solution that does not follow the GitOps approach.</p>"},{"location":"FAQ/#can-we-run-the-argo-rollouts-controller-in-ha-mode","title":"Can we run the Argo Rollouts controller in HA mode?","text":"<p>Yes. A k8s cluster can run multiple replicas of Argo-rollouts controllers to achieve HA. To enable this feature, run the controller with <code>--leader-elect</code> flag and increase the number of replicas in the controller's deployment manifest. The implementation is based on the k8s client-go's leaderelection package. This implementation is tolerant to arbitrary clock skew among replicas. The level of tolerance to skew rate can be configured by setting <code>--leader-election-lease-duration</code> and <code>--leader-election-renew-deadline</code> appropriately. Please refer to the package documentation for details.</p>"},{"location":"FAQ/#can-we-install-argo-rollouts-centrally-in-a-cluster-and-manage-rollout-resources-in-external-clusters","title":"Can we install Argo Rollouts centrally in a cluster and manage Rollout resources in external clusters?","text":"<p>No you cannot do that (even though Argo CD can work that way). This is by design because the Rollout is a custom resource unknown to vanilla Kubernetes. You need the Rollout CRD as well as the controller in the deployment cluster (every cluster that will use workloads with Rollouts).</p>"},{"location":"FAQ/#rollouts","title":"Rollouts","text":""},{"location":"FAQ/#which-deployment-strategies-does-argo-rollouts-support","title":"Which deployment strategies does Argo Rollouts support?","text":"<p>Argo Rollouts supports BlueGreen, Canary, and Rolling Update. Additionally, Progressive Delivery features can be enabled on top of the blue-green/canary update, which further provides advanced deployment such as automated analysis and rollback.</p>"},{"location":"FAQ/#does-the-rollout-object-follow-the-provided-strategy-when-it-is-first-created","title":"Does the Rollout object follow the provided strategy when it is first created?","text":"<p>As with Deployments, Rollouts does not follow the strategy parameters on the initial deploy. The controller tries to get the Rollout into a steady state as fast as possible by creating a fully scaled up ReplicaSet from the provided <code>.spec.template</code>. Once the Rollout has a stable ReplicaSet to transition from, the controller starts using the provided strategy to transition the previous ReplicaSet to the desired ReplicaSet.</p>"},{"location":"FAQ/#how-does-bluegreen-rollback-work","title":"How does BlueGreen rollback work?","text":"<p>A BlueGreen Rollout keeps the old ReplicaSet up and running for 30 seconds or the value of the scaleDownDelaySeconds. The controller tracks the remaining time before scaling down by adding an annotation called <code>argo-rollouts.argoproj.io/scale-down-deadline</code> to the old ReplicaSet. If the user applies the old Rollout manifest before the old ReplicaSet scales down, the controller does something called a fast rollback. The controller immediately switches the active service\u2019s selector back to the old ReplicaSet\u2019s rollout-pod-template-hash and removes the scaled down annotation from that ReplicaSet. The controller does not do any of the normal operations when trying to introduce a new version since it is trying to revert as fast as possible. A non-fast-track rollback occurs when the scale down annotation has past and the old ReplicaSet has been scaled down. In this case, the Rollout treats the ReplicaSet like any other new ReplicaSet and follows the usual procedure for deploying a new ReplicaSet.</p>"},{"location":"FAQ/#what-is-the-argo-rolloutsargoprojiomanaged-by-rollouts-annotation","title":"What is the <code>argo-rollouts.argoproj.io/managed-by-rollouts</code> annotation?","text":"<p>Argo Rollouts adds an <code>argo-rollouts.argoproj.io/managed-by-rollouts</code> annotation to Services and Ingresses that the controller modifies. They are used when the Rollout managing these resources is deleted and the controller tries to revert them back into their previous state.</p>"},{"location":"FAQ/#rollbacks","title":"Rollbacks","text":""},{"location":"FAQ/#does-argo-rollouts-write-back-in-git-when-a-rollback-takes-place","title":"Does Argo Rollouts write back in Git when a rollback takes place?","text":"<p>No. Argo Rollouts doesn't read/write anything to Git. Actually Argo Rollouts knows nothing about Git repositories (only Argo CD has this information if it manages the Rollout). When a rollback takes place, Argo Rollouts marks the application as \"degraded\" and changes the version on the cluster back to the known stable one.</p>"},{"location":"FAQ/#if-i-use-both-argo-rollouts-and-argo-cd-wouldnt-i-have-an-endless-loop-in-the-case-of-a-rollback","title":"If I use both Argo Rollouts and Argo CD wouldn't I have an endless loop in the case of a Rollback?","text":"<p>No there is no endless loop. As explained already in the previous question, Argo Rollouts doesn't tamper with Git in any way. If you use both Argo projects together, the sequence of events for a rollback is the following:</p> <ol> <li>Version N runs on the cluster as a Rollout (managed by Argo CD). The Git repository is updated with version N+1 in the Rollout/Deployment manifest</li> <li>Argo CD sees the changes in Git and updates the live state in the cluster with the new Rollout object</li> <li>Argo Rollouts takes over as it watches for all changes in Rollout Objects. Argo Rollouts is completely oblivious to what is happening in Git. It only cares about what is happening with Rollout objects that are live in the cluster.</li> <li>Argo Rollouts tries to apply version N+1 with the selected strategy (e.g. blue/green)</li> <li>Version N+1 fails to deploy for some reason</li> <li>Argo Rollouts scales back again (or switches traffic back) to version N in the cluster. No change in Git takes place from Argo Rollouts</li> <li>Cluster is running version N and is completely healthy</li> <li>The Rollout is marked as \"Degraded\" both in ArgoCD and Argo Rollouts.</li> <li>Argo CD syncs take no further action as the Rollout object in Git is exactly the same as in the cluster. They both mention version N+1</li> </ol>"},{"location":"FAQ/#so-how-can-i-make-argo-rollouts-write-back-in-git-when-a-rollback-takes-place","title":"So how can I make Argo Rollouts write back in Git when a rollback takes place?","text":"<p>You don't need to do that if you simply want to go back to the previous version using Argo CD. When a deployment fails, Argo Rollouts automatically sets the cluster back to the stable/previous version as explained in the previous question. You don't need to write anything in Git to achieve this. The cluster is still healthy and you have avoided downtime. You are then expected to fix the issue and roll-forward (i.e. deploy the next version) if you want to follow GitOps in a pedantic manner. If you want Argo Rollouts to write back in Git after a failed deployment then you need to orchestrate this with an external system or write custom glue code. But this is normally not needed.</p>"},{"location":"FAQ/#what-is-the-relationship-between-rollbacks-with-argo-rollouts-and-rollbacks-with-argo-cd","title":"What is the relationship between Rollbacks with Argo Rollouts and Rollbacks with Argo CD?","text":"<p>They are completely unrelated. Argo Rollouts \"rollbacks\" switch the cluster back to the previous version as explained in the previous question. They don't touch or affect Git in any way. Argo CD rollbacks simply point the cluster back a previous Git hash. Normally if you have Argo Rollouts, you don't need to use the Argo CD rollback command.</p>"},{"location":"FAQ/#how-can-i-deploy-multiple-services-in-a-single-step-and-roll-them-back-according-to-their-dependencies","title":"How can I deploy multiple services in a single step and roll them back according to their dependencies?","text":"<p>The Rollout specification focuses on a single application/deployment. Argo Rollouts knows nothing about application dependencies. If you want to deploy multiple applications together in a smart way (e.g. automatically rollback a frontend if backend deployment fails) you need to write your own solution on top of Argo Rollouts. In most cases, you would need one Rollout resource for each application that you are deploying. Ideally you should also make your services backwards and forwards compatible (i.e. frontend should be able to work with both backend-preview and backend-active).</p>"},{"location":"FAQ/#how-can-i-run-my-own-custom-tests-eg-smoke-tests-to-decide-if-a-rollback-should-take-place-or-not","title":"How can I run my own custom tests (e.g. smoke tests) to decide if a Rollback should take place or not?","text":"<p>Use a custom Job or Web Analysis. You can pack all your smoke tests in a single container and run them as a Job analysis. Argo Rollouts will use the results of the analysis to automatically rollback if the tests fail.</p>"},{"location":"FAQ/#experiments","title":"Experiments","text":""},{"location":"FAQ/#why-doesnt-my-experiment-end","title":"Why doesn't my Experiment end?","text":"<p>An Experiment\u2019s duration is controlled by the <code>.spec.duration</code> field and the analyses created for the Experiment. The <code>.spec.duration</code> indicates how long the ReplicaSets created by the Experiment should run. Once the duration passes, the experiment scales down the ReplicaSets it created and marks the AnalysisRuns successful unless the <code>requiredForCompletion</code> field is used in the Experiment. If enabled, the ReplicaSets are still scaled-down, but the Experiment does not finish until the Analysis Run finishes.</p> <p>Additionally, the <code>.spec.duration</code> is an optional field. If it\u2019s left unset, and the Experiment creates no AnalysisRuns, the ReplicaSets run indefinitely. The Experiment creates AnalysisRuns without the <code>requiredForCompletion</code> field, the Experiment fails only when the AnalysisRun created fails or errors out. If the <code>requiredForCompletion</code> field is set, the Experiment only marks itself as Successful and scales down the created ReplicaSets when the AnalysisRun finishes Successfully.</p> <p>Additionally, an Experiment ends if the <code>.spec.terminate</code> field is set to true regardless of the state of the Experiment.</p>"},{"location":"FAQ/#analysis","title":"Analysis","text":""},{"location":"FAQ/#why-doesnt-my-analysisrun-end","title":"Why doesn't my AnalysisRun end?","text":"<p>The AnalysisRun\u2019s duration is controlled by the metrics specified. Each Metric can specify an interval, count, and various limits (ConsecutiveErrorLimit, InconclusiveLimit, FailureLimit). If the interval is omitted, the AnalysisRun takes a single measurement. The count indicates how many measurements should be taken and causes the AnalysisRun to run indefinitely if omitted. The ConsecutiveErrorLimit, InconclusiveLimit, and FailureLimit define the thresholds allowed before putting the rollout into a completed state.</p> <p>Additionally, an AnalysisRun ends if the <code>.spec.terminate</code> field is set to true regardless of the state of the AnalysisRun.</p>"},{"location":"FAQ/#what-is-the-difference-between-failures-and-errors","title":"What is the difference between failures and errors?","text":"<p>Failures are when the failure condition evaluates to true or an AnalysisRun without a failure condition evaluates the success condition to false. Errors are when the controller has any kind of issue with taking a measurement (i.e. invalid Prometheus URL).</p>"},{"location":"architecture/","title":"Architecture","text":"<p>Here is an overview of all the components that take part in a deployment managed by Argo Rollouts.</p> <p></p>"},{"location":"architecture/#argo-rollouts-controller","title":"Argo Rollouts controller","text":"<p>This is the main controller that monitors the cluster for events and reacts whenever a resource of type <code>Rollout</code> is changed. The controller will read all the details of the rollout and bring the cluster to the same state as described in the rollout definition.</p> <p>Note that Argo Rollouts will not tamper with or respond to any changes that happen on normal Deployment Resources. This means that you can install Argo Rollouts in a cluster that is also deploying applications with alternative methods.</p> <p>To install the controller in your cluster and get started with Progressive Delivery, see the Installation page.</p>"},{"location":"architecture/#rollout-resource","title":"Rollout resource","text":"<p>The Rollout resource is a custom Kubernetes resource introduced and managed by Argo Rollouts. It is mostly compatible with the native Kubernetes Deployment resource but with extra fields that control the stages, thresholds and methods of advanced deployment methods such as canaries and blue/green deployments.</p> <p>Note that the Argo Rollouts controller will only respond to those changes that happen in Rollout sources. It will do nothing for normal deployment resources. This means that you need to migrate your Deployments to Rollouts if you want to manage them with Argo Rollouts.</p> <p>You can see all possible options of a Rollout in the full specification page.</p>"},{"location":"architecture/#replica-sets-for-old-and-new-version","title":"Replica sets for old and new version","text":"<p>These are instances of the standard Kubernetes ReplicaSet resources. Argo Rollouts puts some extra metadata on them in order to keep track of the different versions that are part of an application.</p> <p>Note also that the replica sets that take part in a Rollout are fully managed by the controller in an automatic way. You should not tamper with them with external tools.</p>"},{"location":"architecture/#ingressservice","title":"Ingress/Service","text":"<p>This is the mechanism that traffic from live users enters your cluster and is redirected to the appropriate version. Argo Rollouts use the standard Kubernetes service resource, but with some extra metadata needed for management.</p> <p>Argo Rollouts is very flexible on networking options. First of all you can have different services during a Rollout, that go only to the new version, only to the old version or both. Specifically for Canary deployments, Argo Rollouts supports several service mesh and ingress solutions for splitting traffic with specific percentages instead of simple balancing based on pod counts and it is possible to use multiple routing providers simultaneously.</p>"},{"location":"architecture/#analysistemplate-and-analysisrun","title":"AnalysisTemplate and AnalysisRun","text":"<p>Analysis is the capability to connect a Rollout to your metrics provider and define specific thresholds for certain metrics that will decide if an update is successful or not. For each analysis you can define one or more metric queries along with their expected results. A Rollout will progress on its own if metric queries are good, rollback automatically if metrics show failure and pause the rollout if metrics cannot provide a success/failure answer.</p> <p>For performing an analysis, Argo Rollouts includes two custom Kubernetes resources: <code>AnalysisTemplate</code> and <code>AnalysisRun</code>.</p> <p><code>AnalysisTemplate</code> contains instructions on what metrics to query. The actual result that is attached to a Rollout is the <code>AnalysisRun</code> custom resource. You can define an <code>AnalysisTemplate</code> on a specific Rollout or globally on the cluster to be shared by multiple rollouts as a <code>ClusterAnalysisTemplate</code>. The <code>AnalysisRun</code> resource is scoped on a specific rollout.</p> <p>Note that using an analysis and metrics in a Rollout is completely optional. You can manually pause and promote a rollout or use other external methods (e.g. smoke tests) via the API or the CLI. You don't need a metric solution just to use Argo Rollouts. You can also mix both automated (i.e. analysis based) and manual steps in a Rollout.</p> <p>Apart from metrics, you can also decide the success of a rollout by running a Kubernetes job or running a webhook.</p>"},{"location":"architecture/#metric-providers","title":"Metric providers","text":"<p>Argo Rollouts includes native integration for several popular metrics providers that you can use in the Analysis resources to automatically promote or rollback  a rollout. See the documentation of each provider for specific setup options.</p>"},{"location":"architecture/#cli-and-ui-not-shown-in-the-diagram","title":"CLI and UI (Not shown in the diagram)","text":"<p>You can view and manage Rollouts with the Argo Rollouts CLI or the integrated UI. Both are optional.</p>"},{"location":"best-practices/","title":"Best Practices","text":"<p>This document describes some best practices, tips and tricks when using Argo Rollouts. Be sure to read the FAQ page as well.</p>"},{"location":"best-practices/#check-application-compatibility","title":"Check application compatibility","text":"<p>Argo Rollouts is a great solution for applications that your team is deploying in a continuous manner (and you have access to the source code). Before using Argo Rollouts you need to contact the developers of the application and verify that you can indeed run multiple versions of the same application at the same time. </p> <p>Not all applications can work with Argo Rollouts. Applications that use shared resources (e.g. writing to a shared file) will have issues, and \"worker\" type applications (that load data from queues) will rarely work ok without source code modifications.</p> <p>Note that using Argo Rollouts for \"infrastructure\" applications such as cert-manager, nginx, coredns, sealed-secrets etc is NOT recommended.</p>"},{"location":"best-practices/#understand-the-scope-of-argo-rollouts","title":"Understand the scope of Argo Rollouts","text":"<p>Currently Argo Rollouts works with a single Kubernetes deployment/application and within a single cluster only. You also need to have the controller deployed on every cluster where a Rollout is running if have more than one clusters using Rollout workloads.</p> <p>If you want to look at multiple-services on multiple clusters see discussion at issues 2737, 451 and 2088.</p> <p>Note also that Argo Rollouts is a self-contained solution. It doesn't need Argo CD or any other Argo project to work.</p>"},{"location":"best-practices/#understand-your-use-case","title":"Understand your use case","text":"<p>Argo Rollouts is perfect for all progressive delivery scenarios as explained in the concepts page.</p> <p>You should NOT use Argo Rollouts for preview/ephemeral environments. For that use case check the Argo CD Pull Request generator.</p> <p>The recommended way to use Argo Rollouts is for brief deployments that take 15-20 minutes or maximum 1-2 hours. If you want to run new versions for days or weeks before deciding to promote, then Argo Rollouts is probably not the best solution for you.</p> <p>Keeping parallel releases for long times, complicates the deployment process a lot and opens several questions where different people have different views on how Argo Rollouts should work.</p> <p>For example let's say that you are testing for a week version 1.3 as stable and 1.4 as preview. Then somebody deploys 1.5</p> <ol> <li>Some people believe that the new state should be 1.3 stable and 1.5 as preview</li> <li>Some people believe that the new state should be 1.4 stable and 1.5 as preview</li> </ol> <p>Currently Argo Rollouts follows the first approach, under the assumption that something was really wrong with 1.4 and 1.5 is the hotfix. </p> <p>And then let's say that 1.5 has an issue. Some people believe that Argo rollouts should \"rollback\" to 1.3 while other people think it should rollback to 1.4</p> <p>Currently Argo Rollouts assumes that the version to rollback is always 1.3 regardless of how many \"hotfixes\" have been previewed in-between.</p> <p>All these problems are not present if you make the assumption that each release stays active only for a minimal time and you always create one new version when the previous one has finished.</p> <p>Also, if you want to run a wave of multiple versions at the same time (i.e. have 1.1 and 1.2 and 1.3 running at the same time), know that Argo Rollouts was not designed for this scenario. Argo Rollouts always works with the assumption that there is one stable/previous version and one preview/next version.</p> <p>A version that has just been promoted is assumed to be ready for production and has already passed all your tests (either manual or automated).</p>"},{"location":"best-practices/#prepare-your-metrics","title":"Prepare your metrics","text":"<p>The end-goal for using Argo Rollouts is to have fully automated deployments that also include rollbacks when needed.</p> <p>While Argo Rollouts supports manual promotions and other manual pauses, these are best used for experimentation and test reasons.</p> <p>Ideally you should have proper metrics that tell you in 5-15 minutes if a deployment is successful or not. If you don't have those metrics, then you will miss a lot of value from Argo Rollouts.</p> <p>If you are doing a deployment right now and then have an actual human looking at logs/metrics/traces for the next 2 hours, adopting Argo Rollouts is not going to help you a lot with automated deployments.</p> <p>Get your metrics in place first and test them with dry-runs before applying them to production deployments.</p>"},{"location":"best-practices/#there-is-no-argo-rollouts-api","title":"There is no \"Argo Rollouts API\"","text":"<p>A lot of people want to find an official API for managing Rollouts. There isn't any separate Argo Rollouts API. You can always use the Kubernetes API and patching of resources if you want to control a rollout.</p> <p>But as explained in the previous point the end goal should be fully automated deployments without you having to tell Argo Rollouts to promote or abort.</p>"},{"location":"best-practices/#integrating-with-other-systems-and-processes","title":"Integrating with other systems and processes","text":"<p>There are two main ways to integrate other systems with Argo Rollouts.</p> <p>The easiest way is to use Notifications. This means that when a rollout is finished/aborted you send a notification to another system that does other tasks that you want to happen.</p> <p>Alternatively you can control Rollouts with the CLI or by patching manually the Kubernetes resources.</p>"},{"location":"best-practices/#use-the-kubernetes-downward-api","title":"Use the Kubernetes Downward API","text":"<p>If you want your applications to know if they are part of a canary or not, you can use Ephemeral labels along with the Kubernetes downward api.</p> <p>This means that your application will read from files its configuration in a dynamic manner and adapt according to the situation.</p>"},{"location":"best-practices/#ingress-desiredstable-host-routes","title":"Ingress desired/stable host routes","text":"<p>For various reasons, it is often desired that external services are able to reach the desired pods (aka canary/preview) or stable pods specifically, without the possibility of traffic arbitrarily being split between the two versions. Some use cases include:</p> <ul> <li>The new version of the service is able to be reach internally/privately (e.g. for manual verification),   before exposing it externally.</li> <li>An external CI/CD pipeline runs tests against the blue-green preview stack before it is   promoted to production.</li> <li>Running tests which compare the behavior of old version against the new version.</li> </ul> <p>If you are using an Ingress to route traffic to the service, additional host rules can be added to the ingress rules so that it is possible to specifically reach to the desired (canary/preview) pods or stable pods.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: guestbook\nspec:\n  rules:\n  # host rule to only reach the desired pods (aka canary/preview)\n  - host: guestbook-desired.argoproj.io\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: guestbook-desired\n            port:\n              number: 443\n\n  # host rule to only reach the stable pods\n  - host: guestbook-stable.argoproj.io\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: guestbook-stable\n            port:\n              number: 443\n\n  # default rule which omits host, and will split traffic between desired vs. stable\n  - http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: guestbook-root\n            port:\n            number: 443\n</code></pre> <p>The above technique has the a benefit in that it would not incur additional cost of allocating additional load balancers.</p>"},{"location":"best-practices/#reducing-operator-memory-usage","title":"Reducing operator memory usage","text":"<p>On clusters with thousands of rollouts memory usage for the argo-rollouts controller can be reduced significantly by changing the <code>RevisionHistoryLimit</code> property from the default of 10 to a lower number. </p> <p>One user of Argo Rollouts saw a 27% reduction in memory usage for a cluster with 1290 rollouts by changing <code>RevisionHistoryLimit</code> from 10 to 0.</p>"},{"location":"best-practices/#rollout-a-configmap-change","title":"Rollout a ConfigMap change","text":"<p>Argo Rollouts is meant to work on a Kubernetes Deployment. When a ConfigMap is mounted inside one the Deployment container and a change occurs inside the ConfigMap, it won't trigger a new Rollout by default.</p> <p>One technique to trigger the Rollout it to name dynamically the ConfigMap. For example, adding a hash of its content at the end of the name:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: my-config-7270e14e6\n</code></pre> <p>Each time a change occurs in the ConfigMap, its name will change in the Deployment reference as well, triggering a Rollout.</p> <p>However, it's not enough to perform correctly progressive rollouts, as the old ConfigMap might get deleted as soon as the new one is created. This would prevent Experiments and rollbacks in case of rollout failure to work correctly.</p> <p>While no magical solution exist to work aroud that, you can tweak your deployment tool to remove the ConfigMap only when the Rollout is completed successfully.</p> <p>Example with Argo CD:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: my-config-7270e14e6\n  annotations:\n    argocd.argoproj.io/sync-options: PruneLast=true\n</code></pre>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/#rollout","title":"Rollout","text":"<p>A Rollout is Kubernetes workload resource which is equivalent to a Kubernetes Deployment object. It is intended to replace a Deployment object in scenarios when more advanced deployment or progressive delivery functionality is needed. A Rollout provides the following features which a Kubernetes Deployment cannot:</p> <ul> <li>blue-green deployments</li> <li>canary deployments</li> <li>integration with ingress controllers and service meshes for advanced traffic routing</li> <li>integration with metric providers for blue-green &amp; canary analysis</li> <li>automated promotion or rollback based on successful or failed metrics</li> </ul>"},{"location":"concepts/#progressive-delivery","title":"Progressive Delivery","text":"<p>Progressive delivery is the process of releasing updates of a product in a controlled and gradual manner, thereby reducing the risk of the release, typically coupling automation and metric analysis to drive the automated promotion or rollback of the update.</p> <p>Progressive delivery is often described as an evolution of continuous delivery, extending the speed benefits made in CI/CD to the deployment process. This is accomplished by limiting the exposure of the new version to a subset of users, observing and analyzing for correct behavior, then progressively increasing the exposure to a broader and wider audience while continuously verifying correctness.</p>"},{"location":"concepts/#deployment-strategies","title":"Deployment Strategies","text":"<p>While the industry has used a consistent terminology to describe various deployment strategies, the implementations of these strategies tend to differ across tooling. To make it clear how the Argo Rollouts will behave, here are the descriptions of the various deployment strategy implementations. Argo Rollouts only supports Blue-Green and Canary.</p>"},{"location":"concepts/#rolling-update","title":"Rolling Update","text":"<p>A <code>RollingUpdate</code> slowly replaces the old version with the new version. As the new version comes up, the old version is scaled down in order to maintain the overall count of the application. This is the default strategy of the Deployment object.</p>"},{"location":"concepts/#recreate","title":"Recreate","text":"<p>A Recreate deployment deletes the old version of the application before bring up the new version. As a result, this ensures that two versions of the application never run at the same time, but there is downtime during the deployment.</p>"},{"location":"concepts/#blue-green","title":"Blue-Green","text":"<p>A Blue-Green deployment (sometimes referred to as a Red-Black) has both the new and old version of the application deployed at the same time.  During this time, only the old version of the application will receive production traffic. This allows the developers to run tests against the new version before switching the live traffic to the new version.</p> <p></p>"},{"location":"concepts/#canary","title":"Canary","text":"<p>A Canary deployment exposes a subset of users to the new version of the application while serving the rest of the traffic to the old version. Once the new version is verified to be correct, the new version can gradually replace the old version. Ingress controllers and service meshes such as NGINX and Istio, enable more sophisticated traffic shaping patterns for canarying than what is natively available (e.g. achieving very fine-grained traffic splitting, or splitting based on HTTP headers).</p> <p></p> <p>The picture above shows a canary with two stages (10% and 33% of traffic goes to new version) but this is just an example. With Argo Rollouts you can define the exact number of stages and percentages of traffic according to your use case.</p>"},{"location":"concepts/#which-strategy-to-choose","title":"Which strategy to choose","text":"<p>In general Blue/Green is the easier strategy to start with, but also the more limited. We recommend you start with Blue/Green deployments first and as you gain confidence for your metrics and applications switch to Canaries.</p> <p>You also need to examine if your application can handle canaries or not.</p> <ul> <li>Blue/Green always works because only one application is active at a time. Not all applications can have different versions running in parallel at the same time (which is what canaries are doing). This can be a showstopper for adopting canary deployments especially for legacy applications.</li> <li>Blue/Green is simpler because you can get their full value WITHOUT a traffic manager. While canaries can also work without a traffic manager, most of their advanced features assume a fine-grained way to control traffic. If you don't have a traffic manager, then you can easily get the full value of blue/green deployments but only the basic capabilities of canaries.</li> <li>Blue/Green also works with services that use queues and databases (workers that fetch tasks). Argo Rollouts doesn't control traffic flow for connections it doesn't understand (i.e. binary/queue channels).</li> </ul> <p>Here is a summary table for the possible approaches.</p> Blue/Green Basic Canary Canary with Traffic manager Adoption Complexity Low Medium High Flexibility Low High Maximum Needs traffic provider No No Yes Works with queue workers Yes No No Works with shared/locked resources Yes No No Traffic switch All or nothing Gradual percentage Gradual percentage Traffic control 0% or 100% coarse grained fine grained Traffic depends on deployment state number of canary pods Any split option is possible Advanced routing scenarios No No Yes Failure Blast Radius Massive impact Low impact Low impact <p>Note that that traffic manager can be any compatible Service Mesh or Ingress Controller or Gateway API implementation (via a plugin).</p>"},{"location":"dashboard/","title":"UI Dashboard","text":"<p>The Argo Rollouts Kubectl plugin can serve a local UI Dashboard to visualize your Rollouts.</p> <p>To start it, run <code>kubectl argo rollouts dashboard</code> in the namespace that contains your Rollouts. Then visit <code>localhost:3100</code> to view the user interface.</p>"},{"location":"dashboard/#list-view","title":"List view","text":""},{"location":"dashboard/#individual-rollout-view","title":"Individual Rollout view","text":""},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will demonstrate various concepts and features of Argo Rollouts by going through deployment, upgrade, promotion, and abortion of a Rollout.</p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes cluster with argo-rollouts controller installed (see install guide)</li> <li>kubectl with argo-rollouts plugin installed (see install guide)</li> </ul>"},{"location":"getting-started/#1-deploying-a-rollout","title":"1. Deploying a Rollout","text":"<p>First we deploy a Rollout resource and a Kubernetes Service targeting that Rollout. The example Rollout in this guide utilizes a canary update strategy which sends 20% of traffic to the canary, followed by a manual promotion, and finally gradual automated traffic increases for the remainder of the upgrade. This behavior is described in the following portion of the Rollout spec:</p> <pre><code>spec:\n  replicas: 5\n  strategy:\n    canary:\n      steps:\n      - setWeight: 20\n      - pause: {}\n      - setWeight: 40\n      - pause: {duration: 10}\n      - setWeight: 60\n      - pause: {duration: 10}\n      - setWeight: 80\n      - pause: {duration: 10}\n</code></pre> <p>Run the following command to deploy the initial Rollout and Service:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/basic/rollout.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/basic/service.yaml\n</code></pre> <p>Initial creations of any Rollout will immediately scale up the replicas to 100% (skipping any canary upgrade steps, analysis, etc...) since there was no upgrade that occurred.</p> <p>The Argo Rollouts kubectl plugin allows you to visualize the Rollout, its related resources (ReplicaSets, Pods, AnalysisRuns), and presents live state changes as they occur. To watch the rollout as it deploys, run the <code>get rollout --watch</code> command from plugin:</p> <p><pre><code>kubectl argo rollouts get rollout rollouts-demo --watch\n</code></pre> </p>"},{"location":"getting-started/#2-updating-a-rollout","title":"2. Updating a Rollout","text":"<p>Next it is time to perform an update. Just as with Deployments, any change to the Pod template field (<code>spec.template</code>) results in a new version (i.e. ReplicaSet) to be deployed. Updating a Rollout involves modifying the rollout spec, typically changing the container image field with a new version, and then running  <code>kubectl apply</code> against the new manifest. As a convenience, the rollouts plugin provides a <code>set image</code> command, which performs these steps against the live rollout object in-place. Run the following command to update the <code>rollouts-demo</code> Rollout with the \"yellow\" version of the container:</p> <pre><code>kubectl argo rollouts set image rollouts-demo \\\n  rollouts-demo=argoproj/rollouts-demo:yellow\n</code></pre> <p>During a rollout update, the controller will progress through the steps defined in the Rollout's update strategy. The example rollout sets a 20% traffic weight to the canary, and pauses the rollout indefinitely until user action is taken to unpause/promote the rollout. After updating the image,  watch the rollout again until it reaches the paused state:</p> <pre><code>kubectl argo rollouts get rollout rollouts-demo --watch\n</code></pre> <p></p> <p>When the demo rollout reaches the second step, we can see from the plugin that the Rollout is in a paused state, and now has 1 of 5 replicas running the new version of the pod template, and 4 of 5 replicas running the old version. This equates to the 20% canary weight as defined by the <code>setWeight: 20</code> step.</p>"},{"location":"getting-started/#3-promoting-a-rollout","title":"3. Promoting a Rollout","text":"<p>The rollout is now in a paused state. When a Rollout reaches a <code>pause</code> step with no duration, it  will remain in a paused state indefinitely until it is resumed/promoted. To manually promote a rollout to the next step, run the <code>promote</code> command of the plugin:</p> <pre><code>kubectl argo rollouts promote rollouts-demo\n</code></pre> <p>After promotion, Rollout will proceed to execute the remaining steps. The remaining rollout steps in our example are fully automated, so the Rollout will eventually complete steps until it has has fully transitioned to the new version. Watch the rollout again until it has completed all steps:</p> <pre><code>kubectl argo rollouts get rollout rollouts-demo --watch\n</code></pre> <p></p> <p>Tip</p> <p>The <code>promote</code> command also supports the ability to skip all remaining steps and analysis with the <code>--full</code> flag.</p> <p>Once all steps complete successfully, the new ReplicaSet is marked as the \"stable\" ReplicaSet. Whenever a rollout is aborted during an update, either automatically via a failed canary analysis, or manually by a user, the Rollout will fall back to the \"stable\" version.</p>"},{"location":"getting-started/#4-aborting-a-rollout","title":"4. Aborting a Rollout","text":"<p>Next we will learn how to manually abort a rollout during an update. First, deploy a new \"red\" version of the container using the <code>set image</code> command, and wait for the rollout to reach the paused step again:</p> <pre><code>kubectl argo rollouts set image rollouts-demo \\\n  rollouts-demo=argoproj/rollouts-demo:red\n</code></pre> <p></p> <p>This time, instead of promoting the rollout to the next step, we will abort the update, so that it falls back to the \"stable\" version. The plugin provides an <code>abort</code> command as a way to manually abort a rollout at any time during an update:</p> <pre><code>kubectl argo rollouts abort rollouts-demo\n</code></pre> <p>When a rollout is aborted, it will scale up the \"stable\" version of the ReplicaSet (in this case the yellow image), and scale down any other versions. Although the stable version of the ReplicaSet may be running and is healthy, the overall rollout is still considered <code>Degraded</code>,  since the desired version (the red image) is not the version which is actually running.</p> <p></p> <p>In order to make Rollout considered Healthy again and not Degraded, it is necessary to change the desired state back to the previous, stable version. This typically involves running <code>kubectl apply</code> against the previous Rollout spec. In our case, we can simply re-run the <code>set image</code> command using the previous, \"yellow\" image.</p> <pre><code>kubectl argo rollouts set image rollouts-demo \\\n  rollouts-demo=argoproj/rollouts-demo:yellow\n</code></pre> <p>After running this command, you should notice that the Rollout immediately becomes Healthy, and there is no activity with regards to new ReplicaSets becoming created.</p> <p></p> <p>When a Rollout has not yet reached its desired state (e.g. it was aborted, or in the middle of an update), and the stable manifest were re-applied, the Rollout detects this as a rollback  and not a update, and will fast-track the deployment of the stable ReplicaSet by skipping analysis, and the steps.</p>"},{"location":"getting-started/#summary","title":"Summary","text":"<p>In this guide, we have learned basic capabilities of Argo Rollouts, including:</p> <ul> <li>Deploying a rollout</li> <li>Performing a canary update</li> <li>Manual promotion</li> <li>Manual abortion </li> </ul> <p>The Rollout in this basic example did not utilize a ingress controller or service mesh provider to route traffic. Instead, it used normal Kubernetes Service networking (i.e. kube-proxy) to achieve an approximate canary weight, based on the closest ratio of new to old replica counts. As a result, this Rollout had a limitation in that it could only achieve a minimum canary weight of 20%, by scaling 1 of 5 pods to run the new version. In order to achieve much finer grained canaries, an ingress controller or service mesh is necessary.</p> <p>Follow one of the traffic routing guides to see how Argo Rollouts can leverage a networking provider to achieve more advanced traffic shaping.</p> <ul> <li>ALB Guide</li> <li>App Mesh Guide</li> <li>Ambassador Guide</li> <li>Istio Guide</li> <li>Multiple Providers Guide</li> <li>NGINX Guide</li> <li>SMI Guide</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#controller-installation","title":"Controller Installation","text":"<p>Two types of installation:</p> <ul> <li>install.yaml - Standard installation method. <pre><code>kubectl create namespace argo-rollouts\nkubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml\n</code></pre></li> </ul> <p>This will create a new namespace, <code>argo-rollouts</code>, where Argo Rollouts controller will run.</p> <p>Tip</p> <p>If you are using another namespace name, please update <code>install.yaml</code> clusterrolebinding's serviceaccount namespace name.</p> <p>Tip</p> <p>When installing Argo Rollouts on Kubernetes v1.14 or lower, the CRD manifests must be kubectl applied with the --validate=false option. This is caused by use of new CRD fields introduced in v1.15, which are rejected by default in lower API servers.</p> <p>Tip</p> <p>On GKE, you will need grant your account the ability to create new cluster roles:</p> <pre><code>kubectl create clusterrolebinding YOURNAME-cluster-admin-binding --clusterrole=cluster-admin --user=YOUREMAIL@gmail.com\n</code></pre> <ul> <li>namespace-install.yaml - Installation of Argo Rollouts which requires only namespace level privileges. An example usage of this installation method would be to run several Argo Rollouts controller instances in different namespaces on the same cluster.</li> </ul> <p>Note: Argo Rollouts CRDs are not included into namespace-install.yaml. and have to be installed separately. The CRD manifests are located in manifests/crds directory. Use the following command to install them: <pre><code>kubectl apply -k https://github.com/argoproj/argo-rollouts/manifests/crds\\?ref\\=stable\n</code></pre></p> <p>You can find released container images of the controller at Quay.io. There are also old releases at Dockerhub, but since the introduction of rate limiting, the Argo project has moved to Quay.</p>"},{"location":"installation/#kubectl-plugin-installation","title":"Kubectl Plugin Installation","text":"<p>The kubectl plugin is optional, but is convenient for managing and visualizing rollouts from the command line.</p>"},{"location":"installation/#brew","title":"Brew","text":"<pre><code>brew install argoproj/tap/kubectl-argo-rollouts\n</code></pre>"},{"location":"installation/#manual","title":"Manual","text":"<ol> <li> <p>Install Argo Rollouts Kubectl plugin with curl.     <pre><code>curl -LO https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-darwin-amd64\n</code></pre></p> <p>For Linux dist, replace <code>darwin</code> with <code>linux</code></p> </li> <li> <p>Make the kubectl-argo-rollouts binary executable.</p> <pre><code>chmod +x ./kubectl-argo-rollouts-darwin-amd64\n</code></pre> </li> <li> <p>Move the binary into your PATH.</p> <pre><code>sudo mv ./kubectl-argo-rollouts-darwin-amd64 /usr/local/bin/kubectl-argo-rollouts\n</code></pre> </li> </ol> <p>Test to ensure the version you installed is up-to-date:</p> <pre><code>kubectl argo rollouts version\n</code></pre>"},{"location":"installation/#shell-auto-completion","title":"Shell auto completion","text":"<p>To enable auto completion for the plugin when used with <code>kubectl</code> (version 1.26 or newer), you need to create a shell script on your PATH called <code>kubectl_complete-argo-rollouts</code> which will provide the completions.</p> <pre><code>cat &lt;&lt;EOF &gt;kubectl_complete-argo-rollouts\n#!/usr/bin/env sh\n\n# Call the __complete command passing it all arguments\nkubectl argo rollouts __complete \"\\$@\"\nEOF\n\nchmod +x kubectl_complete-argo-rollouts\nsudo mv ./kubectl_complete-argo-rollouts /usr/local/bin/\n</code></pre> <p>To enable auto completion for the CLI run as a standalone binary, the CLI can export shell completion code for several shells.</p> <p>For bash, ensure you have bash completions installed and enabled. To access completions in your current shell, run $ <code>source &lt;(kubectl-argo-rollouts completion bash)</code>. Alternatively, write it to a file and source in <code>.bash_profile</code>.</p> <p>The completion command supports bash, zsh, fish and powershell.</p> <p>See the completion command documentation for more details.</p>"},{"location":"installation/#using-the-cli-with-docker","title":"Using the CLI  with Docker","text":"<p>The CLI is also available as a container image at https://quay.io/repository/argoproj/kubectl-argo-rollouts</p> <p>You can run it like any other Docker image or use it in any CI platform that supports Docker images.</p> <pre><code>docker run quay.io/argoproj/kubectl-argo-rollouts:master version\n</code></pre>"},{"location":"installation/#supported-versions","title":"Supported versions","text":"<p>Check e2e testing file to see what the Kubernetes version is being fully tested.</p> <p>You can switch to different tags to see what relevant Kubernetes versions were being tested for the respective version.</p>"},{"location":"installation/#upgrading-argo-rollouts","title":"Upgrading Argo Rollouts","text":"<p>Argo Rollouts is a Kubernetes controller that doesn't hold any external state. It is active only when deployments are actually happening.</p> <p>To upgrade Argo Rollouts:</p> <ol> <li>Try to find a time period when no deployments are happening</li> <li>Delete the previous version of the controller and apply/install the new one</li> <li>When a new Rollout takes place the new controller will be activated.</li> </ol> <p>If deployments are happening while you upgrade the controller, then you shouldn't have any downtime. Current Rollouts will be paused and as soon as the new controller becomes active it will resume all in-flight deployments.</p>"},{"location":"migrating/","title":"Migrating to Rollouts","text":"<p>There are ways to migrate to Rollout:</p> <ul> <li>Convert an existing Deployment resource to a Rollout resource.</li> <li>Reference an existing Deployment from a Rollout using <code>workloadRef</code> field.</li> </ul>"},{"location":"migrating/#convert-deployment-to-rollout","title":"Convert Deployment to Rollout","text":"<p>When converting a Deployment to a Rollout, it involves changing three fields:</p> <ol> <li>Replacing the <code>apiVersion</code> from <code>apps/v1</code> to <code>argoproj.io/v1alpha1</code></li> <li>Replacing the <code>kind</code> from <code>Deployment</code> to <code>Rollout</code></li> <li>Replacing the deployment strategy with a blue-green or canary strategy</li> </ol> <p>Below is an example of a Rollout resource using the canary strategy.</p> <pre><code>apiVersion: argoproj.io/v1alpha1  # Changed from apps/v1\nkind: Rollout                     # Changed from Deployment\nmetadata:\n  name: rollouts-demo\nspec:\n  selector:\n    matchLabels:\n      app: rollouts-demo\n  template:\n    metadata:\n      labels:\n        app: rollouts-demo\n    spec:\n      containers:\n      - name: rollouts-demo\n        image: argoproj/rollouts-demo:blue\n        ports:\n        - containerPort: 8080\n  strategy:\n    canary:                        # Changed from rollingUpdate or recreate\n      steps:\n      - setWeight: 20\n      - pause: {}\n</code></pre> <p>Warning</p> <p>When migrating a Deployment which is already serving live production traffic, a Rollout should run next to the Deployment before deleting the Deployment or scaling down the Deployment. Not following this approach might result in downtime. It also allows for the Rollout to be tested before deleting the original Deployment.</p>"},{"location":"migrating/#reference-deployment-from-rollout","title":"Reference Deployment From Rollout","text":"<p>Instead of removing Deployment you can scale it down to zero and reference it from the Rollout resource:</p> <ol> <li>Create a Rollout resource.</li> <li>Reference an existing Deployment using <code>workloadRef</code> field.</li> <li>In the <code>workloadRef</code> field set the <code>scaleDown</code> attribute, which specifies how the Deployment should be scaled down. There are three options available:</li> <li><code>never</code>: the Deployment is not scaled down</li> <li><code>onsuccess</code>: the Deployment is scaled down after the Rollout becomes healthy</li> <li><code>progressively</code>: as the Rollout is scaled up the Deployment is scaled down.</li> </ol> <p>Alternatively, manually scale down an existing Deployment by changing replicas field of an existing Deployment to zero. 1. To perform an update, the change should be made to the Pod template field of the Deployment.</p> <p>Below is an example of a Rollout resource referencing a Deployment.</p> <pre><code>apiVersion: argoproj.io/v1alpha1               # Create a rollout resource\nkind: Rollout\nmetadata:\n  name: rollout-ref-deployment\nspec:\n  replicas: 5\n  selector:\n    matchLabels:\n      app: rollout-ref-deployment\n  workloadRef:                                 # Reference an existing Deployment using workloadRef field\n    apiVersion: apps/v1\n    kind: Deployment\n    name: rollout-ref-deployment\n    scaleDown: onsuccess\n  strategy:\n    canary:\n      steps:\n        - setWeight: 20\n        - pause: {duration: 10s}\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app.kubernetes.io/instance: rollout-canary\n  name: rollout-ref-deployment\nspec:\n  replicas: 0                                  # Scale down existing deployment\n  selector:\n    matchLabels:\n      app: rollout-ref-deployment\n  template:\n    metadata:\n      labels:\n        app: rollout-ref-deployment\n    spec:\n      containers:\n        - name: rollouts-demo\n          image: argoproj/rollouts-demo:blue\n          imagePullPolicy: Always\n          ports:\n            - containerPort: 8080\n</code></pre> <p>Consider following if your Deployment runs in production:</p>"},{"location":"migrating/#running-rollout-and-deployment-side-by-side","title":"Running Rollout and Deployment side-by-side","text":"<p>After creation Rollout will spinup required number of Pods side-by-side with the Deployment Pods. Rollout won't try to manage existing Deployment Pods. That means you can safely update add Rollout to the production environment without any interruption but you are going to run twice more Pods during migration.</p> <p>Argo-rollouts controller patches the spec of rollout object with an annotation of <code>rollout.argoproj.io/workload-generation</code>, which equals the generation of referenced deployment. Users can detect if the rollout matches desired generation of deployment by checking the <code>workloadObservedGeneration</code> in the rollout status.</p>"},{"location":"migrating/#traffic-management-during-migration","title":"Traffic Management During Migration","text":"<p>The Rollout offers traffic management functionality that manages routing rules and flows the traffic to different versions of an application. For example Blue-Green deployment strategy manipulates Kubernetes Service selector and direct production traffic to \"green\" instances only.</p> <p>If you are using this feature then Rollout switches production\u00a0traffic to Pods that it manages. The switch happens only when the required number of Pod is running and healthy so it is safe in production as well. However, if you want to be extra careful then consider creating a temporal Service or Ingress object to validate Rollout behavior. Once testing is done delete temporal Service/Ingress and switch rollout to production one.</p>"},{"location":"migrating/#migrating-to-deployments","title":"Migrating to Deployments","text":"<p>In case users want to rollback to the deployment kinds from rollouts, there are two scenarios aligned with those in Migrating to Rollouts.</p> <ul> <li>Convert a Rollout resource to a Deployment resource.</li> <li>Reference an existing Deployment from a Rollout using <code>workloadRef</code> field.</li> </ul>"},{"location":"migrating/#convert-rollout-to-deployment","title":"Convert Rollout to Deployment","text":"<p>When converting a Rollout to a Deployment, it involves changing three fields:</p> <ol> <li>Changing the apiVersion from  argoproj.io/v1alpha1 to apps/v1</li> <li>Changing the kind from Rollout to Deployment</li> <li>Remove the rollout strategy in <code>spec.strategy.canary</code> or <code>spec.strategy.blueGreen</code></li> </ol> <p>Warning</p> <p>When migrating a Rollout which is already serving live production traffic, a Deployment should run next to the rollout before deleting the rollout or scaling down the rollout. Not following this approach might result in downtime. It also allows for the Deployment to be tested before deleting the original Rollout.</p>"},{"location":"migrating/#reference-deployment-from-rollout_1","title":"Reference Deployment From Rollout","text":"<p>When a rollout is referencing to a deployment:</p> <ol> <li>Scale-up an existing Deployment by changing its <code>replicas</code> field to a desired number of pods.</li> <li>Wait for the Deployment pods to become Ready.</li> <li>Scale-down an existing Rollout by changing its <code>replicas</code> field to zero.</li> </ol> <p>Please refer to Running Rollout and Deployment side-by-side and Traffic Management During Migration for caveats.</p>"},{"location":"plugins/","title":"Creating an Argo Rollouts Plugin","text":""},{"location":"plugins/#high-level-overview","title":"High Level Overview","text":"<p>Argo Rollouts plugins depend on hashicorp's go-plugin library. This library provides a way for a plugin to be compiled as a standalone executable and then loaded by the rollouts controller at runtime. This works by having the plugin executable act as a rpc server and the rollouts controller act as a client. The plugin executable is started by the rollouts controller and is a long-lived process and that the rollouts controller connects to over a unix socket.</p> <p>Here is an overview of how plugins are loaded:</p> <p></p> <p>The communication protocol uses golang built in net/rpc library so plugins have to be written in golang.</p>"},{"location":"plugins/#plugin-repository","title":"Plugin Repository","text":"<p>In order to get plugins listed in the main argo rollouts documentation we ask that the plugin repository be created under the argoproj-labs organization. Please open an issue under argo-rollouts requesting a repo which you would be granted admin access on.</p> <p>There is also a standard naming convention for plugin names used for configmap registration, as well as what the plugin uses for locating its specific configuration on rollout or analysis resources. The name needs to be in the form of <code>&lt;namespace&gt;/&lt;name&gt;</code> and both  and  have a regular expression check that matches Github's requirements for <code>username/org</code> and <code>repository name</code>. This requirement is in place to help with allowing multiple creators of the same plugin types to exist such as <code>&lt;org1&gt;/nginx</code> and <code>&lt;org2&gt;/nginx</code>. These names could be based of the repo name such as <code>argoproj-labs/rollouts-plugin-metric-sample-prometheus</code> but it is not a requirement. <p>There will also be a standard for naming repositories under argoproj-labs in the form of <code>rollouts-plugin-&lt;type&gt;-&lt;tool&gt;</code> where <code>&lt;type&gt;</code> is say <code>metric</code>, or <code>trafficrouter</code> and <code>&lt;tool&gt;</code> is the software the plugin is for say nginx.</p>"},{"location":"plugins/#plugin-name","title":"Plugin Name","text":"<p>So now that we have an idea on plugin naming and repository standards let's pick a name to use for the rest of this documentation and call our plugin <code>argoproj-labs/nginx</code>.</p> <p>This name will be used in a few different spots the first is the config map that your plugin users will need to configure. It looks like this below.</p> <pre><code>kind: ConfigMap\nmetadata:\n  name: argo-rollouts-config\ndata:\n  metricProviderPlugins: |-\n    - name: \"argoproj-labs/metrics\"\n      location: \"file:///tmp/argo-rollouts/metric-plugin\"\n      args:\n        - \"--log-level\"\n        - \"debug\"\n  trafficRouterPlugins: |-\n    - name: \"argoproj-labs/nginx\"\n      location: \"file:///tmp/argo-rollouts/traffic-plugin\"\n      args:\n        - \"--log-level\"\n        - \"debug\"\n</code></pre> <p>As you can see there is a field called <code>name:</code> under both <code>metrics</code> or <code>trafficrouters</code> this is the first place where your end users will need to configure the name of the plugin. The second <code>location</code> is either in the rollout object or the analysis template which you can see the examples below. The third <code>args</code> holds the command line arguments of the plugin.</p>"},{"location":"plugins/#analysistemplate-example","title":"AnalysisTemplate Example","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  metrics:\n    - name: success-rate\n      ...\n      provider:\n        plugin:\n          argoproj-labs/metrics:\n            address: http://prometheus.local\n</code></pre>"},{"location":"plugins/#traffic-router-example","title":"Traffic Router Example","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: example-plugin-ro\nspec:\n  strategy:\n    canary:\n      canaryService: example-plugin-ro-canary-analysis\n      stableService: example-plugin-ro-stable-analysis\n      trafficRouting:\n        plugins:\n          argoproj-labs/nginx:\n            stableIngress: canary-demo\n</code></pre> <p>You can see that we use the plugin name under <code>spec.metrics[].provider.plugin</code> for analysis template and <code>spec.strategy.canary.trafficRouting.plugins</code> for traffic routers. You as a plugin author can then put any configuration you need under <code>argoproj-labs/nginx</code> and you will be able to look up that config in your plugin via the plugin name key. You will also want to document what configuration options your plugin supports.</p>"},{"location":"plugins/#plugin-interfaces","title":"Plugin Interfaces","text":"<p>Argo Rollouts currently supports two plugin systems as a plugin author your end goal is to implement these interfaces as a hashicorp go-plugin. The two interfaces are <code>MetricsPlugin</code> and <code>TrafficRouterPlugin</code> for each of the respective plugins:</p> <pre><code>type MetricProviderPlugin interface {\n  // InitPlugin initializes the traffic router plugin this gets called once when the plugin is loaded.\n  InitPlugin() RpcError\n  // Run start a new external system call for a measurement\n  // Should be idempotent and do nothing if a call has already been started\n  Run(*v1alpha1.AnalysisRun, v1alpha1.Metric) v1alpha1.Measurement\n  // Resume Checks if the external system call is finished and returns the current measurement\n  Resume(*v1alpha1.AnalysisRun, v1alpha1.Metric, v1alpha1.Measurement) v1alpha1.Measurement\n  // Terminate will terminate an in-progress measurement\n  Terminate(*v1alpha1.AnalysisRun, v1alpha1.Metric, v1alpha1.Measurement) v1alpha1.Measurement\n  // GarbageCollect is used to garbage collect completed measurements to the specified limit\n  GarbageCollect(*v1alpha1.AnalysisRun, v1alpha1.Metric, int) RpcError\n  // Type gets the provider type\n  Type() string\n  // GetMetadata returns any additional metadata which providers need to store/display as part\n  // of the metric result. For example, Prometheus uses is to store the final resolved queries.\n  GetMetadata(metric v1alpha1.Metric) map[string]string\n}\n\ntype TrafficRouterPlugin interface {\n  // InitPlugin initializes the traffic router plugin this gets called once when the plugin is loaded.\n  InitPlugin() RpcError\n  // UpdateHash informs a traffic routing reconciler about new canary, stable, and additionalDestination(s) pod hashes\n  UpdateHash(rollout *v1alpha1.Rollout, canaryHash, stableHash string, additionalDestinations []v1alpha1.WeightDestination) RpcError\n  // SetWeight sets the canary weight to the desired weight\n  SetWeight(rollout *v1alpha1.Rollout, desiredWeight int32, additionalDestinations []v1alpha1.WeightDestination) RpcError\n  // SetHeaderRoute sets the header routing step\n  SetHeaderRoute(rollout *v1alpha1.Rollout, setHeaderRoute *v1alpha1.SetHeaderRoute) RpcError\n  // SetMirrorRoute sets up the traffic router to mirror traffic to a service\n  SetMirrorRoute(rollout *v1alpha1.Rollout, setMirrorRoute *v1alpha1.SetMirrorRoute) RpcError\n  // VerifyWeight returns true if the canary is at the desired weight and additionalDestinations are at the weights specified\n  // Returns nil if weight verification is not supported or not applicable\n  VerifyWeight(rollout *v1alpha1.Rollout, desiredWeight int32, additionalDestinations []v1alpha1.WeightDestination) (RpcVerified, RpcError)\n  // RemoveManagedRoutes Removes all routes that are managed by rollouts by looking at spec.strategy.canary.trafficRouting.managedRoutes\n  RemoveManagedRoutes(ro *v1alpha1.Rollout) RpcError\n  // Type returns the type of the traffic routing reconciler\n  Type() string\n}\n</code></pre>"},{"location":"plugins/#plugin-init-function","title":"Plugin Init Function","text":"<p>Each plugin interface has a <code>InitPlugin</code> function, this function is called when the plugin is first started up and is only called once per startup. The <code>InitPlugin</code> function is used as a means to initialize the plugin it gives you the plugin author the ability to either set up a client for a specific metrics provider or in the case of a traffic router construct a client or informer for kubernetes api. The one thing to note about this though is because these calls happen over RPC the plugin author should not depend on state being stored in the plugin struct as it will not be persisted between calls.</p>"},{"location":"plugins/#kubernetes-rbac","title":"Kubernetes RBAC","text":"<p>The plugin runs as a child process of the rollouts controller and as such it will inherit the same RBAC permissions as the controller. This means that the service account for the rollouts controller will need the correct permissions for the plugin to function. This might mean instructing users to create a role and role binding to the standard rollouts service account for the plugin to use. This will probably affect traffic router plugins more than metrics plugins.</p>"},{"location":"plugins/#sample-plugins","title":"Sample Plugins","text":"<p>There are two sample plugins within the argo-rollouts repo that you can use as a reference for creating your own plugin.</p> <ul> <li>Metrics Plugin Sample</li> <li>Traffic Router Plugin Sample</li> </ul>"},{"location":"releasing/","title":"Releasing","text":"<ol> <li> <p>Ensure that the <code>release branch</code> already exist.</p> </li> <li> <p>Checkout the release branch. Example: <code>git fetch upstream &amp;&amp; git    checkout release-1.5</code></p> </li> <li> <p>Run the script found at <code>hack/trigger-release.sh</code> as follows:</p> </li> </ol> <pre><code>./hack/trigger-release.sh &lt;version&gt; &lt;remote name&gt;\n</code></pre> <p>Example: <pre><code>./hack/trigger-release.sh v1.6.0-rc1 upstream\n</code></pre></p> <p>Tip</p> <p>The tag must be in one of the following formats to trigger the GH workflow: * GA: <code>v&lt;MAJOR&gt;.&lt;MINOR&gt;.&lt;PATCH&gt;</code> * Pre-release: <code>v&lt;MAJOR&gt;.&lt;MINOR&gt;.&lt;PATCH&gt;-rc&lt;RC#&gt;</code></p> <p>Once the script is executed successfully, a GitHub workflow will start execution. You can follow its progress under the Actions tab, the name of the action is <code>Release</code>.</p> <ol> <li>When the action completes, visit the generated draft Github releases and enter the details about the release:</li> <li>Getting started (copy from previous release and new version)</li> <li>Changelog</li> </ol>"},{"location":"releasing/#update-brew-formula","title":"Update Brew formula","text":"<ol> <li> <p>Update Brew formula:</p> </li> <li> <p>Fork the repo https://github.com/argoproj/homebrew-tap</p> </li> <li>Run the following commands to update the brew formula:     <pre><code>cd homebrew-tap\n./update.sh kubectl-argo-rollouts $VERSION\n</code></pre></li> <li>If there is a new minor version we want to update the versioned formula as well:<ul> <li>Run the following commands to update the versioned brew formula:       <pre><code>./update.sh kubectl-argo-rollouts $VERSION @&lt;version_without_patch_and_v&gt;\n</code></pre></li> <li>Example: If the new version is <code>v1.3.2</code>, we want to update the formula for <code>v1.3</code> as well.      <pre><code>./update.sh kubectl-argo-rollouts v1.3.2 @1.3\n</code></pre></li> </ul> </li> <li>Commit and push the changes to your fork      <pre><code>git commit -am \"Update kubectl-argo-rollouts to $VERSION\"\n</code></pre></li> <li>Create a PR with the modified files pointing to upstream/master</li> <li>Once the PR is approved by a maintainer, it can be merged.</li> </ol>"},{"location":"releasing/#verify","title":"Verify","text":"<ol> <li> <p>Install locally using the command below and follow the Getting Started Guide:</p> <pre><code>kubectl apply -n argo-rollouts -f https://github.com/argoproj/argo-rollouts/releases/download/${VERSION}/install.yaml\n</code></pre> </li> <li> <p>Check the Kubectl Argo Rollout plugin:     <pre><code>brew upgrade kubectl-argo-rollouts\nkubectl argo rollouts version\n</code></pre></p> </li> </ol>"},{"location":"analysis/cloudwatch/","title":"CloudWatch Metrics","text":"<p>Important</p> <p>Available since v1.1.0</p> <p>A CloudWatch using GetMetricData can be used to obtain measurements for analysis.</p>"},{"location":"analysis/cloudwatch/#setup","title":"Setup","text":"<p>You can use CloudWatch Metrics if you have used to EKS or not. This analysis is required IAM permission for <code>cloudwatch:GetMetricData</code> and you need to define <code>AWS_REGION</code> in Deployment for <code>argo-rollouts</code>.</p>"},{"location":"analysis/cloudwatch/#eks","title":"EKS","text":"<p>If you create new cluster on EKS, you can attach cluster IAM role or attach IAM roles for service accounts. If you have already cluster on EKS, you can attach IAM roles for service accounts.</p>"},{"location":"analysis/cloudwatch/#not-eks","title":"not EKS","text":"<p>You need to define access key and secret key.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: cloudwatch-secret\ntype: Opaque\nstringData:\n  AWS_ACCESS_KEY_ID: &lt;aws-access-key-id&gt;\n  AWS_SECRET_ACCESS_KEY: &lt;aws-secret-access-key&gt;\n  AWS_REGION: &lt;aws-region&gt;\n</code></pre> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: argo-rollouts\nspec:\n  template:\n    spec:\n      containers:\n      - name: argo-rollouts\n        env:\n        - name: AWS_ACCESS_KEY_ID\n          valueFrom:\n            secretKeyRef:\n              name: cloudwatch-secret\n              key: AWS_ACCESS_KEY_ID\n        - name: AWS_SECRET_ACCESS_KEY\n          valueFrom:\n            secretKeyRef:\n              name: cloudwatch-secret\n              key: AWS_SECRET_ACCESS_KEY\n        - name: AWS_REGION\n          valueFrom:\n            secretKeyRef:\n              name: cloudwatch-secret\n              key: AWS_REGION\n</code></pre>"},{"location":"analysis/cloudwatch/#configuration","title":"Configuration","text":"<ul> <li><code>metricDataQueries</code> - GetMetricData query: MetricDataQuery</li> <li><code>interval</code> - optional interval, e.g. 30m, default: 5m</li> </ul> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  metrics:\n  - name: success-rate\n    interval: 1m\n    successCondition: \"len(result[0].Values) &gt;= 5 and all(result[0].Values, {# &lt;= 0.01})\"\n    failureLimit: 3\n    provider:\n      cloudWatch:\n        interval: 30m\n        metricDataQueries:\n        - {\n            \"id\": \"rate\",\n            \"expression\": \"errors / requests\"\n          }\n        - {\n            \"id\": \"errors\",\n            \"metricStat\": {\n              \"metric\": {\n                \"namespace\": \"app\",\n                \"metricName\": \"errors\"\n              },\n              \"period\": 300,\n              \"stat\": \"Sum\",\n              \"unit\": \"Count\"\n            },\n            \"returnData\": false\n          }\n        - {\n            \"id\": \"requests\",\n            \"metricStat\": {\n              \"metric\": {\n                \"namespace\": \"app\",\n                \"metricName\": \"requests\"\n              },\n              \"period\": 300,\n              \"stat\": \"Sum\",\n              \"unit\": \"Count\"\n            },\n            \"returnData\": false\n          }\n</code></pre>"},{"location":"analysis/cloudwatch/#debug","title":"debug","text":"<p>You can confirm the results value in <code>AnalysisRun</code>.</p> <pre><code>$ kubectl get analysisrun/rollouts-name-xxxxxxxxxx-xx -o yaml\n(snip)\nstatus:\n  metricResults:\n  - count: 2\n    failed: 1\n    measurements:\n    - finishedAt: \"2021-09-08T17:29:14Z\"\n      phase: Failed\n      startedAt: \"2021-09-08T17:29:13Z\"\n      value: '[[0.0029476787030213707 0.006100422336931018 0.01020408163265306 0.007932573128408527\n        0.00589622641509434 0.006339144215530904]]'\n    - finishedAt: \"2021-09-08T17:30:14Z\"\n      phase: Successful\n      startedAt: \"2021-09-08T17:30:14Z\"\n      value: '[[0.004484304932735426 0.0058374494836102376 0.006736068585425597 0.008444444444444444\n        0.006859756097560976 0.0045385779122541605]]'\n    name: success-rate\n    phase: Running\n    successful: 1\n  phase: Running\n  startedAt: \"2021-09-08T17:29:14Z\"\n</code></pre>"},{"location":"analysis/datadog/","title":"Datadog Metrics","text":"<p>A Datadog query can be used to obtain measurements for analysis.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: loq-error-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: error-rate\n    interval: 5m\n    successCondition: result &lt;= 0.01\n    failureLimit: 3\n    provider:\n      datadog:\n        apiVersion: v2\n        interval: 5m\n        query: |\n          sum:requests.error.rate{service:{{args.service-name}}}\n</code></pre> <p>The field <code>apiVersion</code> refers to the API version of Datadog (v1 or v2). Default value is <code>v1</code> if this is omitted. See \"Working with Datadog API v2\" below for more information.</p> <p>Datadog api and app tokens can be configured in a kubernetes secret in argo-rollouts namespace.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: datadog\ntype: Opaque\nstringData:\n  address: https://api.datadoghq.com\n  api-key: &lt;datadog-api-key&gt;\n  app-key: &lt;datadog-app-key&gt;\n</code></pre> <p><code>apiVersion</code> here is different from the <code>apiVersion</code> from the Datadog configuration above.</p> <p>Important</p> <p>Let me know if there's anything else you'd like to adjust!</p> <pre><code>```yaml\napiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: loq-error-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: error-rate\n    interval: 5m\n    successCondition: result &lt;= 0.01\n    failureLimit: 3\n    provider:\n      datadog:\n        apiVersion: v2\n        interval: 5m\n        secretRef:\n          name: \"mysecret\"\n          namespaced: true\n        query: |\n          sum:requests.error.rate{service:{{args.service-name}}}\n```\n</code></pre>"},{"location":"analysis/datadog/#namespaced-secret","title":"Namespaced secret","text":"<p>Datadog integration supports referring to secrets inside the same namespace as argo-rollouts (by default) or referring to a secret in the same namespace as the <code>AnalysisTemplate</code>.</p> <p>To use a secret from the <code>AnalysisTemplate</code> namespace, include a <code>secretRef</code> section in the template, specifying the <code>name</code> of the secret and setting the <code>namespaced</code> property to <code>true</code>.</p> <p>The process for retrieving Datadog credentials is as follows: 1. If a <code>secretRef</code> is defined in the <code>AnalysisTemplate</code>: Argo Rollouts will search for the secret with the specified name in the namespace where the template resides. 2. If the secret is not found in the specified namespace: Argo Rollouts will then check the environment variables. 3. If the credentials are not found in environment variables: Argo Rollouts will look for a secret named \"Datadog\" in the namespace where Argo Rollouts itself is deployed.</p>"},{"location":"analysis/datadog/#working-with-datadog-api-v2","title":"Working with Datadog API v2","text":"<p>Important</p> <p>While some basic v2 functionality is working in earlier versions, the new properties of <code>formula</code> and <code>queries</code> are only available as of v1.7</p>"},{"location":"analysis/datadog/#moving-to-v2","title":"Moving to v2","text":"<p>If your old v1 was just a simple metric query - no formula as part of the query - then you can just move to v2 by updating the <code>apiVersion</code> in your existing Analysis Template, and everything should work.</p> <p>If you have a formula, you will need to update how you configure your metric. Here is a before/after example of what your Analysis Template should look like:</p> <p>Before:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: log-error-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: error-rate\n    interval: 30s\n    successCondition: default(result, 0) &lt; 10\n    failureLimit: 3\n    provider:\n      datadog:\n        apiVersion: v1\n        interval: 5m\n        query: \"moving_rollup(sum:requests.errors{service:{{args.service-name}}}.as_count(), 60, 'sum') / sum:requests{service:{{args.service-name}}}.as_count()\"\n</code></pre> <p>After:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: loq-error-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: error-rate\n    # Polling rate against the Datadog API\n    interval: 30s\n    successCondition: default(result, 0) &lt; 10\n    failureLimit: 3\n    provider:\n      datadog:\n        apiVersion: v2\n        # The window of time we are looking at in DD. Basically we will fetch data from (now-5m) to now.\n        interval: 5m\n        queries:\n          a: sum:requests.errors{service:{{args.service-name}}}.as_count()\n          b: sum:requests{service:{{args.service-name}}}.as_count()\n        formula: \"moving_rollup(a, 60, 'sum') / b\"\n</code></pre>"},{"location":"analysis/datadog/#examples","title":"Examples","text":"<p>Simple v2 query with no formula</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: canary-container-restarts\nspec:\n  args:\n    # This is set in rollout using the valueFrom: podTemplateHashValue functionality\n    - name: canary-hash\n    - name: service-name\n    - name: restarts.initial-delay\n      value: \"60s\"\n    - name: restarts.max-restarts\n      value: \"4\"\n  metrics:\n    - name: kubernetes.containers.restarts\n      initialDelay: \"{{ args.restarts.initial-delay }}\"\n      interval: 15s\n      failureCondition: default(result, 0) &gt; {{ args.restarts.max-restarts }}\n      failureLimit: 0\n      provider:\n        datadog:\n          apiVersion: v2\n          interval: 5m\n          queries:\n            # The key is arbitrary - you will use this key to refer to the query if you use a formula.\n            q: \"max:kubernetes.containers.restarts{service-name:{{args.service-name}},rollouts_pod_template_hash:{{args.canary-hash}}}\"\n</code></pre>"},{"location":"analysis/datadog/#tips","title":"Tips","text":""},{"location":"analysis/datadog/#datadog-results","title":"Datadog Results","text":"<p>Datadog queries can return empty results if the query takes place during a time interval with no metrics. The Datadog provider will return a <code>nil</code> value yielding an error during the evaluation phase like:</p> <pre><code>invalid operation: &lt; (mismatched types &lt;nil&gt; and float64)\n</code></pre> <p>However, empty query results yielding a <code>nil</code> value can be handled using the <code>default()</code> function. Here is a succeeding example using the <code>default()</code> function:</p> <pre><code>successCondition: default(result, 0) &lt; 0.05\n</code></pre>"},{"location":"analysis/datadog/#metric-aggregation-v2-only","title":"Metric aggregation (v2 only)","text":"<p>By default, Datadog analysis run is configured to use <code>last</code> metric aggregator when querying Datadog v2 API. This value can be overriden by specifying a new <code>aggregator</code> value from a list of supported aggregators (<code>avg,min,max,sum,last,percentile,mean,l2norm,area</code>) for the V2 API (docs).</p> <p>For example, using count-based distribution metric (<code>count:metric{*}.as_count()</code>) with values <code>1,9,3,7,5</code> in a given <code>interval</code> will make <code>last</code> aggregator return <code>5</code>. To return a sum of all values (<code>25</code>), set <code>aggregator: sum</code> in Datadog provider block and use <code>moving_rollup()</code> function to aggregate values in the specified rollup interval. These functions can be combined in a <code>formula</code> to perform additional calculations:</p> <pre><code>...&lt;snip&gt;\n  metrics:\n  - name: error-percentage\n    interval: 30s\n    successCondition: default(result, 0) &lt; 5\n    failureLimit: 3\n    provider:\n      datadog:\n        apiVersion: v2\n        interval: 5m\n        aggregator: sum # override default aggregator\n        queries:\n          a: count:requests.errors{service:my-service}.as_count()\n          b: count:requests{service:my-service}.as_count()\n        formula: \"moving_rollup(a, 300, 'sum') / moving_rollup(b, 300, 'sum') * 100\" # percentage of requests with errors\n</code></pre>"},{"location":"analysis/datadog/#templates-and-helm","title":"Templates and Helm","text":"<p>Helm and Argo Rollouts both try to parse things between <code>{{ ... }}</code> when rendering templates. If you use Helm to deliver your manifests, you will need to escape <code>{{ args.whatever }}</code>. Using the example above, here it is set up for Helm:</p> <pre><code>...&lt;snip&gt;\nmetrics:\n  - name: kubernetes.containers.restarts\n      initialDelay: \"{{ `{{ args.restarts.initial-delay }}` }}\"\n    interval: 15s\n      failureCondition: default(result, 0) &gt; {{ `{{ args.restarts.max-restarts }}` }}\n    failureLimit: 0\n    provider:\n      datadog:\n        apiVersion: v2\n        interval: 5m\n        queries:\n          q: \"{{ `max:kubernetes.containers.restarts{kube_app_name:{{args.kube_app_name}},rollouts_pod_template_hash:{{args.canary-hash}}}` }}\"\n</code></pre>"},{"location":"analysis/datadog/#rate-limits","title":"Rate Limits","text":"<p>For the <code>v1</code> API, you ask for an increase on the <code>api/v1/query</code> route.</p> <p>For the <code>v2</code> API, the Ratelimit-Name you ask for an increase in is the <code>query_scalar_public</code>.</p>"},{"location":"analysis/graphite/","title":"Graphite Metrics","text":"<p>A Graphite query can be used to obtain measurements for analysis.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: success-rate\n    interval: 5m\n    # Note that the Argo Rollouts Graphite metrics provider returns results as an array of float64s with 6 decimal places.\n    successCondition: results[0] &gt;= 90.000000\n    failureLimit: 3\n    provider:\n      graphite:\n        address: http://graphite.example.com:9090\n        query: |\n          target=summarize(\n            asPercent(\n              sumSeries(\n                stats.timers.httpServerRequests.app.{{args.service-name}}.exception.*.method.*.outcome.{CLIENT_ERROR,INFORMATIONAL,REDIRECTION,SUCCESS}.status.*.uri.*.count\n              ),\n              sumSeries(\n                stats.timers.httpServerRequests.app.{{args.service-name}}.exception.*.method.*.outcome.*.status.*.uri.*.count\n              )\n            ),\n            '5min',\n            'avg'\n          )\n</code></pre>"},{"location":"analysis/influxdb/","title":"InfluxDB Metrics","text":"<p>An InfluxDB query using Flux can be used to obtain measurements for analysis.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: error-rate\nspec:\n  args:\n  - name: application-name\n  metrics:\n  - name: error-rate\n    # NOTE: To be consistent with the prometheus metrics provider InfluxDB query results are returned as an array.\n    # In the example we're looking at index 0 of the returned array to obtain the value we're using for the success condition\n    successCondition: result[0] &lt;= 0.01\n    provider:\n      influxdb:\n        profile: my-influxdb-secret  # optional, defaults to 'influxdb'\n        query: |\n          from(bucket: \"app_istio\")\n            |&gt; range(start: -15m)\n            |&gt; filter(fn: (r) =&gt; r[\"destination_workload\"] == \"{{ args.application-name }}\")\n            |&gt; filter(fn: (r) =&gt; r[\"_measurement\"] == \"istio:istio_requests_errors_percentage:rate1m:5xx\")\n</code></pre> <p>An InfluxDB access profile can be configured using a Kubernetes secret in the <code>argo-rollouts</code> namespace. Alternate accounts can be used by creating more secrets of the same format and specifying which secret to use in the metric provider configuration using the <code>profile</code> field.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: influxdb\ntype: Opaque\nstringData:\n  address: &lt;infuxdb-url&gt;\n  authToken: &lt;influxdb-auth-token&gt;\n  org: &lt;influxdb-org&gt;\n</code></pre>"},{"location":"analysis/job/","title":"Job Metrics","text":"<p>A Kubernetes Job can be used to run analysis. When a Job is used, the metric is considered successful if the Job completes and had an exit code of zero, otherwise it is failed.</p> <pre><code>metrics:\n  - name: test\n    provider:\n      job:\n        metadata:\n          annotations:\n            foo: bar # annotations defined here will be copied to the Job object\n          labels:\n            foo: bar # labels defined here will be copied to the Job object\n        spec:\n          backoffLimit: 1\n          template:\n            spec:\n              containers:\n                - name: test\n                  image: my-image:latest\n                  command:\n                    [my-test-script, my-service.default.svc.cluster.local]\n              restartPolicy: Never\n</code></pre>"},{"location":"analysis/job/#control-where-the-jobs-run","title":"Control where the jobs run","text":"<p>Argo Rollouts allows you some control over where your metric job runs.</p> <p>The following env vars can be set on the Rollouts controller:</p> <p><code>ARGO_ROLLOUTS_ANALYSIS_JOB_NAMESPACE</code> will allow you to run your metric jobs in a namespace other than the default (which can vary depending on if you are running Rollouts in cluster mode or not).</p> <p><code>ARGO_ROLLOUTS_ANALYSIS_JOB_KUBECONFIG</code> will allow running metric jobs in a different cluster entirely. This should be a path to the kubeconfig you want to use.</p>"},{"location":"analysis/kayenta/","title":"Kayenta","text":""},{"location":"analysis/kayenta/#kayenta-eg-mann-whitney-analysis","title":"Kayenta (e.g. Mann-Whitney Analysis)","text":"<p>Analysis can also be done as part of an Experiment.</p> <p>This example starts both a canary and baseline ReplicaSet. The ReplicaSets run for 1 hour, then scale down to zero. Call out to Kayenta to perform Mann-Whintney analysis against the two pods. Demonstrates ability to start a short-lived experiment and an asynchronous analysis.</p> <p>This example demonstrates:</p> <ul> <li>The ability to start an Experiment as part of rollout steps, which launches multiple ReplicaSets (e.g. baseline &amp; canary)</li> <li>The ability to reference and supply pod-template-hash to an AnalysisRun</li> <li>Kayenta metrics</li> </ul> Rollout <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\n  labels:\n    app: guestbook\nspec:\n  strategy:\n    canary:\n      steps:\n      - experiment:\n          duration: 1h\n          templates:\n          - name: baseline\n            specRef: stable\n          - name: canary\n            specRef: canary\n          analyses:\n          - templateName: mann-whitney\n            args:\n            - name: stable-hash\n              valueFrom:\n                podTemplateHashValue: Stable\n            - name: canary-hash\n              valueFrom:\n                podTemplateHashValue: Latest\n</code></pre> AnalysisTemplate <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: mann-whitney\nspec:\n  args:\n  - name: start-time\n  - name: end-time\n  - name: stable-hash\n  - name: canary-hash\n  metrics:\n  - name: mann-whitney\n    provider:\n      kayenta:\n        address: https://kayenta.example.com\n        application: guestbook\n        canaryConfigName: my-test\n        thresholds:\n          pass: 90\n          marginal: 75\n        scopes:\n        - name: default\n          controlScope:\n            scope: app=guestbook and rollouts-pod-template-hash={{args.stable-hash}}\n            step: 60\n            start: \"{{args.start-time}}\"\n            end: \"{{args.end-time}}\"\n          experimentScope:\n            scope: app=guestbook and rollouts-pod-template-hash={{args.canary-hash}}\n            step: 60\n            start: \"{{args.start-time}}\"\n            end: \"{{args.end-time}}\"\n</code></pre> Experiment <pre><code># This is the resulting experiment that is produced by the step\napiVersion: argoproj.io/v1alpha1\nkind: Experiment\nname:\n  name: guestbook-6c54544bf9-0\nspec:\n  duration: 1h\n  templates:\n  - name: baseline\n    replicas: 1\n    spec:\n      containers:\n      - name: guestbook\n        image: guestbook:v1\n  - name: canary\n    replicas: 1\n    spec:\n      containers:\n      - name: guestbook\n        image: guestbook:v2\n  analysis:\n    templateName: mann-whitney\n    args:\n    - name: start-time\n      value: \"{{experiment.availableAt}}\"\n    - name: end-time\n      value: \"{{experiment.finishedAt}}\"\n</code></pre> <p>In order to perform multiple kayenta runs over some time duration, the <code>interval</code> and <code>count</code> fields can be supplied. When the <code>start</code> and <code>end</code> fields are omitted from the kayenta scopes, the values will be implicitly decided as:</p> <ul> <li><code>start</code> = if <code>lookback: true</code> start of analysis, otherwise current time - interval</li> <li><code>end</code> = current time</li> </ul> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: mann-whitney\nspec:\n  args:\n  - name: stable-hash\n  - name: canary-hash\n  metrics:\n  - name: mann-whitney\n    provider:\n      kayenta:\n        address: https://kayenta.intuit.com\n        application: guestbook\n        canaryConfigName: my-test\n        interval: 3600\n        count: 3\n        # loopback will cause start time value to be equal to start of analysis\n        # lookback: true\n        thresholds:\n          pass: 90\n          marginal: 75\n        scopes:\n        - name: default\n          controlScope:\n            scope: app=guestbook and rollouts-pod-template-hash={{args.stable-hash}}\n            step: 60\n          experimentScope:\n            scope: app=guestbook and rollouts-pod-template-hash={{args.canary-hash}}\n            step: 60\n</code></pre>"},{"location":"analysis/newrelic/","title":"NewRelic Metrics","text":"<p>Important</p> <p>Available since v0.10.0</p> <p>A New Relic query using NRQL can be used to obtain measurements for analysis.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: application-name\n  metrics:\n  - name: success-rate\n    successCondition: result.successRate &gt;= 0.95\n    provider:\n      newRelic:\n        profile: my-newrelic-secret  # optional, defaults to 'newrelic'\n        query: |\n          FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode != 500) as successRate where appName = '{{ args.application-name }}'\n        timeout: 10 # NRQL query timeout in seconds. Optional, defaults to 5\n</code></pre> <p>The <code>result</code> evaluated for the condition will always be map or list of maps. The name will follow the pattern of either <code>function</code> or <code>function.field</code>, e.g. <code>SELECT average(duration) from Transaction</code> will yield <code>average.duration</code>. In this case the field result cannot be accessed with dot notation and instead should be accessed like <code>result['average.duration']</code>. Query results can be renamed using the NRQL clause <code>AS</code> as seen above.</p> <p>A New Relic access profile can be configured using a Kubernetes secret in the <code>argo-rollouts</code> namespace. Alternate accounts can be used by creating more secrets of the same format and specifying which secret to use in the metric provider configuration using the <code>profile</code> field.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: newrelic\ntype: Opaque\nstringData:\n  personal-api-key: &lt;newrelic-personal-api-key&gt;\n  account-id: &lt;newrelic-account-id&gt;\n  region: \"us\" # optional, defaults to \"us\" if not set. Only set to \"eu\" if you use EU New Relic\n</code></pre> <p>To use the New Relic metric provider from behind a proxy, provide a <code>base-url-rest</code> key pointing to the base URL of the New Relic REST API for your proxy, and a <code>base-url-nerdgraph</code> key pointing to the base URL for NerdGraph for your proxy:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: newrelic\ntype: Opaque\nstringData:\n  personal-api-key: &lt;newrelic-personal-api-key&gt;\n  account-id: &lt;newrelic-account-id&gt;\n  region: \"us\" # optional, defaults to \"us\" if not set. Only set to \"eu\" if you use EU New Relic\n  base-url-rest: &lt;your-base-url&gt;\n  base-url-nerdgraph: &lt;your-base-url&gt;\n</code></pre>"},{"location":"analysis/newrelic/#additional-metadata","title":"Additional Metadata","text":"<p>The New Relic provider returns the below metadata under the <code>Metadata</code> map in the <code>MetricsResult</code> object of <code>AnalysisRun</code>.</p> KEY Description ResolvedNewRelicQuery Resolved query after substituting the template's arguments"},{"location":"analysis/plugins/","title":"Metric Plugins","text":"<p>Important</p> <p>Available since v1.5 - Status: Alpha</p> <p>Argo Rollouts supports getting analysis metrics via 3rd party plugin system. This allows users to extend the capabilities of Rollouts to support metric providers that are not natively supported. Rollout's uses a plugin library called go-plugin to do this. You can find a sample plugin here: rollouts-plugin-metric-sample-prometheus</p>"},{"location":"analysis/plugins/#using-a-metric-plugin","title":"Using a Metric Plugin","text":"<p>There are two methods of installing and using an argo rollouts plugin. The first method is to mount up the plugin executable into the rollouts controller container. The second method is to use a HTTP(S) server to host the plugin executable.</p>"},{"location":"analysis/plugins/#mounting-the-plugin-executable-into-the-rollouts-controller-container","title":"Mounting the plugin executable into the rollouts controller container","text":"<p>There are a few ways to mount the plugin executable into the rollouts controller container. Some of these will depend on your particular infrastructure. Here are a few methods:</p> <ul> <li>Using an init container to download the plugin executable</li> <li>Using a Kubernetes volume mount with a shared volume such as NFS, EBS, etc.</li> <li>Building the plugin into the rollouts controller container</li> </ul> <p>Then you can use the configmap to point to the plugin executable file location. Example:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-config\ndata:\n  metricProviderPlugins: |-\n    - name: \"argoproj-labs/sample-prometheus\" # name of the plugin, it must match the name required by the plugin so it can find it's configuration\n      location: \"file://./my-custom-plugin\" # supports http(s):// urls and file://\n</code></pre>"},{"location":"analysis/plugins/#using-a-https-server-to-host-the-plugin-executable","title":"Using a HTTP(S) server to host the plugin executable","text":"<p>Argo Rollouts supports downloading the plugin executable from a HTTP(S) server. To use this method, you will need to configure the controller via the <code>argo-rollouts-config</code> configmap and set <code>pluginLocation</code> to a http(s) url. Example:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-config\ndata:\n  metricProviderPlugins: |-\n    - name: \"argoproj-labs/sample-prometheus\" # name of the plugin, it must match the name required by the plugin so it can find it's configuration\n      location: \"https://github.com/argoproj-labs/rollouts-plugin-metric-sample-prometheus/releases/download/v0.0.4/metric-plugin-linux-amd64\" # supports http(s):// urls and file://\n      sha256: \"dac10cbf57633c9832a17f8c27d2ca34aa97dd3d\" #optional sha256 checksum of the plugin executable\n</code></pre>"},{"location":"analysis/plugins/#some-words-of-caution","title":"Some words of caution","text":"<p>Depending on which method you use to install and the plugin, there are some things to be aware of. The rollouts controller will not start if it can not download or find the plugin executable. This means that if you are using a method of installation that requires a download of the plugin and the server hosting the plugin for some reason is not available and the rollouts controllers pod got deleted while the server was down or is coming up for the first time, it will not be able to start until the server hosting the plugin is available again.</p> <p>Argo Rollouts will download the plugin at startup only once but if the pod is deleted it will need to download the plugin again on next startup. Running Argo Rollouts in HA mode can help a little with this situation because each pod will download the plugin at startup. So if a single pod gets deleted during a server outage, the other pods will still be able to take over because there will already be a plugin executable available to it. It is the responsibility of the Argo Rollouts administrator to define the plugin installation method considering the risks of each approach.</p>"},{"location":"analysis/plugins/#list-of-available-plugins-alphabetical-order","title":"List of Available Plugins (alphabetical order)","text":""},{"location":"analysis/plugins/#add-your-plugin-here","title":"Add Your Plugin Here","text":"<ul> <li>If you have created a plugin, please submit a PR to add it to this list.</li> </ul>"},{"location":"analysis/plugins/#rollouts-plugin-metric-sample-prometheus","title":"rollouts-plugin-metric-sample-prometheus","text":"<ul> <li>This is just a sample plugin that can be used as a starting point for creating your own plugin. It is not meant to be used in production. It is based on the built-in prometheus provider.</li> </ul>"},{"location":"analysis/prometheus/","title":"Prometheus Metrics","text":"<p>A Prometheus query can be used to obtain measurements for analysis.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: success-rate\n    interval: 5m\n    # NOTE: prometheus queries return results in the form of a vector.\n    # So it is common to access the index 0 of the returned array to obtain the value\n    successCondition: result[0] &gt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        # timeout is expressed in seconds\n        timeout: 40\n        headers:\n        - key: X-Scope-OrgID\n          value: tenant_a\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n</code></pre> <p>The example shows Istio metrics, but you can use any kind of metric available to your prometheus instance. We suggest you validate your PromQL expression using the Prometheus GUI first.</p> <p>See the Analysis Overview page for more details on the available options.</p>"},{"location":"analysis/prometheus/#range-queries","title":"Range queries","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: range-query-example\nspec:\n  args:\n  - name: service-name\n  - name: lookback-duration\n    value: 5m\n  metrics:\n  - name: success-rate\n    # checks that all returned values are under 1000ms\n    successCondition: \"all(result, # &lt; 1000)\"\n    failureLimit: 3\n    provider:\n      prometheus:\n        rangeQuery:\n          # See https://expr-lang.org/docs/language-definition#date-functions\n          # for value date functions\n          # The start point to query from\n          start: 'now() - duration(\"{{args.lookback-duration}}\")'\n          # The end point to query to\n          end: 'now()'\n          # Query resolution width \n          step: 1m\n        address: http://prometheus.example.com:9090\n        query: http_latency_ms{service=\"{{args.service-name}}\"}\n</code></pre>"},{"location":"analysis/prometheus/#range-query-and-successconditionfailurecondition","title":"Range query and successCondition/failureCondition","text":"<p>Since range queries will usually return multiple values from prometheus. It is important to assert on every value returned. See the following examples:</p> <ul> <li>\u274c <code>result[0] &lt; 1000</code> - this will only check the first value returned</li> <li>\u2705 <code>all(result, # &lt; 1000)</code> - checks every value returns from prometheus</li> </ul> <p>See expr for more expression options.</p>"},{"location":"analysis/prometheus/#authorization","title":"Authorization","text":""},{"location":"analysis/prometheus/#utilizing-amazon-managed-prometheus","title":"Utilizing Amazon Managed Prometheus","text":"<p>Amazon Managed Prometheus can be used as the prometheus data source for analysis. In order to do this the namespace where your analysis is running will have to have the appropriate IRSA attached to allow for prometheus queries. Once you ensure the proper permissions are in place to access AMP, you can use an AMP workspace url in your <code>provider</code> block and add a SigV4 config for Sigv4 signing:</p> <pre><code>provider:\n  prometheus:\n    address: https://aps-workspaces.$REGION.amazonaws.com/workspaces/$WORKSPACEID\n    query: |\n      sum(irate(\n        istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n      )) /\n      sum(irate(\n        istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n      ))\n    authentication:\n      sigv4:\n        region: $REGION\n        profile: $PROFILE\n        roleArn: $ROLEARN\n</code></pre>"},{"location":"analysis/prometheus/#with-oauth2","title":"With OAuth2","text":"<p>You can setup an OAuth2 client credential flow using the following values:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  # from secret\n  - name: oauthSecret  # This is the OAuth2 shared secret\n    valueFrom:\n      secretKeyRef:\n        name: oauth-secret\n        key: secret\n  metrics:\n  - name: success-rate\n    interval: 5m\n    # NOTE: prometheus queries return results in the form of a vector.\n    # So it is common to access the index 0 of the returned array to obtain the value\n    successCondition: result[0] &gt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        # timeout is expressed in seconds\n        timeout: 40\n        authentication:\n          oauth2:\n            tokenUrl: https://my-oauth2-provider/token\n            clientId: my-cliend-id\n            clientSecret: \"{{ args.oauthSecret }}\"\n            scopes: [\n              \"my-oauth2-scope\"\n            ]\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n</code></pre> <p>The AnalysisRun will first get an access token using that information, and provide it as an <code>Authorization: Bearer</code> header for the metric provider call.</p>"},{"location":"analysis/prometheus/#additional-metadata","title":"Additional Metadata","text":"<p>Any additional metadata from the Prometheus controller, like the resolved queries after substituting the template's arguments, etc. will appear under the <code>Metadata</code> map in the <code>MetricsResult</code> object of <code>AnalysisRun</code>.</p>"},{"location":"analysis/prometheus/#skip-tls-verification","title":"Skip TLS verification","text":"<p>You can skip the TLS verification of the prometheus host provided by setting the options <code>insecure: true</code>.</p> <pre><code>provider:\n  prometheus:\n    address: https://prometheus.example.com\n    insecure: true\n    query: |\n      sum(irate(\n        istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n      )) /\n      sum(irate(\n        istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n      ))\n</code></pre>"},{"location":"analysis/skywalking/","title":"Apache SkyWalking Metrics","text":"<p>Important</p> <p>Available since v1.5.0</p> <p>A SkyWalking query using GraphQL can be used to obtain measurements for analysis.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: apdex\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: apdex\n    interval: 5m\n    successCondition: \"all(result.service_apdex.values.values, {asFloat(.value) &gt;= 9900})\"\n    failureLimit: 3\n    provider:\n      skywalking:\n        interval: 3m\n        address: http://skywalking-oap.istio-system:12800\n        query: |\n          query queryData($duration: Duration!) {\n            service_apdex: readMetricsValues(\n              condition: { name: \"service_apdex\", entity: { scope: Service, serviceName: \"{{ args.service-name }}\", normal: true } },\n              duration: $duration) {\n                label values { values { value } }\n              }\n          }\n</code></pre> <p>The <code>result</code> evaluated for the query depends on the specific GraphQL you give, you can try to run the GraphQL query first and inspect the output format, then compose the condition.</p>"},{"location":"analysis/wavefront/","title":"Wavefront Metrics","text":"<p>A Wavefront query can be used to obtain measurements for analysis.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: success-rate\n    interval: 5m\n    successCondition: result &gt;= 0.95\n    failureLimit: 3\n    provider:\n      wavefront:\n        address: example.wavefront.com\n        query: |\n          sum(rate(\n            5m, ts(\"istio.requestcount.count\", response_code!=500 and destination_service=\"{{args.service-name}}\"\n          ))) /\n          sum(rate(\n            5m, ts(\"istio.requestcount.count\", reporter=client and destination_service=\"{{args.service-name}}\"\n          )))\n</code></pre> <p>Wavefront api tokens can be configured in a kubernetes secret in argo-rollouts namespace.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: wavefront-api-tokens\ntype: Opaque\nstringData:\n  example1.wavefront.com: &lt;token1&gt;\n  example2.wavefront.com: &lt;token2&gt;\n</code></pre>"},{"location":"analysis/web/","title":"Web Metrics","text":"<p>An HTTP request can be performed against some external service to obtain the measurement. This example makes a HTTP GET request to some URL. The webhook response must return JSON content. The result of the optional <code>jsonPath</code> expression will be assigned to the <code>result</code> variable that can be referenced in the <code>successCondition</code> and <code>failureCondition</code> expressions. If omitted, will use the entire body of the as the result variable.</p> <pre><code>  metrics:\n  - name: webmetric\n    successCondition: result == true\n    provider:\n      web:\n        url: \"http://my-server.com/api/v1/measurement?service={{ args.service-name }}\"\n        timeoutSeconds: 20 # defaults to 10 seconds\n        headers:\n          - key: Authorization\n            value: \"Bearer {{ args.api-token }}\"\n        jsonPath: \"{$.data.ok}\"\n</code></pre> <p>In the following example, given the payload, the measurement will be Successful if the <code>data.ok</code> field was <code>true</code>, and the <code>data.successPercent</code> was greater than <code>0.90</code></p> <pre><code>{\n  \"data\": {\n    \"ok\": true,\n    \"successPercent\": 0.95\n  }\n}\n</code></pre> <pre><code>  metrics:\n  - name: webmetric\n    successCondition: \"result.ok &amp;&amp; result.successPercent &gt;= 0.90\"\n    provider:\n      web:\n        url: \"http://my-server.com/api/v1/measurement?service={{ args.service-name }}\"\n        headers:\n          - key: Authorization\n            value: \"Bearer {{ args.api-token }}\"\n        jsonPath: \"{$.data}\"\n</code></pre> <p>NOTE: if the result is a string, two convenience functions <code>asInt</code> and <code>asFloat</code> are provided to convert a result value to a numeric type so that mathematical comparison operators can be used (e.g. &gt;, &lt;, &gt;=, &lt;=).</p>"},{"location":"analysis/web/#optional-web-methods","title":"Optional web methods","text":"<p>It is possible to use a POST or PUT requests, by specifying the <code>method</code> and either <code>body</code> or <code>jsonBody</code> fields</p> <p><pre><code>  metrics:\n  - name: webmetric\n    successCondition: result == true\n    provider:\n      web:\n        method: POST # valid values are GET|POST|PUT, defaults to GET\n        url: \"http://my-server.com/api/v1/measurement?service={{ args.service-name }}\"\n        timeoutSeconds: 20 # defaults to 10 seconds\n        headers:\n          - key: Authorization\n            value: \"Bearer {{ args.api-token }}\"\n          - key: Content-Type # if body is a json, it is recommended to set the Content-Type\n            value: \"application/json\"\n        body: \"string value\"\n        jsonPath: \"{$.data.ok}\"\n</code></pre>   !!! tip       In order to send in JSON, you can use jsonBody and Content-Type will be automatically set as json.       Setting a <code>body</code> or <code>jsonBody</code> field for a <code>GET</code> request will result in an error.       Set either <code>body</code> or <code>jsonBody</code> and setting both will result in an error.</p> <pre><code>  metrics:\n  - name: webmetric\n    successCondition: result == true\n    provider:\n      web:\n        method: POST # valid values are GET|POST|PUT, defaults to GET\n        url: \"http://my-server.com/api/v1/measurement?service={{ args.service-name }}\"\n        timeoutSeconds: 20 # defaults to 10 seconds\n        headers:\n          - key: Authorization\n            value: \"Bearer {{ args.api-token }}\"\n          - key: Content-Type # if body is a json, it is recommended to set the Content-Type\n            value: \"application/json\"\n        jsonBody: # If using jsonBody Content-Type header will be automatically set to json\n          key1: value_1\n          key2:\n            nestedObj: nested value\n            key3: \"{{ args.service-name }}\"\n        jsonPath: \"{$.data.ok}\"\n</code></pre>"},{"location":"analysis/web/#skip-tls-verification","title":"Skip TLS verification","text":"<p>You can skip the TLS verification of the web host provided by setting the options <code>insecure: true</code>.</p> <pre><code>  metrics:\n  - name: webmetric\n    successCondition: \"result.ok &amp;&amp; result.successPercent &gt;= 0.90\"\n    provider:\n      web:\n        url: \"https://my-server.com/api/v1/measurement?service={{ args.service-name }}\"\n        insecure: true\n        headers:\n          - key: Authorization\n            value: \"Bearer {{ args.api-token }}\"\n        jsonPath: \"{$.data}\"\n</code></pre>"},{"location":"analysis/web/#authorization","title":"Authorization","text":""},{"location":"analysis/web/#with-oauth2","title":"With OAuth2","text":"<p>You can setup an OAuth2 client credential flow using the following values:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  # from secret\n  - name: oauthSecret  # This is the OAuth2 shared secret\n    valueFrom:\n      secretKeyRef:\n        name: oauth-secret\n        key: secret\n  metrics:\n  - name: webmetric\n    successCondition: result == true\n    provider:\n      web:\n        url: \"http://my-server.com/api/v1/measurement?service={{ args.service-name }}\"\n        timeoutSeconds: 20 # defaults to 10 seconds\n        authentication:\n          oauth2:\n            tokenUrl: https://my-oauth2-provider/token\n            clientId: my-cliend-id\n            clientSecret: \"{{ args.oauthSecret }}\"\n            scopes: [\n              \"my-oauth2-scope\"\n            ]\n        headers:\n          - key: Content-Type # if body is a json, it is recommended to set the Content-Type\n            value: \"application/json\"\n        jsonPath: \"{$.data.ok}\"\n</code></pre> <p>In that case, no need to provide specifically the <code>Authentication</code> header. The AnalysisRun will first get an access token using that information, and provide it as an <code>Authorization: Bearer</code> header for the metric provider call.</p>"},{"location":"features/analysis/","title":"Analysis &amp; Progressive Delivery","text":"<p>Argo Rollouts provides several ways to perform analysis to drive progressive delivery. This document describes how to achieve various forms of progressive delivery, varying the point in time analysis is performed, its frequency, and occurrence.</p>"},{"location":"features/analysis/#custom-resource-definitions","title":"Custom Resource Definitions","text":"CRD Description Rollout A <code>Rollout</code> acts as a drop-in replacement for a Deployment resource. It provides additional blueGreen and canary update strategies. These strategies can create AnalysisRuns and Experiments during the update, which will progress the update, or abort it. AnalysisTemplate An <code>AnalysisTemplate</code> is a template spec which defines how to perform a canary analysis, such as the metrics which it should perform, its frequency, and the values which are considered successful or failed. AnalysisTemplates may be parameterized with inputs values. ClusterAnalysisTemplate A <code>ClusterAnalysisTemplate</code> is like an <code>AnalysisTemplate</code>, but it is not limited to its namespace. It can be used by any <code>Rollout</code> throughout the cluster. AnalysisRun An <code>AnalysisRun</code> is an instantiation of an <code>AnalysisTemplate</code>. AnalysisRuns are like Jobs in that they eventually complete. Completed runs are considered Successful, Failed, or Inconclusive, and the result of the run affect if the Rollout's update will continue, abort, or pause, respectively. Experiment An <code>Experiment</code> is limited run of one or more ReplicaSets for the purposes of analysis. Experiments typically run for a pre-determined duration, but can also run indefinitely until stopped. Experiments may reference an <code>AnalysisTemplate</code> to run during or after the experiment. The canonical use case for an Experiment is to start a baseline and canary deployment in parallel, and compare the metrics produced by the baseline and canary pods for an equal comparison."},{"location":"features/analysis/#background-analysis","title":"Background Analysis","text":"<p>Analysis can be run in the background -- while the canary is progressing through its rollout steps.</p> <p>The following example gradually increments the canary weight by 20% every 10 minutes until it reaches 100%. In the background, an <code>AnalysisRun</code> is started based on the <code>AnalysisTemplate</code> named <code>success-rate</code>. The <code>success-rate</code> template queries a prometheus server, measuring the HTTP success rates at 5 minute intervals/samples. It has no end time, and continues until stopped or failed. If the metric is measured to be less than 95%, and there are three such measurements, the analysis is considered Failed. The failed analysis causes the Rollout to abort, setting the canary weight back to zero, and the Rollout would be considered in a <code>Degraded</code>. Otherwise, if the rollout completes all of its canary steps, the rollout is considered successful and the analysis run is stopped by the controller.</p> <p>This example highlights:</p> <ul> <li>Background analysis style of progressive delivery</li> <li>Using a Prometheus query to perform a measurement</li> <li>The ability to parameterize the analysis</li> <li>Delay starting the analysis run until step 3 (Set Weight 40%)</li> </ul> Rollout <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\nspec:\n...\n  strategy:\n    canary:\n      analysis:\n        templates:\n        - templateName: success-rate\n        startingStep: 2 # delay starting analysis run until setWeight: 40%\n        args:\n        - name: service-name\n          value: guestbook-svc.default.svc.cluster.local\n      steps:\n      - setWeight: 20\n      - pause: {duration: 10m}\n      - setWeight: 40\n      - pause: {duration: 10m}\n      - setWeight: 60\n      - pause: {duration: 10m}\n      - setWeight: 80\n      - pause: {duration: 10m}\n</code></pre> AnalysisTemplate <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: success-rate\n    interval: 5m\n    # NOTE: prometheus queries return results in the form of a vector.\n    # So it is common to access the index 0 of the returned array to obtain the value\n    successCondition: result[0] &gt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n</code></pre>"},{"location":"features/analysis/#inline-analysis","title":"Inline Analysis","text":"<p>Analysis can also be performed as a rollout step as an inline \"analysis\" step. When analysis is performed \"inlined,\" an <code>AnalysisRun</code> is started when the step is reached, and blocks the rollout until the run is completed. The success or failure of the analysis run decides if the rollout will proceed to the next step, or abort the rollout completely.</p> <p>This example sets the canary weight to 20%, pauses for 5 minutes, then runs an analysis. If the analysis was successful, continues with rollout, otherwise aborts.</p> <p>This example demonstrates:</p> <ul> <li>The ability to invoke an analysis in-line as part of steps</li> </ul> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\nspec:\n...\n  strategy:\n    canary:\n      steps:\n      - setWeight: 20\n      - pause: {duration: 5m}\n      - analysis:\n          templates:\n          - templateName: success-rate\n          args:\n          - name: service-name\n            value: guestbook-svc.default.svc.cluster.local\n</code></pre> <p>In this example, the <code>AnalysisTemplate</code> is identical to the background analysis example, but since no interval is specified, the analysis will perform a single measurement and complete.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  - name: prometheus-port\n    value: 9090\n  metrics:\n  - name: success-rate\n    successCondition: result[0] &gt;= 0.95\n    provider:\n      prometheus:\n        address: \"http://prometheus.example.com:{{args.prometheus-port}}\"\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n</code></pre> <p>Multiple measurements can be performed over a longer duration period, by specifying the <code>count</code> and <code>interval</code> fields:</p> <pre><code>  metrics:\n  - name: success-rate\n    successCondition: result[0] &gt;= 0.95\n    interval: 60s\n    count: 5\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: ...\n</code></pre> <p>Note</p> <p>The <code>count</code> can have 0 as value which means that it will run until the end of the Rollout execution for background analysis (outside of steps). However if the <code>count</code> has value 0 and the analysis is defined in the steps, the analysis won't be executed.</p>"},{"location":"features/analysis/#clusteranalysistemplates","title":"ClusterAnalysisTemplates","text":"<p>Important</p> <p>Available since v0.9.0</p> <p>A Rollout can reference a Cluster scoped AnalysisTemplate called a <code>ClusterAnalysisTemplate</code>. This can be useful when you want to share an AnalysisTemplate across multiple Rollouts; in different namespaces, and avoid duplicating the same template in every namespace. Use the field <code>clusterScope: true</code> to reference a ClusterAnalysisTemplate instead of an AnalysisTemplate.</p> Rollout <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\nspec:\n...\n  strategy:\n    canary:\n      steps:\n      - setWeight: 20\n      - pause: {duration: 5m}\n      - analysis:\n          templates:\n          - templateName: success-rate\n            clusterScope: true\n          args:\n          - name: service-name\n            value: guestbook-svc.default.svc.cluster.local\n</code></pre> ClusterAnalysisTemplate <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: ClusterAnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  - name: prometheus-port\n    value: 9090\n  metrics:\n  - name: success-rate\n    successCondition: result[0] &gt;= 0.95\n    provider:\n      prometheus:\n        address: \"http://prometheus.example.com:{{args.prometheus-port}}\"\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n</code></pre> <p>Note</p> <p>The resulting <code>AnalysisRun</code> will still run in the namespace of the <code>Rollout</code></p>"},{"location":"features/analysis/#analysis-with-multiple-templates","title":"Analysis with Multiple Templates","text":"<p>A Rollout can reference multiple AnalysisTemplates when constructing an AnalysisRun. This allows users to compose analysis from multiple AnalysisTemplates. If multiple templates are referenced, then the controller will merge the templates together. The controller combines the <code>metrics</code> and <code>args</code> fields of all the templates.</p> Rollout <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\nspec:\n...\n  strategy:\n    canary:\n      analysis:\n        templates:\n        - templateName: success-rate\n        - templateName: error-rate\n        args:\n        - name: service-name\n          value: guestbook-svc.default.svc.cluster.local\n</code></pre> AnalysisTemplate <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: success-rate\n    interval: 5m\n    successCondition: result[0] &gt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n---\napiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: error-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: error-rate\n    interval: 5m\n    successCondition: result[0] &lt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code=~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n</code></pre> AnalysisRun <pre><code># NOTE: Generated AnalysisRun from the multiple templates\napiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\nmetadata:\n  name: guestbook-CurrentPodHash-multiple-templates\nspec:\n  args:\n  - name: service-name\n    value: guestbook-svc.default.svc.cluster.local\n  metrics:\n  - name: success-rate\n    interval: 5m\n    successCondition: result[0] &gt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n  - name: error-rate\n    interval: 5m\n    successCondition: result[0] &lt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code=~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n</code></pre> <p>Note</p> <p>The controller will error when merging the templates if:</p> <ul> <li>Multiple metrics in the templates have the same name</li> <li>Two arguments with the same name have different default values no matter the argument value in Rollout</li> </ul>"},{"location":"features/analysis/#analysis-template-referencing-other-analysis-templates","title":"Analysis Template referencing other Analysis Templates","text":"<p>AnalysisTemplates and ClusterAnalysisTemplates may reference other templates.</p> <p>They can be combined with other metrics:</p> AnalysisTemplate <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: error-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: error-rate\n    interval: 5m\n    successCondition: result[0] &lt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code=~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n---\napiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: rates\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: success-rate\n    interval: 5m\n    successCondition: result[0] &gt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n  templates:\n  - templateName: error-rate\n    clusterScope: false\n</code></pre> <p>Or without additional metrics:</p> AnalysisTemplate <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: success-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: success-rate\n    interval: 5m\n    successCondition: result[0] &gt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n---\napiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: error-rate\nspec:\n  args:\n  - name: service-name\n  metrics:\n  - name: error-rate\n    interval: 5m\n    successCondition: result[0] &lt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code=~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n---\napiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: rates\nspec:\n  args:\n  - name: service-name\n  templates:\n  - templateName: success-rate\n    clusterScope: false\n  - templateName: error-rate\n    clusterScope: false\n</code></pre> <p>The result in the AnalysisRun will have the aggregation of metrics of each template:</p> AnalysisRun <pre><code># NOTE: Generated AnalysisRun from a single template referencing several templates\napiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\nmetadata:\n  name: guestbook-CurrentPodHash-templates-in-template\nspec:\n  args:\n  - name: service-name\n    value: guestbook-svc.default.svc.cluster.local\n  metrics:\n  - name: success-rate\n    interval: 5m\n    successCondition: result[0] &gt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code!~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n  - name: error-rate\n    interval: 5m\n    successCondition: result[0] &lt;= 0.95\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code=~\"5.*\"}[5m]\n          )) /\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\"}[5m]\n          ))\n</code></pre> <p>Note</p> <p>The same limitations as for the multiple templates feature apply. The controller will error when merging the templates if:</p> <ul> <li>Multiple metrics in the templates have the same name</li> <li>Two arguments with the same name have different default values no matter the argument value in Rollout</li> </ul> <p>However, if the same AnalysisTemplate is referenced several times along the chain of references, the controller will only keep it once and discard the other references.</p>"},{"location":"features/analysis/#analysis-template-arguments","title":"Analysis Template Arguments","text":"<p>AnalysisTemplates may declare a set of arguments that can be passed by Rollouts. The args can then be used as in metrics configuration and are resolved at the time the AnalysisRun is created. Argument placeholders are defined as <code>{{ args.&lt;name&gt; }}</code>.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nmetadata:\n  name: args-example\nspec:\n  args:\n  # required in Rollout due to no default value\n  - name: service-name\n  - name: stable-hash\n  - name: latest-hash\n  # optional in Rollout given the default value\n  - name: api-url\n    value: http://example/measure\n  # from secret\n  - name: api-token\n    valueFrom:\n      secretKeyRef:\n        name: token-secret\n        key: apiToken\n  metrics:\n  - name: webmetric\n    successCondition: result == 'true'\n    provider:\n      web:\n        # placeholders are resolved when an AnalysisRun is created\n        url: \"{{ args.api-url }}?service={{ args.service-name }}\"\n        headers:\n          - key: Authorization\n            value: \"Bearer {{ args.api-token }}\"\n        jsonPath: \"{$.results.ok}\"\n</code></pre> <p>Analysis arguments defined in a Rollout are merged with the args from the AnalysisTemplate when the AnalysisRun is created.</p> <p><pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\nspec:\n...\n  strategy:\n    canary:\n      analysis:\n        templates:\n        - templateName: args-example\n        args:\n        # required value\n        - name: service-name\n          value: guestbook-svc.default.svc.cluster.local\n        # override default value\n        - name: api-url\n          value: http://other-api\n        # pod template hash from the stable ReplicaSet\n        - name: stable-hash\n          valueFrom:\n            podTemplateHashValue: Stable\n        # pod template hash from the latest ReplicaSet\n        - name: latest-hash\n          valueFrom:\n            podTemplateHashValue: Latest\n</code></pre> Analysis arguments also support valueFrom for reading metadata fields and passing them as arguments to AnalysisTemplate. An example would be to reference metadata labels like env and region and passing them along to AnalysisTemplate.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\n  labels:\n    appType: demo-app\n    buildType: nginx-app\n    ...\n    env: dev\n    region: us-west-2\nspec:\n...\n  strategy:\n    canary:\n      analysis:\n        templates:\n        - templateName: args-example\n        args:\n        ...\n        - name: env\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.labels['env']\n        # region where this app is deployed\n        - name: region\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.labels['region']\n</code></pre> <p>Important</p> <p>Available since v1.2</p> <p>Analysis arguments also support valueFrom for reading any field from Rollout status and passing them as arguments to AnalysisTemplate. Following example references Rollout status field like aws canaryTargetGroup name and passing them along to AnalysisTemplate</p> <p>from the Rollout status <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\n  labels:\n    appType: demo-app\n    buildType: nginx-app\n    ...\n    env: dev\n    region: us-west-2\nspec:\n...\n  strategy:\n    canary:\n      analysis:\n        templates:\n        - templateName: args-example\n        args:\n        ...\n        - name: canary-targetgroup-name\n          valueFrom:\n            fieldRef:\n              fieldPath: status.alb.canaryTargetGroup.name\n</code></pre></p>"},{"location":"features/analysis/#bluegreen-pre-promotion-analysis","title":"BlueGreen Pre Promotion Analysis","text":"<p>A Rollout using the BlueGreen strategy can launch an AnalysisRun before it switches traffic to the new version using pre-promotion. This can be used to block the Service selector switch until the AnalysisRun finishes successfully. The success or failure of the AnalysisRun decides if the Rollout switches traffic, or abort the Rollout completely.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\nspec:\n...\n  strategy:\n    blueGreen:\n      activeService: active-svc\n      previewService: preview-svc\n      prePromotionAnalysis:\n        templates:\n        - templateName: smoke-tests\n        args:\n        - name: service-name\n          value: preview-svc.default.svc.cluster.local\n</code></pre> <p>In this example, the Rollout creates a pre-promotion AnalysisRun once the new ReplicaSet is fully available. The Rollout will not switch traffic to the new version until the analysis run finishes successfully.</p> <p>Note: if the<code>autoPromotionSeconds</code> field is specified and the Rollout has waited auto promotion seconds amount of time, the Rollout marks the AnalysisRun successful and switches the traffic to a new version automatically. If the AnalysisRun completes before then, the Rollout will not create another AnalysisRun and wait out the rest of the <code>autoPromotionSeconds</code>.</p>"},{"location":"features/analysis/#bluegreen-post-promotion-analysis","title":"BlueGreen Post Promotion Analysis","text":"<p>A Rollout using a BlueGreen strategy can launch an analysis run after the traffic switch to the new version using post-promotion analysis. If post-promotion Analysis fails or errors, the Rollout enters an aborted state and switches traffic back to the previous stable Replicaset. When post-analysis is Successful, the Rollout is considered fully promoted and the new ReplicaSet will be marked as stable. The old ReplicaSet will then be scaled down according to <code>scaleDownDelaySeconds</code> (default 30 seconds).</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\nspec:\n...\n  strategy:\n    blueGreen:\n      activeService: active-svc\n      previewService: preview-svc\n      scaleDownDelaySeconds: 600 # 10 minutes\n      postPromotionAnalysis:\n        templates:\n        - templateName: smoke-tests\n        args:\n        - name: service-name\n          value: preview-svc.default.svc.cluster.local\n</code></pre>"},{"location":"features/analysis/#failure-conditions-and-failure-limit","title":"Failure Conditions and Failure Limit","text":"<p><code>failureCondition</code> can be used to cause an analysis run to fail. <code>failureLimit</code> is the maximum number of failed run an analysis is allowed. The following example continually polls the defined Prometheus server to get the total number of errors(i.e., HTTP response code &gt;= 500) every 5 minutes, causing the measurement to fail if ten or more errors are encountered. The entire analysis run is considered as Failed after three failed measurements.</p> <pre><code>  metrics:\n  - name: total-errors\n    interval: 5m\n    failureCondition: result[0] &gt;= 10\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code=~\"5.*\"}[5m]\n          ))\n</code></pre>"},{"location":"features/analysis/#dry-run-mode","title":"Dry-Run Mode","text":"<p>Important</p> <p>Available since v1.2</p> <p><code>dryRun</code> can be used on a metric to control whether or not to evaluate that metric in a dry-run mode. A metric running  in the dry-run mode won't impact the final state of the rollout or experiment even if it fails or the evaluation comes  out as inconclusive.</p> <p>The following example queries prometheus every 5 minutes to get the total number of 4XX and 5XX errors, and even if the evaluation of the metric to monitor the 5XX error-rate fail, the analysis run will pass.</p> <pre><code>  dryRun:\n  - metricName: total-5xx-errors\n  metrics:\n  - name: total-5xx-errors\n    interval: 5m\n    failureCondition: result[0] &gt;= 10\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code~\"5.*\"}[5m]\n          ))\n  - name: total-4xx-errors\n    interval: 5m\n    failureCondition: result[0] &gt;= 10\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code~\"4.*\"}[5m]\n          ))\n</code></pre> <p>RegEx matches are also supported. <code>.*</code> can be used to make all the metrics run in the dry-run mode. In the following  example, even if one or both metrics fail, the analysis run will pass.</p> <pre><code>  dryRun:\n  - metricName: .*\n  metrics:\n  - name: total-5xx-errors\n    interval: 5m\n    failureCondition: result[0] &gt;= 10\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code~\"5.*\"}[5m]\n          ))\n  - name: total-4xx-errors\n    interval: 5m\n    failureCondition: result[0] &gt;= 10\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code~\"4.*\"}[5m]\n          ))\n</code></pre>"},{"location":"features/analysis/#dry-run-summary","title":"Dry-Run Summary","text":"<p>If one or more metrics are running in the dry-run mode, the summary of the dry-run results gets appended to the analysis  run message. Assuming that the <code>total-4xx-errors</code> metric fails in the above example but, the <code>total-5xx-errors</code>  succeeds, the final dry-run summary will look like this.</p> <pre><code>Message: Run Terminated\nRun Summary:\n  ...\nDry Run Summary: \n  Count: 2\n  Successful: 1\n  Failed: 1\nMetric Results:\n...\n</code></pre>"},{"location":"features/analysis/#dry-run-rollouts","title":"Dry-Run Rollouts","text":"<p>If a rollout wants to dry run its analysis, it simply needs to specify the <code>dryRun</code> field to its <code>analysis</code> stanza. In the  following example, all the metrics from <code>random-fail</code> and <code>always-pass</code> get merged and executed in the dry-run mode.</p> <pre><code>kind: Rollout\nspec:\n...\n  steps:\n  - analysis:\n      templates:\n      - templateName: random-fail\n      - templateName: always-pass\n      dryRun:\n      - metricName: .*\n</code></pre>"},{"location":"features/analysis/#dry-run-experiments","title":"Dry-Run Experiments","text":"<p>If an experiment wants to dry run its analysis, it simply needs to specify the <code>dryRun</code> field under its specs. In the  following example, all the metrics from <code>analyze-job</code> matching the RegEx rule <code>test.*</code> will be executed in the dry-run  mode.</p> <pre><code>kind: Experiment\nspec:\n  templates:\n  - name: baseline\n    selector:\n      matchLabels:\n        app: rollouts-demo\n    template:\n      metadata:\n        labels:\n          app: rollouts-demo\n      spec:\n        containers:\n        - name: rollouts-demo\n          image: argoproj/rollouts-demo:blue\n  analyses:\n  - name: analyze-job\n    templateName: analyze-job\n  dryRun:\n  - metricName: test.*\n</code></pre>"},{"location":"features/analysis/#measurements-retention","title":"Measurements Retention","text":"<p>Important</p> <p>Available since v1.2</p> <p><code>measurementRetention</code> can be used to retain other than the latest ten results for the metrics running in any mode  (dry/non-dry). Setting this option to <code>0</code> would disable it and, the controller will revert to the existing behavior of  retaining the latest ten measurements.</p> <p>The following example queries Prometheus every 5 minutes to get the total number of 4XX and 5XX errors and retains the  latest twenty measurements for the 5XX metric run results instead of the default ten.</p> <pre><code>  measurementRetention:\n  - metricName: total-5xx-errors\n    limit: 20\n  metrics:\n  - name: total-5xx-errors\n    interval: 5m\n    failureCondition: result[0] &gt;= 10\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code~\"5.*\"}[5m]\n          ))\n  - name: total-4xx-errors\n    interval: 5m\n    failureCondition: result[0] &gt;= 10\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code~\"4.*\"}[5m]\n          ))\n</code></pre> <p>RegEx matches are also supported. <code>.*</code> can be used to apply the same retention rule to all the metrics. In the following  example, the controller will retain the latest twenty run results for all the metrics instead of the default ten results.</p> <pre><code>  measurementRetention:\n  - metricName: .*\n    limit: 20\n  metrics:\n  - name: total-5xx-errors\n    interval: 5m\n    failureCondition: result[0] &gt;= 10\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code~\"5.*\"}[5m]\n          ))\n  - name: total-4xx-errors\n    interval: 5m\n    failureCondition: result[0] &gt;= 10\n    failureLimit: 3\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: |\n          sum(irate(\n            istio_requests_total{reporter=\"source\",destination_service=~\"{{args.service-name}}\",response_code~\"4.*\"}[5m]\n          ))\n</code></pre>"},{"location":"features/analysis/#measurements-retention-for-rollouts-analysis","title":"Measurements Retention for Rollouts Analysis","text":"<p>If a rollout wants to retain more results of its analysis metrics, it simply needs to specify the <code>measurementRetention</code>  field to its <code>analysis</code> stanza. In the following example, all the metrics from <code>random-fail</code> and <code>always-pass</code> get  merged, and their latest twenty measurements get retained instead of the default ten.</p> <pre><code>kind: Rollout\nspec:\n...\n  steps:\n  - analysis:\n      templates:\n      - templateName: random-fail\n      - templateName: always-pass\n      measurementRetention:\n      - metricName: .*\n        limit: 20\n</code></pre>"},{"location":"features/analysis/#define-custom-labelsannotations-for-analysisrun","title":"Define custom Labels/Annotations for AnalysisRun","text":"<p>If you would like to annotate/label the <code>AnalysisRun</code> with the custom labels your can do it by specifying  <code>analysisRunMetadata</code> field.</p> <pre><code>kind: Rollout\nspec:\n...\n  steps:\n  - analysis:\n      templates:\n      - templateName: my-template\n      analysisRunMetadata:\n        labels:\n          my-custom-label: label-value\n        annotations:\n          my-custom-annotation: annotation-value\n</code></pre>"},{"location":"features/analysis/#measurements-retention-for-experiments","title":"Measurements Retention for Experiments","text":"<p>If an experiment wants to retain more results of its analysis metrics, it simply needs to specify the  <code>measurementRetention</code> field under its specs. In the following example, all the metrics from <code>analyze-job</code> matching the  RegEx rule <code>test.*</code> will have their latest twenty measurements get retained instead of the default ten.</p> <pre><code>kind: Experiment\nspec:\n  templates:\n  - name: baseline\n    selector:\n      matchLabels:\n        app: rollouts-demo\n    template:\n      metadata:\n        labels:\n          app: rollouts-demo\n      spec:\n        containers:\n        - name: rollouts-demo\n          image: argoproj/rollouts-demo:blue\n  analyses:\n  - name: analyze-job\n    templateName: analyze-job\n  measurementRetention:\n  - metricName: test.*\n    limit: 20\n</code></pre>"},{"location":"features/analysis/#time-to-live-ttl-strategy","title":"Time-to-live (TTL) Strategy","text":"<p>Important</p> <p>Available since v1.7</p> <p><code>ttlStrategy</code> limits the lifetime of an analysis run that has finished execution depending on if it Succeeded or Failed. If this struct is set, once the run finishes, it will be deleted after the time to live expires. If this field is unset, the analysis controller will keep the completed runs, unless they are associated with rollouts using other garbage collection policies (e.g. <code>successfulRunHistoryLimit</code> and <code>unsuccessfulRunHistoryLimit</code>).</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\nspec:\n  ...\n  ttlStrategy:\n    secondsAfterCompletion: 3600\n    secondsAfterSuccess: 1800\n    secondsAfterFailure: 1800\n</code></pre>"},{"location":"features/analysis/#inconclusive-runs","title":"Inconclusive Runs","text":"<p>Analysis runs can also be considered <code>Inconclusive</code>, which indicates the run was neither successful, nor failed. Inconclusive runs causes a rollout to become paused at its current step. Manual intervention is then needed to either resume the rollout, or abort. One example of how analysis runs could become <code>Inconclusive</code>, is when a metric defines no success or failure conditions.</p> <pre><code>  metrics:\n  - name: my-query\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: ...\n</code></pre> <p><code>Inconclusive</code> analysis runs might also happen when both success and failure conditions are specified, but the measurement value did not meet either condition.</p> <pre><code>  metrics:\n  - name: success-rate\n    successCondition: result[0] &gt;= 0.90\n    failureCondition: result[0] &lt; 0.50\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: ...\n</code></pre> <p>A use case for having <code>Inconclusive</code> analysis runs are to enable Argo Rollouts to automate the execution of analysis runs, and collect the measurement, but still allow human judgement to decide whether or not measurement value is acceptable and decide to proceed or abort.</p>"},{"location":"features/analysis/#delay-analysis-runs","title":"Delay Analysis Runs","text":"<p>If the analysis run does not need to start immediately (i.e give the metric provider time to collect metrics on the canary version), Analysis Runs can delay the specific metric analysis. Each metric can be configured to have a different delay. In additional to the metric specific delays, the rollouts with background analysis can delay creating an analysis run until a certain step is reached</p> <p>Delaying a specific analysis metric: <pre><code>  metrics:\n  - name: success-rate\n    # Do not start this analysis until 5 minutes after the analysis run starts\n    initialDelay: 5m\n    successCondition: result[0] &gt;= 0.90\n    provider:\n      prometheus:\n        address: http://prometheus.example.com:9090\n        query: ...\n</code></pre></p> <p>Delaying starting background analysis run until step 3 (Set Weight 40%):</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\nspec:\n  strategy:\n    canary:\n      analysis:\n        templates:\n        - templateName: success-rate\n        startingStep: 2\n      steps:\n      - setWeight: 20\n      - pause: {duration: 10m}\n      - setWeight: 40\n      - pause: {duration: 10m}\n</code></pre>"},{"location":"features/analysis/#referencing-secrets","title":"Referencing Secrets","text":"<p>AnalysisTemplates and AnalysisRuns can reference secret objects in <code>.spec.args</code>. This allows users to securely pass authentication information to Metric Providers, like login credentials or API tokens.</p> <p>An AnalysisRun can only reference secrets from the same namespace as it's running in. This is only relevant for AnalysisRuns, since AnalysisTemplates do not resolve the secret.</p> <p>In the following example, an AnalysisTemplate references an API token and passes it to a Web metric provider.</p> <p>This example demonstrates:</p> <ul> <li>The ability to reference a secret in the AnalysisTemplate <code>.spec.args</code></li> <li>The ability to pass secret arguments to Metric Providers</li> </ul> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisTemplate\nspec:\n  args:\n  - name: api-token\n    valueFrom:\n      secretKeyRef:\n        name: token-secret\n        key: apiToken\n  metrics:\n  - name: webmetric\n    provider:\n      web:\n        headers:\n        - key: Authorization\n          value: \"Bearer {{ args.api-token }}\"\n</code></pre>"},{"location":"features/analysis/#handling-metric-results","title":"Handling Metric Results","text":""},{"location":"features/analysis/#nan-and-infinity","title":"NaN and Infinity","text":"<p>Metric providers can sometimes return values of NaN (not a number) and infinity. Users can edit the <code>successCondition</code> and <code>failureCondition</code> fields to handle these cases accordingly.</p> <p>Here are three examples where a metric result of NaN is considered successful, inconclusive and failed respectively.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\n  ...\n    successCondition: isNaN(result) || result &gt;= 0.95\nstatus:\n  metricResults:\n  - count: 1\n    measurements:\n    - finishedAt: \"2021-02-10T00:15:26Z\"\n      phase: Successful\n      startedAt: \"2021-02-10T00:15:26Z\"\n      value: NaN\n    name: success-rate\n    phase: Successful\n    successful: 1\n  phase: Successful\n  startedAt: \"2021-02-10T00:15:26Z\"\n</code></pre> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\n  ...\n    successCondition: result &gt;= 0.95\n    failureCondition: result &lt; 0.95\nstatus:\n  metricResults:\n  - count: 1\n    measurements:\n    - finishedAt: \"2021-02-10T00:15:26Z\"\n      phase: Inconclusive\n      startedAt: \"2021-02-10T00:15:26Z\"\n      value: NaN\n    name: success-rate\n    phase: Inconclusive\n    successful: 1\n  phase: Inconclusive\n  startedAt: \"2021-02-10T00:15:26Z\"\n</code></pre> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\n  ...\n    successCondition: result &gt;= 0.95\nstatus:\n  metricResults:\n  - count: 1\n    measurements:\n    - finishedAt: \"2021-02-10T00:15:26Z\"\n      phase: Failed\n      startedAt: \"2021-02-10T00:15:26Z\"\n      value: NaN\n    name: success-rate\n    phase: Failed\n    successful: 1\n  phase: Failed\n  startedAt: \"2021-02-10T00:15:26Z\"\n</code></pre> <p>Here are two examples where a metric result of infinity is considered successful and failed respectively.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\n  ...\n    successCondition: result &gt;= 0.95\nstatus:\n  metricResults:\n  - count: 1\n    measurements:\n    - finishedAt: \"2021-02-10T00:15:26Z\"\n      phase: Successful\n      startedAt: \"2021-02-10T00:15:26Z\"\n      value: +Inf\n    name: success-rate\n    phase: Successful\n    successful: 1\n  phase: Successful\n  startedAt: \"2021-02-10T00:15:26Z\"\n</code></pre> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\n  ...\n    failureCondition: isInf(result)\nstatus:\n  metricResults:\n  - count: 1\n    measurements:\n    - finishedAt: \"2021-02-10T00:15:26Z\"\n      phase: Failed\n      startedAt: \"2021-02-10T00:15:26Z\"\n      value: +Inf\n    name: success-rate\n    phase: Failed\n    successful: 1\n  phase: Failed\n  startedAt: \"2021-02-10T00:15:26Z\"\n</code></pre>"},{"location":"features/analysis/#empty-array","title":"Empty array","text":""},{"location":"features/analysis/#prometheus","title":"Prometheus","text":"<p>Metric providers can sometimes return empty array, e.g., no data returned from prometheus query.</p> <p>Here are two examples where a metric result of empty array is considered successful and failed respectively.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\n  ...\n    successCondition: len(result) == 0 || result[0] &gt;= 0.95\nstatus:\n  metricResults:\n  - count: 1\n    measurements:\n    - finishedAt: \"2021-09-08T19:15:49Z\"\n      phase: Successful\n      startedAt: \"2021-09-08T19:15:49Z\"\n      value: '[]'\n    name: success-rate\n    phase: Successful\n    successful: 1\n  phase: Successful\n  startedAt:  \"2021-09-08T19:15:49Z\"\n</code></pre> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: AnalysisRun\n  ...\n    successCondition: len(result) &gt; 0 &amp;&amp; result[0] &gt;= 0.95\nstatus:\n  metricResults:\n  - count: 1\n    measurements:\n    - finishedAt: \"2021-09-08T19:19:44Z\"\n      phase: Failed\n      startedAt: \"2021-09-08T19:19:44Z\"\n      value: '[]'\n    name: success-rate\n    phase: Failed\n    successful: 1\n  phase: Failed\n  startedAt: \"2021-09-08T19:19:44Z\"\n</code></pre>"},{"location":"features/analysis/#datadog","title":"Datadog","text":"<p>Datadog queries can return empty results if the query takes place during a time interval with no metrics. The Datadog provider will return a <code>nil</code> value yielding an error during the evaluation phase like:</p> <pre><code>invalid operation: &lt; (mismatched types &lt;nil&gt; and float64)\n</code></pre> <p>However, empty query results yielding a <code>nil</code> value can be handled using the <code>default()</code> function. Here is a succeeding example using the <code>default()</code> function:</p> <pre><code>successCondition: default(result, 0) &lt; 0.05\n</code></pre>"},{"location":"features/bluegreen/","title":"BlueGreen Deployment Strategy","text":"<p>A Blue Green Deployment allows users to reduce the amount of time multiple versions are running at the same time.</p>"},{"location":"features/bluegreen/#overview","title":"Overview","text":"<p>In addition to managing ReplicaSets, the rollout controller will modify a Service resource during the <code>BlueGreenUpdate</code> strategy.  The Rollout spec has users specify a reference to active service and optionally a preview service in the same namespace. The active Service is used to send regular application traffic to the old version, while the preview Service is used as funnel traffic to the new version. The rollout controller ensures proper traffic routing by injecting a unique hash of the ReplicaSet to these services' selectors.  This allows the rollout to define an active and preview stack and a process to migrate replica sets from the preview to the active. </p> <p>When there is a change to the <code>.spec.template</code> field of a rollout, the controller will create the new ReplicaSet.  If the active service is not sending traffic to a ReplicaSet, the controller will immediately start sending traffic to the ReplicaSet. Otherwise, the active service will point at the old ReplicaSet while the ReplicaSet becomes available. Once the new ReplicaSet becomes available, the controller will modify the active service to point at the new ReplicaSet. After waiting some time configured by the <code>.spec.strategy.blueGreen.scaleDownDelaySeconds</code>, the controller will scale down the old ReplicaSet.</p> <p>Important</p> <p>When the rollout changes the selector on a service, there is a propagation delay before all the nodes update their IP tables to send traffic to the new pods instead of the old. During this delay, traffic will be directed to the old pods if the nodes have not been updated yet. In order to prevent the packets from being sent to a node that killed the old pod, the rollout uses the scaleDownDelaySeconds field to give nodes enough time to broadcast the IP table changes.</p>"},{"location":"features/bluegreen/#example","title":"Example","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollout-bluegreen\nspec:\n  replicas: 2\n  revisionHistoryLimit: 2\n  selector:\n    matchLabels:\n      app: rollout-bluegreen\n  template:\n    metadata:\n      labels:\n        app: rollout-bluegreen\n    spec:\n      containers:\n      - name: rollouts-demo\n        image: argoproj/rollouts-demo:blue\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 8080\n  strategy:\n    blueGreen: \n      # activeService specifies the service to update with the new template hash at time of promotion.\n      # This field is mandatory for the blueGreen update strategy.\n      activeService: rollout-bluegreen-active\n      # previewService specifies the service to update with the new template hash before promotion.\n      # This allows the preview stack to be reachable without serving production traffic.\n      # This field is optional.\n      previewService: rollout-bluegreen-preview\n      # autoPromotionEnabled disables automated promotion of the new stack by pausing the rollout\n      # immediately before the promotion. If omitted, the default behavior is to promote the new\n      # stack as soon as the ReplicaSet are completely ready/available.\n      # Rollouts can be resumed using: `kubectl argo rollouts promote ROLLOUT`\n      autoPromotionEnabled: false\n</code></pre>"},{"location":"features/bluegreen/#configurable-features","title":"Configurable Features","text":"<p>Here are the optional fields that will change the behavior of BlueGreen deployment: <pre><code>spec:\n  strategy:\n    blueGreen:\n      autoPromotionEnabled: boolean\n      autoPromotionSeconds: *int32\n      antiAffinity: object\n      previewService: string\n      prePromotionAnalysis: object\n      postPromotionAnalysis: object\n      previewReplicaCount: *int32\n      scaleDownDelaySeconds: *int32\n      scaleDownDelayRevisionLimit: *int32\n</code></pre></p>"},{"location":"features/bluegreen/#sequence-of-events","title":"Sequence of Events","text":"<p>The following describes the sequence of events that happen during a blue-green update.</p> <ol> <li>Beginning at a fully promoted, steady-state, a revision 1 ReplicaSet is pointed to by both the <code>activeService</code> and <code>previewService</code>.</li> <li>A user initiates an update by modifying the pod template (<code>spec.template.spec</code>).</li> <li>The revision 2 ReplicaSet is created with size 0.</li> <li>The <code>previewService</code> is modified to point to the revision 2 ReplicaSet. The <code>activeService</code> remains pointing to revision 1.</li> <li>The revision 2 ReplicaSet is scaled to either <code>spec.replicas</code> or <code>previewReplicaCount</code> if set.</li> <li>Once revision 2 ReplicaSet Pods are fully available, <code>prePromotionAnalysis</code> begins.</li> <li>Upon success of <code>prePromotionAnalysis</code>, the blue/green pauses if <code>autoPromotionEnabled</code> is false, or <code>autoPromotionSeconds</code> is non-zero.</li> <li>The rollout is resumed either manually by a user, or automatically by surpassing <code>autoPromotionSeconds</code>.</li> <li>The revision 2 ReplicaSet is scaled to the <code>spec.replicas</code>, if the <code>previewReplicaCount</code> feature was used.</li> <li>The rollout \"promotes\" the revision 2 ReplicaSet by updating the <code>activeService</code> to point to it. At this point, there are no services pointing to revision 1</li> <li><code>postPromotionAnalysis</code> analysis begins</li> <li>Once <code>postPromotionAnalysis</code> completes successfully, the update is successful and the revision 2 ReplicaSet is marked as stable. The rollout is considered fully-promoted.</li> <li>After waiting <code>scaleDownDelaySeconds</code> (default 30 seconds), the revision 1 ReplicaSet is scaled down </li> </ol>"},{"location":"features/bluegreen/#autopromotionenabled","title":"autoPromotionEnabled","text":"<p>The AutoPromotionEnabled will make the rollout automatically promote the new ReplicaSet to the active service once the new ReplicaSet is healthy. This field is defaulted to true if it is not specified.</p> <p>Defaults to true</p>"},{"location":"features/bluegreen/#autopromotionseconds","title":"autoPromotionSeconds","text":"<p>Setting a positive non-zero value here would make the rollout automatically promote the new <code>ReplicaSet</code> to active Service after this much time has been elapsed since the rollout has entered a paused state. If the <code>AutoPromotionEnabled</code> field is set to false, this field would be ignored.</p> <p>Defaults to nil</p>"},{"location":"features/bluegreen/#antiaffinity","title":"antiAffinity","text":"<p>Check out the Anti Affinity document document for more information.</p> <p>Defaults to nil</p>"},{"location":"features/bluegreen/#maxunavailable","title":"maxUnavailable","text":"<p>The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxSurge is 0.</p> <p>Defaults to 0</p>"},{"location":"features/bluegreen/#prepromotionanalysis","title":"prePromotionAnalysis","text":"<p>Configures the Analysis before it switches traffic to the new version. The AnalysisRun can be used to block the Service selector switch until the AnalysisRun finishes successful. The success or failure of the analysis run decides if the Rollout will switch traffic, or abort the Rollout completely.</p> <p>Defaults to nil</p>"},{"location":"features/bluegreen/#postpromotionanalysis","title":"postPromotionAnalysis","text":"<p>Configures the Analysis after the traffic switch to new version. If the analysis run fails or errors out, the Rollout enters an aborted state and switch traffic back to the previous stable Replicaset. If <code>scaleDownDelaySeconds</code> is specified, the controller will cancel any AnalysisRuns at time of <code>scaleDownDelay</code> to  scale down the ReplicaSet. If it is omitted, and post analysis is specified, it will scale down the ReplicaSet only  after the AnalysisRun completes (with a minimum of 30 seconds).</p> <p>Defaults to nil</p>"},{"location":"features/bluegreen/#previewservice","title":"previewService","text":"<p>The PreviewService field references a Service that will be modified to send traffic to the new ReplicaSet before the new one is promoted to receiving traffic from the active service. Once the new ReplicaSet starts receiving traffic from the active service, the preview service will also be modified to send traffic to the new ReplicaSet as well. The Rollout always makes sure that the preview service is sending traffic to the newest ReplicaSet.  As a result, if a new version is introduced before the old version is promoted to the active service, the controller will immediately switch over to that brand new version.</p> <p>This feature is used to provide an endpoint that can be used to test a new version of an application.</p> <p>Defaults to an empty string</p>"},{"location":"features/bluegreen/#previewreplicacount","title":"previewReplicaCount","text":"<p>The PreviewReplicaCount field will indicate the number of replicas that the new version of an application should run.  Once the application is ready to promote to the active service, the controller will scale the new ReplicaSet to the value of the <code>spec.replicas</code>. The rollout will not switch over the active service to the new ReplicaSet until it matches the <code>spec.replicas</code> count.</p> <p>This feature is mainly used to save resources during the testing phase. If the application does not need a fully scaled up application for the tests, this feature can help save some resources.</p> <p>If omitted, the preview ReplicaSet stack will be scaled to 100% of the replicas.</p>"},{"location":"features/bluegreen/#scaledowndelayseconds","title":"scaleDownDelaySeconds","text":"<p>The ScaleDownDelaySeconds is used to delay scaling down the old ReplicaSet after the active Service is switched to the new ReplicaSet.</p> <p>Defaults to 30</p>"},{"location":"features/bluegreen/#scaledowndelayrevisionlimit","title":"scaleDownDelayRevisionLimit","text":"<p>The ScaleDownDelayRevisionLimit limits the number of old active ReplicaSets to keep scaled up while they wait for the scaleDownDelay to pass after being removed from the active service. </p> <p>If omitted, all ReplicaSets will be retained for the specified scaleDownDelay</p>"},{"location":"features/canary/","title":"Canary Deployment Strategy","text":"<p>A canary rollout is a deployment strategy where the operator releases a new version of their application to a small percentage of the production traffic.</p>"},{"location":"features/canary/#overview","title":"Overview","text":"<p>Since there is no agreed upon standard for a canary deployment, the rollouts controller allows users to outline how they want to run their canary deployment. Users can define a list of steps the controller uses to manipulate the ReplicaSets when there is a change to the <code>.spec.template</code>. Each step will be evaluated before the new ReplicaSet is promoted to the stable version, and the old version is completely scaled down.</p> <p>Each step can have one of two fields. The <code>setWeight</code> field dictates the percentage of traffic that should be sent to the canary, and the <code>pause</code> struct instructs the rollout to pause.  When the controller reaches a <code>pause</code> step for a rollout, it will add a <code>PauseCondition</code> struct to the <code>.status.PauseConditions</code> field. If the <code>duration</code> field within the <code>pause</code> struct is set, the rollout will not progress to the next step until it has waited for the value of the <code>duration</code> field. Otherwise, the rollout will wait indefinitely until that Pause condition is removed. By using the <code>setWeight</code> and the <code>pause</code> fields, a user can declaratively describe how they want to progress to the new version. Below is an example of a canary strategy.</p> <p>Important</p> <p>If the canary Rollout does not use traffic management, the Rollout makes a best effort attempt to achieve the percentage listed in the last <code>setWeight</code> step between the new and old version. For example, if a Rollout has 10 Replicas and 10% for the first <code>setWeight</code> step, the controller will scale the new desired ReplicaSet to 1 replicas and the old stable ReplicaSet to 9. In the case where the setWeight is 41%, the Rollout attempts to get there by finding the whole number with the smallest delta, rounding up the calculation if the deltas are equals (i.e. the new ReplicaSet has 4 pods since 41% of 10 is closer to 4/10 than 5/10, and the old ReplicaSet has 6 pods). If a user wants to have more fine-grained control of the percentages without a large number of Replicas, that user should use the  traffic management functionality.</p>"},{"location":"features/canary/#example","title":"Example","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: example-rollout\nspec:\n  replicas: 10\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.15.4\n        ports:\n        - containerPort: 80\n  minReadySeconds: 30\n  revisionHistoryLimit: 3\n  strategy:\n    canary: #Indicates that the rollout should use the Canary strategy\n      maxSurge: \"25%\"\n      maxUnavailable: 0\n      steps:\n      - setWeight: 10\n      - pause:\n          duration: 1h # 1 hour\n      - setWeight: 20\n      - pause: {} # pause indefinitely\n</code></pre>"},{"location":"features/canary/#pause-duration","title":"Pause Duration","text":"<p>Pause duration can be specified with an optional time unit suffix. Valid time units are \"s\", \"m\", \"h\". Defaults to \"s\" if not specified.</p> <pre><code>spec:\n  strategy:\n    canary:\n      steps:\n        - pause: { duration: 10 }  # 10 seconds\n        - pause: { duration: 10s } # 10 seconds\n        - pause: { duration: 10m } # 10 minutes\n        - pause: { duration: 10h } # 10 hours\n        - pause: {}                # pause indefinitely\n</code></pre> <p>If no <code>duration</code> is specified for a pause step, the rollout will be paused indefinitely. To unpause, use the argo kubectl plugin <code>promote</code> command.</p> <pre><code># promote to the next step\nkubectl argo rollouts promote &lt;rollout&gt;\n</code></pre>"},{"location":"features/canary/#dynamic-canary-scale-with-traffic-routing","title":"Dynamic Canary Scale (with Traffic Routing)","text":"<p>By default, the rollout controller will scale the canary to match the current trafficWeight of the current step. For example, if the current weight is 25%, and there are four replicas, then the canary will be scaled to 1, to match the traffic weight.</p> <p>It is possible to control the canary replica's scale during the steps such that it does not necessary match the traffic weight. Some use cases for this:</p> <ol> <li>The new version should not yet be exposed to the public (setWeight: 0), but you would like to    scale the canary up for testing purposes.</li> <li>You wish to scale the canary stack up minimally, and use some header based traffic shaping to    the canary, while setWeight is still set to 0.</li> <li>You wish to scale the canary up to 100%, in order to facilitate traffic shadowing.</li> </ol> <p>Important</p> <p>Setting canary scale is only available when using the canary strategy with a traffic router, since the basic canary needs to control canary scale in order to approximate canary weight.</p> <p>To control canary scales and weights during steps, use the <code>setCanaryScale</code> step and indicate which scale the the canary should use:</p> <ul> <li>explicit replica count without changing traffic weight (<code>replicas</code>)</li> <li>explicit weight percentage of total spec.replicas without changing traffic weight(<code>weight</code>)</li> <li>to or not to match current canary's <code>setWeight</code> step (<code>matchTrafficWeight: true or false</code>)</li> </ul> <pre><code>spec:\n  strategy:\n    canary:\n      steps:\n      # explicit count\n      - setCanaryScale:\n          replicas: 3\n      # a percentage of spec.replicas\n      - setCanaryScale:\n          weight: 25\n      # matchTrafficWeight returns to the default behavior of matching the canary traffic weight\n      - setCanaryScale:\n          matchTrafficWeight: true\n</code></pre> <p>When using <code>setCanaryScale</code> with explicit values for either replicas or weight, one must be careful if used in conjunction with the <code>setWeight</code> step. If done incorrectly, an imbalanced amount of traffic may be directed to the canary (in proportion to the Rollout's scale). For example, the following set of steps would cause 90% of traffic to only be served by 10% of pods:</p> <pre><code>spec:\n  replicas: 10\n  strategy:\n    canary:\n      steps:\n      # 1 canary pod (10% of spec.replicas)\n      - setCanaryScale:\n          weight: 10\n      # 90% of traffic to the 1 canary pod\n      - setWeight: 90\n      - pause: {}\n</code></pre> <p>The above situation is caused by the changed behvaior of <code>setWeight</code> after <code>setCanaryScale</code>. To reset, set <code>matchTrafficWeight: true</code> and the <code>setWeight</code> behavior will be restored, i.e., subsequent <code>setWeight</code> will create canary replicas matching the traffic weight.</p>"},{"location":"features/canary/#dynamic-stable-scale-with-traffic-routing","title":"Dynamic Stable Scale (with Traffic Routing)","text":"<p>Important</p> <p>Available since v1.1</p> <p>When using traffic routing, by default the stable ReplicaSet is left scaled to 100% during the update. This has the advantage that if an abort occurs, traffic can be immediately shifted back to the stable ReplicaSet without delay. However, it has the disadvantage that during the update, there will eventually exist double the number of replica pods running (similar to in a blue-green deployment), since the stable ReplicaSet is left scaled up for the full duration of the update.</p> <p>It is possible to dynamically reduce the scale of the stable ReplicaSet during an update such that it scales down as the traffic weight increases to canary. This would be desirable in scenarios where the Rollout has a high replica count and resource cost is a concern, or in bare-metal situations where it is not possible to create additional node capacity to accommodate double the replicas.</p> <p>The ability to dynamically scale the stable ReplicaSet can be enabled by setting the <code>canary.dynamicStableScale</code> flag to true:</p> <pre><code>spec:\n  strategy:\n    canary:\n      dynamicStableScale: true\n</code></pre> <p>NOTE: that if <code>dynamicStableScale</code> is set, and the rollout is aborted, the canary ReplicaSet will dynamically scale down as traffic shifts back to stable. If you wish to leave the canary ReplicaSet scaled up while aborting, an explicit value for <code>abortScaleDownDelaySeconds</code> can be set:</p> <pre><code>spec:\n  strategy:\n    canary:\n      dynamicStableScale: true\n      abortScaleDownDelaySeconds: 600\n</code></pre>"},{"location":"features/canary/#mimicking-rolling-update","title":"Mimicking Rolling Update","text":"<p>If the <code>steps</code> field is omitted, the canary strategy will mimic the rolling update behavior. Similar to the deployment, the canary strategy has the <code>maxSurge</code> and <code>maxUnavailable</code> fields to configure how the Rollout should progress to the new version.</p>"},{"location":"features/canary/#other-configurable-features","title":"Other Configurable Features","text":"<p>Here are the optional fields that will modify the behavior of canary strategy:</p> <pre><code>spec:\n  strategy:\n    canary:\n      analysis: object\n      antiAffinity: object\n      canaryService: string\n      stableService: string\n      maxSurge: stringOrInt\n      maxUnavailable: stringOrInt\n      trafficRouting: object\n</code></pre>"},{"location":"features/canary/#analysis","title":"analysis","text":"<p>Configure the background Analysis to execute during the rollout. If the analysis is unsuccessful the rollout will be aborted.</p> <p>Defaults to nil</p>"},{"location":"features/canary/#antiaffinity","title":"antiAffinity","text":"<p>Check out the Anti Affinity document document for more information.</p> <p>Defaults to nil</p>"},{"location":"features/canary/#canaryservice","title":"canaryService","text":"<p><code>canaryService</code> references a Service that will be modified to send traffic to only the canary ReplicaSet. This allows users to only hit the canary ReplicaSet.</p> <p>Defaults to an empty string</p>"},{"location":"features/canary/#stableservice","title":"stableService","text":"<p><code>stableService</code> the name of a Service which selects pods with stable version and doesn't select any pods with canary version. This allows users to only hit the stable ReplicaSet.</p> <p>Defaults to an empty string</p>"},{"location":"features/canary/#maxsurge","title":"maxSurge","text":"<p><code>maxSurge</code> defines the maximum number of replicas the rollout can create to move to the correct ratio set by the last setWeight. Max Surge can either be an integer or percentage as a string (i.e. \"20%\")</p> <p>Defaults to \"25%\".</p>"},{"location":"features/canary/#maxunavailable","title":"maxUnavailable","text":"<p>The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxSurge is 0.</p> <p>Defaults to 25%</p>"},{"location":"features/canary/#trafficrouting","title":"trafficRouting","text":"<p>The traffic management rules to apply to control the flow of traffic between the active and canary versions. If not set, the default weighted pod replica based routing will be used.</p> <p>Defaults to nil</p>"},{"location":"features/controller-metrics/","title":"Controller Metrics","text":"<p>The Argo Rollouts controller is already instrumented with Prometheus metrics available at <code>/metrics</code> in port 8090. You can use these metrics to look at the health of the controller either via dashboards or via other Prometheus integrations.</p>"},{"location":"features/controller-metrics/#installing-and-configuring-prometheus","title":"Installing and configuring Prometheus","text":"<p>To take advantage of the metrics you need to have Prometheus installed in your Kubernetes cluster. If you don't have an existing installation of Prometheus you can use any of the common methods to install it in your cluster. Popular options include the Prometheus Helm chart or the Prometheus Operator.</p> <p>Once Prometheus is running in your cluster you need to make sure that it scrapes the Argo Rollouts endpoint. Prometheus already contains a service discovery mechanism for Kubernetes, but you need to configure it first. Depending on your installation method you might need to take additional actions to scrape the Argo Rollouts endpoint.</p> <p>For example, if you used the Helm chart of Prometheus you need to annotate your Argo Rollouts Controller with the following:</p> <pre><code>spec:\n  template:\n    metadata:\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/path: /metrics\n        prometheus.io/port: \"8090\"\n</code></pre> <p>You can always see if the controller is reached successfully in the Prometheus \"Targets\" screen:</p> <p></p> <p>Once the controller metrics are read by your Prometheus instance, you can use them like any other Prometheus data source.</p>"},{"location":"features/controller-metrics/#creating-grafana-dashboards","title":"Creating Grafana Dashboards","text":"<p>You can easily visualize the metrics from the controller using Grafana dashboards. Install Grafana in your cluster and connect it your Prometheus instance. Then you can create any dashboard by using the available metrics (described in detail in the next sections).</p> <p>As a starting point you can find an existing dashboard at https://github.com/argoproj/argo-rollouts/blob/master/examples/dashboard.json</p> <p></p> <p>You can import this Dashboard in your Grafana installation as a JSON file.</p>"},{"location":"features/controller-metrics/#available-metrics-for-rollout-objects","title":"Available metrics for Rollout Objects","text":"<p>The Argo Rollouts controller publishes the following prometheus metrics about Argo Rollout objects.</p> Name Description <code>rollout_info</code> Information about rollout. <code>rollout_info_replicas_available</code> The number of available replicas per rollout. <code>rollout_info_replicas_unavailable</code> The number of unavailable replicas per rollout. <code>rollout_info_replicas_desired</code> The number of desired replicas per rollout. <code>rollout_info_replicas_updated</code> The number of updated replicas per rollout. <code>rollout_phase</code> [DEPRECATED - use rollout_info] Information on the state of the rollout. <code>rollout_reconcile</code> Rollout reconciliation performance. <code>rollout_reconcile_error</code> Error occurring during the rollout. <code>experiment_info</code> Information about Experiment. <code>experiment_phase</code> Information on the state of the experiment. <code>experiment_reconcile</code> Experiments reconciliation performance. <code>experiment_reconcile_error</code> Error occurring during the experiment. <code>analysis_run_info</code> Information about analysis run. <code>analysis_run_metric_phase</code> Information on the duration of a specific metric in the Analysis Run. <code>analysis_run_metric_type</code> Information on the type of a specific metric in the Analysis Runs. <code>analysis_run_phase</code> Information on the state of the Analysis Run. <code>analysis_run_reconcile</code> Analysis Run reconciliation performance. <code>analysis_run_reconcile_error</code> Error occurring during the analysis run."},{"location":"features/controller-metrics/#available-metrics-for-the-controller-itself","title":"Available metrics for the controller itself","text":"<p>The controller also publishes the following Prometheus metrics to describe the controller health.</p> Name Description <code>controller_clientset_k8s_request_total</code> Number of kubernetes requests executed during application reconciliation. <code>workqueue_adds_total</code> Total number of adds handled by workqueue <code>workqueue_depth</code> Current depth of workqueue <code>workqueue_queue_duration_seconds</code> How long in seconds an item stays in workqueue before being requested. <code>workqueue_work_duration_seconds</code> How long in seconds processing an item from workqueue takes. <code>workqueue_unfinished_work_seconds</code> How many seconds of work has done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases. <code>workqueue_longest_running_processor_seconds</code> How many seconds has the longest running processor for workqueue been running <code>workqueue_retries_total</code> Total number of retries handled by workqueue <p>In addition, the Argo-rollouts offers metrics on CPU, memory and file descriptor usage as well as the process start time and memory stats of current Go processes.</p>"},{"location":"features/ephemeral-metadata/","title":"Ephemeral Metadata","text":"<p>Important</p> <p>Available for canary rollouts since v0.10.0</p> <p>Important</p> <p>Available for blue-green rollouts since v1.0</p> <p>One use case is for a Rollout to label or annotate the desired/stable pods with user-defined labels/annotations, for only the duration which they are the desired or stable set, and for the labels to be updated/removed as soon as the ReplicaSet switches roles (e.g. from desired to stable). The use case which this enables, is to allow prometheus, wavefront, datadog queries and dashboards to be built, which can rely on a consistent list of labels, rather than the <code>rollouts-pod-template-hash</code> which is unpredictable and changing from revision to revision.</p> <p>A Rollout using the canary strategy has the ability to attach ephemeral metadata to the stable or canary Pods using the <code>stableMetadata</code> and <code>canaryMetadata</code> fields respectively.</p> <pre><code>spec:\n  strategy:\n    canary:\n      stableMetadata:\n        labels:\n          role: stable\n      canaryMetadata:\n        labels:\n          role: canary\n</code></pre> <p>A Rollout using the blue-green strategy has the ability to attach ephemeral metadata to the active or preview Pods using the <code>activeMetadata</code> and <code>previewMetadata</code> fields respectively.</p> <pre><code>spec:\n  strategy:\n    blueGreen:\n      activeMetadata:\n        labels:\n          role: active\n      previewMetadata:\n        labels:\n          role: preview\n</code></pre> <p>During an update, the Rollout will create the desired ReplicaSet while also merging the metadata defined in <code>canaryMetadata</code>/<code>previewMetadata</code> to the desired ReplicaSet's <code>spec.template.metadata</code>. This results in all Pods of the ReplicaSet being created with the desired metadata. When the rollout becomes fully promoted, the desired ReplicaSet becomes the stable, and is updated to use the labels and annotations under <code>stableMetadata</code>/<code>activeMetadata</code>. The Pods of the ReplicaSet will then be updated in place to use the stable metadata (without recreating the pods).</p> <p>Important</p> <p>In order for tooling to take advantage of this feature, they would need to recognize the change in labels and/or annotations that happen after the Pod has already started. Not all tools may detect this.</p>"},{"location":"features/experiment/","title":"Experiment CRD","text":""},{"location":"features/experiment/#what-is-the-experiment-crd","title":"What is the Experiment CRD?","text":"<p>The Experiment CRD allows users to have ephemeral runs of one or more ReplicaSets. In addition to running ephemeral ReplicaSets, the Experiment CRD can launch AnalysisRuns alongside the ReplicaSets. Generally, those AnalysisRun is used to confirm that new ReplicaSets are running as expected.</p> <p>A Service routing traffic to the Experiment ReplicaSet is also generated if a weight (which requires traffic routing) OR the Service attribute for that experiment is set.</p>"},{"location":"features/experiment/#use-cases-of-experiments","title":"Use cases of Experiments","text":"<ul> <li> <p>A user wants to run two versions of an application for a specific duration to enable Kayenta-style analysis of their application. The Experiment CRD creates 2 ReplicaSets (a baseline and a canary) based on the <code>spec.templates</code> field of the Experiment and waits until both are healthy. After the duration passes, the Experiment scales down the ReplicaSets, and the user can start the Kayenta analysis run.</p> </li> <li> <p>A user can use experiments to enable A/B/C testing by launching multiple experiments with a different version of their application for a long duration. Each Experiment has one PodSpec template that defines a specific version a user would want to run. The Experiment allows users to launch multiple experiments at once and keep each Experiment self-contained.</p> </li> <li> <p>Launching a new version of an existing application with different labels to avoid receiving traffic from a Kubernetes service. The user can run tests against the new version before continuing the Rollout.</p> </li> </ul>"},{"location":"features/experiment/#experiment-spec","title":"Experiment Spec","text":"<p>Below is an example of an experiment that creates two ReplicaSets with 1 replica each and runs them for 20 minutes once they both become available. Additionally, several AnalysisRuns are run to perform analysis against the pods of the Experiment </p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Experiment\nmetadata:\n  name: example-experiment\nspec:\n  # Duration of the experiment, beginning from when all ReplicaSets became healthy (optional)\n  # If omitted, will run indefinitely until terminated, or until all analyses which were marked\n  # `requiredForCompletion` have completed.\n  duration: 20m\n\n  # Deadline in seconds in which a ReplicaSet should make progress towards becoming available.\n  # If exceeded, the Experiment will fail.\n  progressDeadlineSeconds: 30\n\n  # List of pod template specs to run in the experiment as ReplicaSets\n  templates:\n  - name: purple\n    # Number of replicas to run (optional). If omitted, will run a single replica\n    replicas: 1\n    # Flag to create Service for this Experiment (optional)\n    # If omitted, a Service won't be created.\n    service:\n      # Name of the Service (optional). If omitted, service: {} would also be acceptable.\n      name: service-name\n    selector:\n      matchLabels:\n        app: canary-demo\n        color: purple\n    template:\n      metadata:\n        labels:\n          app: canary-demo\n          color: purple\n      spec:\n        containers:\n        - name: rollouts-demo\n          image: argoproj/rollouts-demo:purple\n          imagePullPolicy: Always\n          ports:\n          - name: http\n            containerPort: 8080\n            protocol: TCP\n  - name: orange\n    replicas: 1\n    minReadySeconds: 10\n    selector:\n      matchLabels:\n        app: canary-demo\n        color: orange\n    template:\n      metadata:\n        labels:\n          app: canary-demo\n          color: orange\n      spec:\n        containers:\n        - name: rollouts-demo\n          image: argoproj/rollouts-demo:orange\n          imagePullPolicy: Always\n          ports:\n          - name: http\n            containerPort: 8080\n            protocol: TCP\n\n  # List of AnalysisTemplate references to perform during the experiment\n  analyses:\n  - name: purple\n    templateName: http-benchmark\n    args:\n    - name: host\n      value: purple\n  - name: orange\n    templateName: http-benchmark\n    args:\n    - name: host\n      value: orange\n  - name: compare-results\n    templateName: compare\n    # If requiredForCompletion is true for an analysis reference, the Experiment will not complete\n    # until this analysis has completed.\n    requiredForCompletion: true\n    args:\n    - name: host\n      value: purple\n</code></pre>"},{"location":"features/experiment/#experiment-lifecycle","title":"Experiment Lifecycle","text":"<p>An Experiment is intended to temporarily run one or more templates. The lifecycle of an Experiment is as follows:</p> <ol> <li>Create and scale a ReplicaSet for each pod template specified under <code>spec.templates</code>. If    <code>service</code> is specified under a pod template, a Service will also be created for that pod.</li> <li>Wait for all ReplicaSets reach full availability. If a ReplicaSet does not become available    within <code>spec.progressDeadlineSeconds</code>, the Experiment will fail. Once available, the Experiment    will transition from the <code>Pending</code> state to a <code>Running</code> state.</li> <li>Once an Experiment is considered <code>Running</code>, it will begin an AnalysisRun for every    AnalysisTemplate referenced under <code>spec.analyses</code>.</li> <li>If a duration is specified under <code>spec.duration</code>, the Experiment will wait until the duration    has elapsed before completing the Experiment.</li> <li>If an AnalysisRun fails or errors, the Experiment will end prematurely, with a status equal to    the unsuccessful AnalysisRun (i.e. <code>Failed</code> or <code>Error</code>)</li> <li>If one or more of the referenced AnalysisTemplates is marked with <code>requiredForCompletion: true</code>,    the Experiment will not complete until those AnalysisRuns have completed, even if it exceeds    the Experiment duration.</li> <li>If neither a <code>spec.duration</code> or <code>requiredForCompletion: true</code> is specified, the Experiment will    run indefinitely, until explicitly terminated (by setting <code>spec.terminate: true</code>).</li> <li>Once an Experiment is complete, the ReplicaSets will be scaled to zero, and any incomplete    AnalysisRuns will be terminated.</li> </ol> <p>Note</p> <p>ReplicaSet names are generated by combining the Experiment name with the template name.</p>"},{"location":"features/experiment/#integration-with-rollouts","title":"Integration With Rollouts","text":"<p>A rollout using the Canary strategy can create an experiment using an <code>experiment</code> step. The experiment step serves as a blocking step for the Rollout, and a Rollout will not continue until the Experiment succeeds. The Rollout creates an Experiment using the configuration in the experiment step of the Rollout. If the Experiment fails or errors, the Rollout will abort.</p> <p>Note</p> <p>Experiment names are generated by combining the Rollout's name, the PodHash of the new ReplicaSet, the current revision of the Rollout, and the current step-index.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\n  labels:\n    app: guestbook\nspec:\n...\n  strategy:\n    canary: \n      steps:\n      - experiment:\n          duration: 1h\n          templates:\n          - name: baseline\n            specRef: stable\n          - name: canary\n            specRef: canary\n          analyses:\n          - name : mann-whitney\n            templateName: mann-whitney\n            args:\n            - name: baseline-hash\n              value: \"{{templates.baseline.podTemplateHash}}\"\n            - name: canary-hash\n              value: \"{{templates.canary.podTemplateHash}}\"\n</code></pre> <p>In the example above, during an update of a Rollout, the Rollout will launch an Experiment. The Experiment will create two ReplicaSets: <code>baseline</code> and <code>canary</code>, with one replica each, and will run for one hour. The <code>baseline</code> template uses the PodSpec from the stable ReplicaSet, and the canary template uses the PodSpec from the canary ReplicaSet.</p> <p>Additionally, the Experiment will perform analysis using the AnalysisTemplate named <code>mann-whitney</code>. The AnalysisRun is supplied with the pod-hash details of the baseline and canary to perform the necessary metrics queries, using the <code>{{templates.baseline.podTemplateHash}}</code> and <code>{{templates.canary.podTemplateHash}}</code> variables respectively.</p> <p>Note</p> <p>The pod-hashes of the <code>baseline</code>/<code>canary</code> ReplicaSets created by the Experiment, will have different values than the pod-hashes of the <code>stable</code>/<code>canary</code> ReplicaSets created by the Rollout. This is despite the fact that the PodSpec are the same. This is intentional behavior, in order to allow the metrics of the Experiment's pods to be delineated and queried separately from the metrics of the Rollout pods.</p>"},{"location":"features/experiment/#weighted-experiment-step-with-traffic-routing","title":"Weighted Experiment Step with Traffic Routing","text":"<p>Important</p> <p>Available since v1.1</p> <p>A Rollout using the Canary strategy along with Traffic Routing can  split traffic to an experiment stack in a fine-grained manner. When Traffic Routing is enabled, the Rollout Experiment step allows traffic to be shifted to experiment pods.</p> <p>Note</p> <p>This feature is currently available only for the SMI, ALB, and Istio Traffic Routers.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\n  labels:\n    app: guestbook\nspec:\n...\nstrategy:\n  canary:\n    trafficRouting:\n      alb:\n        ingress: ingress\n        ...\n    steps:\n      - experiment:\n          duration: 1h\n          templates:\n            - name: experiment-baseline\n              specRef: stable\n              weight: 5\n            - name: experiment-canary\n              specRef: canary\n              weight: 5\n</code></pre> <p>In the above example, during an update, the first step would start a baseline vs. canary experiment. When pods are ready (Experiment enters Running phase), the rollout would direct 5% of traffic to <code>experiment-canary</code> and 5% to <code>experiment-baseline</code>, leaving the remaining 90% of traffic to the old stack.</p> <p>Note</p> <p>When a weighted experiment step with traffic routing is used, a service is auto-created for each experiment template. The traffic routers use this service to send traffic to the experiment pods.</p> <p>By default, the generated Service has the name of the ReplicaSet and inherits ports and selector from the specRef definition. It can be accessed in using the <code>{{templates.baseline.replicaset.name}}</code> or <code>{{templates.canary.replicaset.name}}</code> variables respectively.</p>"},{"location":"features/experiment/#experiment-service-creation-without-weight","title":"Experiment Service Creation without Weight","text":"<p>If you don't want to use traffic routing for your Experiments but still want to create a Service for them, you can set a Service object which takes an optional Name, without having to set a Weight for them.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: guestbook\n  labels:\n    app: guestbook\nspec:\n...\nstrategy:\n  canary:\n    steps:\n      - experiment:\n          duration: 1h\n          templates:\n            - name: experiment-baseline\n              specRef: stable\n              service:\n                name: test-service\n            - name: experiment-canary\n              specRef: canary\n</code></pre> <p>In the above example, during an update, the first step would start a baseline vs. canary experiment. This time, a service would be created for <code>experiment-baseline</code> even without setting a weight for it or traffic routing for the rollout.</p>"},{"location":"features/helm/","title":"Using Argo Rollouts with Helm","text":"<p>Argo Rollouts will always respond to changes in Rollouts resources regardless of how the change was made. This means that Argo Rollouts is compatible with all templating solutions that you might use to manage your deployments.</p> <p>Argo Rollouts manifests can be managed with the Helm package manager. If your Helm chart contains Rollout Resources, then as soon as you install/upgrade your chart, Argo Rollouts will take over and initiate the progressive delivery process.</p> <p>Here is an example Rollout that is managed with Helm:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: {{ template \"helm-guestbook.fullname\" . }}\n  labels:\n    app: {{ template \"helm-guestbook.name\" . }}\n    chart: {{ template \"helm-guestbook.chart\" . }}\n    release: {{ .Release.Name }}\n    heritage: {{ .Release.Service }}\nspec:\n  replicas: {{ .Values.replicaCount }}\n  revisionHistoryLimit: 3\n  selector:\n    matchLabels:\n      app: {{ template \"helm-guestbook.name\" . }}\n      release: {{ .Release.Name }}\n  strategy:\n    blueGreen:\n      activeService: {{ template \"helm-guestbook.fullname\" . }}\n      previewService: {{ template \"helm-guestbook.fullname\" . }}-preview\n  template:\n    metadata:\n      labels:\n        app: {{ template \"helm-guestbook.name\" . }}\n        release: {{ .Release.Name }}\n    spec:\n      containers:\n        - name: {{ .Chart.Name }}\n          image: \"{{ .Values.image.repository }}:{{ .Values.image.tag }}\"\n          imagePullPolicy: {{ .Values.image.pullPolicy }}\n          ports:\n            - name: http\n              containerPort: 80\n              protocol: TCP\n          livenessProbe:\n            httpGet:\n              path: /\n              port: http\n          readinessProbe:\n            httpGet:\n              path: /\n              port: http\n          resources:\n{{ toYaml .Values.resources | indent 12 }}\n    {{- with .Values.nodeSelector }}\n      nodeSelector:\n{{ toYaml . | indent 8 }}\n    {{- end }}\n    {{- with .Values.affinity }}\n      affinity:\n{{ toYaml . | indent 8 }}\n    {{- end }}\n    {{- with .Values.tolerations }}\n      tolerations:\n{{ toYaml . | indent 8 }}\n    {{- end }}\n</code></pre> <p>You can find the full example at https://github.com/argoproj/argo-rollouts/tree/master/examples/helm-blue-green.</p>"},{"location":"features/hpa-support/","title":"Horizontal Pod Autoscaling","text":"<p>Horizontal Pod Autoscaling (HPA) automatically scales the number of pods in owned by a Kubernetes resource based on observed CPU utilization or user-configured metrics. In order to accomplish this behavior, HPA only supports resources with the scale endpoint enabled with a couple of required fields. The scale endpoint allows the HPA to understand the current state of a resource and modify the resource to scale it appropriately.  Argo Rollouts added support for the scale endpoint in the <code>0.3.0</code> release. After being modified by the HPA, the Argo Rollouts controller is responsible for reconciling that change in replicas. Since the strategies within a Rollout are very different, the Argo Rollouts controller handles the scale endpoint differently for various strategies. Below is the behavior for the different strategies:</p>"},{"location":"features/hpa-support/#blue-green","title":"Blue Green","text":"<p>The HPA will scale rollouts using the <code>BlueGreen</code> strategy using the metrics from the ReplicaSet receiving traffic from the active service. When the HPA changes the replicas count, the Argo Rollouts controller will first scale up the ReplicaSet receiving traffic from the active service before ReplicaSet receiving traffic from the preview service. The controller will scale up the ReplicaSet receiving traffic from the preview service to prepare it for when the rollout switches the preview to active.  If there are no ReplicaSets receiving from the active service, the controller will use all the pods that match the base selector to determine scaling events. In that case, the controller will scale up the latest ReplicaSet to the new count and scale down the older ReplicaSets.</p>"},{"location":"features/hpa-support/#canary-replicaset-based","title":"Canary (ReplicaSet based)","text":"<p>The HPA will scale rollouts using the <code>Canary</code> Strategy using the metrics of all the ReplicasSets within the rollout. Since the Argo Rollouts controller does not control the service that sends traffic to those ReplicaSets, it assumes that all the ReplicaSets in the rollout are receiving traffic.</p>"},{"location":"features/hpa-support/#example","title":"Example","text":"<p>Below is an example of a Horizontal Pod Autoscaler that scales a rollout based on CPU metrics:</p> <pre><code>apiVersion: autoscaling/v1\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: hpa-rollout-example\nspec:\n  maxReplicas: 6\n  minReplicas: 2\n  scaleTargetRef:\n    apiVersion: argoproj.io/v1alpha1\n    kind: Rollout\n    name: example-rollout\n  targetCPUUtilizationPercentage: 80\n</code></pre>"},{"location":"features/hpa-support/#requirements","title":"Requirements","text":"<p>In order for the HPA to manipulate the rollout, the Kubernetes cluster hosting the rollout CRD needs the subresources support for CRDs.  This feature was introduced as alpha in Kubernetes version 1.10 and transitioned to beta in Kubernetes version 1.11.  If a user wants to use HPA on v1.10, the Kubernetes Cluster operator will need to add a custom feature flag to the API server.  After 1.10, the flag is turned on by default.  Check out the following link for more information on setting the custom feature flag.</p>"},{"location":"features/kubectl-plugin/","title":"Kubectl Plugin","text":"<p>Kubectl plugins are a way to extend the kubectl command to provide additional behavior. Generally, they are used to add new functionality to kubectl and automate scriptable workflows against a cluster. The official documentation on them is here.</p> <p>Argo Rollouts offers a Kubectl plugin to enrich the experience with Rollouts, Experiments, and Analysis from the command line. It offers the ability to visualize the Argo Rollouts resources and run routine operations like promote or retry on those resources from the command.</p>"},{"location":"features/kubectl-plugin/#installation","title":"Installation","text":"<p>See the installation guide for instructions on installing the plugin.</p>"},{"location":"features/kubectl-plugin/#usage","title":"Usage","text":"<p>The best way to get information on the available Argo Rollouts kubectl plugin commands is by run <code>kubectl argo rollouts</code>. The plugin lists all the available commands that the tool can execute along with a description of each commend. All the plugin's commands interact with the Kubernetes API server and use KubeConfig credentials for authentication. Since the plugin leverages the KubeConfig of the user running the command, the plugin has the permissions of those configs. </p> <p>Similar to kubectl, the plugin uses many of the same flags as the kubectl. For example, the <code>kubectl argo rollouts get rollout canary-demo -w</code> command starts a watch on the <code>canary-demo</code> rollout object similar to how the <code>kubectl get deployment canary-demo -w</code> command starts a watch on a deployment.</p>"},{"location":"features/kubectl-plugin/#visualizing-rollouts-and-experiments","title":"Visualizing Rollouts and Experiments","text":"<p>In addition to encapsulating many routine commands, the Argo Rollouts kubectl plugin supports visualizing rollouts and experiments with the get command. The get command provides a clean representation of either the rollouts or the experiments running in a cluster. It returns a bunch of metadata on a resource and a tree view of the child resources created by the parent. As an example, here is a rollout retrieved with a get command:</p> <p></p> <p>Here is a table to explain some of the icons on the tree view:</p> Icon Kind \u27f3 Rollout \u03a3 Experiment \u03b1 AnalysisRun # Revision \u29c9 ReplicaSet \u25a1 Pod \u229e Job <p>If the get command includes the watch flag (<code>-w</code> or <code>--watch</code>), the terminal updates as the rollouts or experiment progress highlighting the progress.</p>"},{"location":"features/kustomize/","title":"Kustomize Integration","text":"<p>Kustomize can be extended to understand CRD objects through the use of transformer configs. Using transformer configs, kustomize can be \"taught\" about the structure of a Rollout object and leverage kustomize features such as ConfigMap/Secret generators, variable references, and common labels &amp; annotations. To use Rollouts with kustomize:</p> <ol> <li> <p>Download <code>rollout-transform.yaml</code> into your kustomize directory.</p> </li> <li> <p>Include <code>rollout-transform.yaml</code> in your kustomize <code>configurations</code> section:</p> </li> </ol> <pre><code>kind: Kustomization\napiVersion: kustomize.config.k8s.io/v1beta1\n\nconfigurations:\n- rollout-transform.yaml\n</code></pre> <p>An example kustomize app demonstrating the ability to use transformers with Rollouts can be seen here.</p> <ul> <li>With Kustomize 3.6.1 it is possible to reference the configuration directly from a remote resource:</li> </ul> <pre><code>configurations:\n  - https://argoproj.github.io/argo-rollouts/features/kustomize/rollout-transform.yaml\n</code></pre> <ul> <li>With Kustomize 5 it is possible to reference the configuration directly from a remote resource:</li> </ul> <pre><code>configurations:\n  - https://argoproj.github.io/argo-rollouts/features/kustomize/rollout-transform-kustomize-v5.yaml\n</code></pre> <ul> <li>With Kustomize 4.5.5 kustomize can use kubernetes OpenAPI data to get merge key and patch strategy information about resource types. For example, given the following rollout:</li> </ul> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollout-canary\nspec:\n  strategy:\n    canary:\n      steps:\n      # detail of the canary steps is omitted\n  template:\n    metadata:\n      labels:\n        app: rollout-canary\n    spec:\n      containers:\n      - name: rollouts-demo\n        image: argoproj/rollouts-demo:blue\n        imagePullPolicy: Always\n        ports:\n        - containerPort: 8080\n</code></pre> <p>user can update the Rollout via a patch in a kustomization file, to change the image to nginx</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nresources:\n- rollout-canary.yaml\n\nopenapi:\n  path: https://raw.githubusercontent.com/argoproj/argo-schema-generator/main/schema/argo_all_k8s_kustomize_schema.json\n\npatches:\n- patch: |-\n    apiVersion: argoproj.io/v1alpha1\n    kind: Rollout\n    metadata:\n      name: rollout-canary\n    spec:\n      template:\n        spec:\n          containers:\n          - name: rollouts-demo\n            image: nginx\n</code></pre> <p>The OpenAPI data is auto-generated and defined in this file.</p> <p>An example kustomize app demonstrating the ability to use OpenAPI data with Rollouts can be seen here.</p>"},{"location":"features/notifications/","title":"Notifications","text":"<p>Important</p> <p>Available since v1.1</p> <p>Argo Rollouts provides notifications powered by the Notifications Engine. Controller administrators can leverage flexible systems of triggers and templates to configure notifications requested by the end users. The end-users can subscribe to the configured triggers by adding an annotation to the Rollout objects.</p>"},{"location":"features/notifications/#configuration","title":"Configuration","text":"<p>The trigger defines the condition when the notification should be sent as well as the notification content template. Default Argo Rollouts comes with a list of built-in triggers that cover the most important events of Argo Rollout live-cycle. Both triggers and templates are configured in the <code>argo-rollouts-notification-configmap</code> ConfigMap. In order to get started quickly, you can use pre-configured notification templates defined in notifications-install.yaml.</p> <p>If you are leveraging Kustomize it is recommended to include notifications-install.yaml as a remote resource into your <code>kustomization.yaml</code> file:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nresources:\n- https://github.com/argoproj/argo-rollouts/releases/latest/download/install.yaml\n- https://github.com/argoproj/argo-rollouts/releases/latest/download/notifications-install.yaml\n</code></pre> <p>After including the <code>argo-rollouts-notification-configmap</code> ConfigMap the administrator needs to configure integration with the required notifications service such as Slack or MS Teams. An example below demonstrates Slack integration:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  # detail of the templates is omitted\n  # detail of the triggers is omitted\n  service.slack: |\n    token: $slack-token\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: argo-rollouts-notification-secret\nstringData:\n  slack-token: &lt;my-slack-token&gt;\n</code></pre> <p>Learn more about supported services and configuration settings in services documentation.</p>"},{"location":"features/notifications/#namespace-based-configuration","title":"Namespace based configuration","text":"<p>Important</p> <p>Available since v1.6</p> <p>A common installation method for Argo Rollouts is to install it in a dedicated namespace to manage a whole cluster. In this case, the administrator is the only person who can configure notifications in that namespace generally. However, in some cases, it is required to allow end-users to configure notifications for their Rollout resources. For example, the end-user can configure notifications for their Rollouts in the namespace where they have access to and their rollout is running in.</p> <p>To use this feature all you need to do is create the same configmap named <code>argo-rollouts-notification-configmap</code> and possibly  a secret <code>argo-rollouts-notification-secret</code> in the namespace where the rollout object lives. When it is configured this way the controller will send notifications using both the controller level configuration (the configmap located in the same namespaces as the controller) as well as  the configmap located in the same namespaces where the rollout object is at.</p> <p>To enable you need to add a flag to the controller <code>--self-service-notification-enabled</code></p>"},{"location":"features/notifications/#default-trigger-templates","title":"Default Trigger templates","text":"<p>Currently the following triggers have built-in templates.</p> <ul> <li><code>on-rollout-completed</code> when a rollout is finished and all its steps are completed</li> <li><code>on-rollout-step-completed</code> when an individual step inside a rollout definition is completed</li> <li><code>on-rollout-updated</code> when a rollout definition is changed</li> <li><code>on-scaling-replica-set</code> when the number of replicas in a rollout is changed</li> </ul>"},{"location":"features/notifications/#subscriptions","title":"Subscriptions","text":"<p>The end-users can start leveraging notifications using <code>notifications.argoproj.io/subscribe.&lt;trigger&gt;.&lt;service&gt;: &lt;recipient&gt;</code> annotation. For example, the following annotation subscribes two Slack channels to notifications about canary rollout step completion:</p> <pre><code>---\napiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollout-canary\n  annotations:\n    notifications.argoproj.io/subscribe.on-rollout-step-completed.slack: my-channel1;my-channel2\n</code></pre> <p>Annotation key consists of following parts:</p> <ul> <li><code>on-rollout-step-completed</code> - trigger name</li> <li><code>slack</code> - notification service name</li> <li><code>my-channel1;my-channel2</code> - a semicolon separated list of recipients</li> </ul>"},{"location":"features/notifications/#customization","title":"Customization","text":"<p>The Rollout administrator can customize the notifications by configuring notification templates and custom triggers in <code>argo-rollouts-notification-configmap</code> ConfigMap.</p>"},{"location":"features/notifications/#templates","title":"Templates","text":"<p>The notification template is a stateless function that generates the notification content. The template is leveraging html/template golang package. It is meant to be reusable and can be referenced by multiple triggers.</p> <p>An example below demonstrates a sample template:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  template.my-purple-template: |\n    message: |\n      Rollout {{.rollout.metadata.name}} has purple image\n    slack:\n        attachments: |\n            [{\n              \"title\": \"{{ .rollout.metadata.name}}\",\n              \"color\": \"#800080\"\n            }]\n</code></pre> <p>Each template has access to the following fields:</p> <ul> <li><code>rollout</code> holds the rollout object.</li> <li><code>recipient</code> holds the recipient name.</li> </ul> <p>The <code>message</code> field of the template definition allows creating a basic notification for any notification service. You can leverage notification service-specific fields to create complex notifications. For example using service-specific you can add blocks and attachments for Slack, subject for Email or URL path, and body for Webhook. See corresponding service documentation for more information.</p>"},{"location":"features/notifications/#custom-triggers","title":"Custom Triggers","text":"<p>In addition to custom notification template administrator and configure custom triggers. Custom trigger defines the condition when the notification should be sent. The definition includes name, condition and notification templates reference. The condition is a predicate expression that returns true if the notification should be sent. The trigger condition evaluation is powered by antonmedv/expr. The condition language syntax is described at Language-Definition.md.</p> <p>The trigger is configured in <code>argo-rollouts-notification-configmap</code> ConfigMap. For example the following trigger sends a notification when rollout pod spec uses <code>argoproj/rollouts-demo:purple</code> image:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  trigger.on-purple: |\n    - send: [my-purple-template]\n      when: rollout.spec.template.spec.containers[0].image == 'argoproj/rollouts-demo:purple'\n</code></pre> <p>Each condition might use several templates. Typically each template is responsible for generating a service-specific notification part.</p>"},{"location":"features/notifications/#notification-metrics","title":"Notification Metrics","text":"<p>The following prometheus metrics are emitted when notifications are enabled in argo-rollouts. - notification_send_success is a counter that measures how many times the notification is sent successfully. - notification_send_error is a counter that measures how many times the notification failed to send. - notification_send is a histogram that measures performance of sending notification.</p>"},{"location":"features/restart/","title":"Restarting Rollout Pods","text":"<p>For various reasons, applications often need to be restarted, e.g. for hygiene purposes or to force startup logic to occur again such as reloading of a modified Secret. In these scenarios, it is undesirable to go through an entire blue-green or canary update process. Argo Rollouts supports the ability to restart all of its Pods by performing a rolling recreate of all the Pods in a Rollout while skipping the regular BlueGreen or Canary update strategy.</p>"},{"location":"features/restart/#how-it-works","title":"How it works","text":"<p>A rollout can be restarted via the kubectl plugin, using the restart command:</p> <pre><code>kubectl-argo-rollouts restart ROLLOUT\n</code></pre> <p>Alternatively, if Rollouts is used with Argo CD, the there is a bundled \"restart\" action which can be performed via the Argo CD UI or CLI:</p> <pre><code>argocd app actions run my-app restart --kind Rollout --resource-name my-rollout\n</code></pre> <p>Both of these mechanisms updates the Rollout's <code>.spec.restartAt</code> to the current time in the form of a RFC 3339 formatted UTC string (e.g. 2020-03-30T21:19:35Z), which indicates to the Rollout controller that all of a Rollout's Pods should have been created after this timestamp.</p> <p>During a restart, the controller iterates through each ReplicaSet to see if all the Pods have a  creation timestamp which is newer than the <code>restartAt</code> time. For every pod older than the <code>restartAt</code> timestamp, the Pod will be evicted, allowing the ReplicaSet to replace the pod with a recreated one.</p> <p>To prevent too many Pods from restarting at once, the controller limits itself to deleting up to  <code>maxUnavailable</code> Pods at a time. Secondly, since pods are evicted and not deleted, the restart process will honor any PodDisruptionBudgets which are in place. The controller restarts ReplicaSets in the following order:   1. stable ReplicaSet   2. current ReplicaSet   3. all other ReplicaSets beginning with the oldest</p> <p>If a Rollout's pod template spec (<code>spec.template</code>) is modified in the middle of a restart, the restart is canceled, and the normal blue-green or canary update will occur.</p> <p>Note: Unlike deployments, where a \"restart\" is nothing but a normal rolling upgrade that happened to be triggered by a timestamp in the pod spec annotation, Argo Rollouts facilitates restarts by terminating pods and allowing the existing ReplicaSet to replace the terminated pods. This design choice was made in order to allow a restart to occur even when a Rollout was in the middle of a long-running blue-green/canary update (e.g. a paused canary). However, some consequences of this are:</p> <ul> <li>Restarting a Rollout which has a single replica will cause downtime since Argo Rollouts needs to   terminate the pod in order to replace it.</li> <li>Restarting a rollout will be slower than a deployment's rolling update, since maxSurge is not   used to bring up newer pods faster.</li> <li>maxUnavailable will be used to restart multiple pods at a time (starting in v0.10). But if   maxUnavailable pods is 0, the controller will still restart pods one at a time.</li> </ul>"},{"location":"features/restart/#scheduled-restarts","title":"Scheduled Restarts","text":"<p>Users can schedule a restart on their Rollout by setting the <code>.spec.restartAt</code> field to a time in the future. The controller only starts the restart after the current time is after the restartAt time. </p>"},{"location":"features/rollback/","title":"Rollback Windows","text":"<p>Important</p> <p>Available for blue-green and canary rollouts since v1.4</p> <p>By default, when an older Rollout manifest is re-applied, the controller treats it the same as a spec change, and will execute the full list of steps, and perform analysis too. There are two exceptions to this rule:  1. the controller detects if it is moving back to a blue-green ReplicaSet which exists and is still scaled up (within its <code>scaleDownDelay</code>)  2. the controller detects it is moving back to the canary's \"stable\" ReplicaSet, and the upgrade had not yet completed.</p> <p>It is often undesirable to re-run analysis and steps for a rollout, when the desired behavior is to rollback as soon as possible. To help with this, a rollback window feature allows users to indicate that the promotion to the ReplicaSet within the window will skip all steps.</p> <p>Example:</p> <pre><code>spec:\n  rollbackWindow:\n    revisions: 3\n\n  revisionHistoryLimit: 5\n</code></pre> <p>Assume a linear revision history: <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5 (current)</code>. A rollback from revision 5 back to 4 or 3 will fall within the window, so it will be fast tracked.</p>"},{"location":"features/scaledown-aborted-rs/","title":"Scaledown New Replicaset on Aborted Rollout","text":"<p>Upon an aborted update, we may scale down the new replicaset for all strategies. Users can then choose to leave the new replicaset scaled up indefinitely by setting abortScaleDownDelaySeconds to 0, or adjust the value to something larger (or smaller).</p> <p>The following table summarizes the behavior under combinations of rollout strategy and <code>abortScaleDownDelaySeconds</code>. Note that <code>abortScaleDownDelaySeconds</code> is not applicable to argo-rollouts v1.0. <code>abortScaleDownDelaySeconds = nil</code> is the default, which means in v1.1 across all rollout strategies, the new replicaset is scaled down in 30 seconds on abort by default.</p> strategy v1.0 behavior abortScaleDownDelaySeconds v1.1 behavior blue-green does not scale down nil scales down after 30 seconds blue-green does not scale down 0 does not scale down blue-green does not scale down N scales down after N seconds basic canary rolling update back to stable N/A rolling update back to stable canary w/ traffic routing scales down immediately nil scales down after 30 seconds canary w/ traffic routing scales down immediately 0 does not scale down canary w/ traffic routing scales down immediately N scales down after N seconds canary w/ traffic routing  + setCanaryScale does not scale down (bug) * should behave like  canary w/ traffic routing"},{"location":"features/specification/","title":"Rollout Specification","text":"<p>The following describes all the available fields of a rollout:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: example-rollout-canary\nspec:\n  # Number of desired pods.\n  # Defaults to 1.\n  replicas: 5\n  analysis:\n    # limits the number of successful analysis runs and experiments to be stored in a history\n    # Defaults to 5.\n    successfulRunHistoryLimit: 10\n    # limits the number of unsuccessful analysis runs and experiments to be stored in a history. \n    # Stages for unsuccessful: \"Error\", \"Failed\", \"Inconclusive\"\n    # Defaults to 5.\n    unsuccessfulRunHistoryLimit: 10\n\n  # Label selector for pods. Existing ReplicaSets whose pods are selected by\n  # this will be the ones affected by this rollout. It must match the pod\n  # template's labels.\n  selector:\n    matchLabels:\n      app: guestbook\n\n  # WorkloadRef holds a references to a workload that provides Pod template \n  # (e.g. Deployment). If used, then do not use Rollout template property.\n  workloadRef: \n    apiVersion: apps/v1\n    kind: Deployment\n    name: rollout-ref-deployment\n    # Specifies if the workload (Deployment) is scaled down after migrating to Rollout.\n    # The possible options are:\n    # \"never\": the Deployment is not scaled down\n    # \"onsuccess\": the Deployment is scaled down after the Rollout becomes healthy\n    # \"progressively\": as the Rollout is scaled up the Deployment is scaled down\n    # If the Rollout fails the Deployment will be scaled back up.\n    scaleDown: never|onsuccess|progressively\n\n  # Template describes the pods that will be created. Same as deployment.\n  # If used, then do not use Rollout workloadRef property. \n  template:\n    spec:\n      containers:\n      - name: guestbook\n        image: argoproj/rollouts-demo:blue\n\n  # Minimum number of seconds for which a newly created pod should be ready\n  # without any of its container crashing, for it to be considered available.\n  # Defaults to 0 (pod will be considered available as soon as it is ready)\n  minReadySeconds: 30\n\n  # The number of old ReplicaSets to retain.\n  # Defaults to 10\n  revisionHistoryLimit: 3\n\n  # Pause allows a user to manually pause a rollout at any time. A rollout\n  # will not advance through its steps while it is manually paused, but HPA\n  # auto-scaling will still occur. Typically not explicitly set the manifest,\n  # but controlled via tools (e.g. kubectl argo rollouts pause). If true at\n  # initial creation of Rollout, replicas are not scaled up automatically\n  # from zero unless manually promoted.\n  paused: true\n\n  # The maximum time in seconds in which a rollout must make progress during\n  # an update, before it is considered to be failed. Argo Rollouts will\n  # continue to process failed rollouts and a condition with a\n  # ProgressDeadlineExceeded reason will be surfaced in the rollout status.\n  # Note that progress will not be estimated during the time a rollout is\n  # paused.\n  # Defaults to 600s\n  progressDeadlineSeconds: 600\n\n  # Whether to abort the update when ProgressDeadlineSeconds is exceeded.\n  # Optional and default is false.\n  progressDeadlineAbort: false\n\n  # UTC timestamp in which a Rollout should sequentially restart all of\n  # its pods. Used by the `kubectl argo rollouts restart ROLLOUT` command.\n  # The controller will ensure all pods have a creationTimestamp greater\n  # than or equal to this value.\n  restartAt: \"2020-03-30T21:19:35Z\"\n\n  # The rollback window provides a way to fast track deployments to\n  # previously deployed versions.\n  # Optional, and by default is not set.\n  rollbackWindow:\n    revisions: 3\n\n  strategy:\n\n    # Blue-green update strategy\n    blueGreen:\n\n      # Reference to service that the rollout modifies as the active service.\n      # Required.\n      activeService: active-service\n\n      # Pre-promotion analysis run which performs analysis before the service\n      # cutover. +optional\n      prePromotionAnalysis:\n        templates:\n        - templateName: success-rate\n        args:\n        - name: service-name\n          value: guestbook-svc.default.svc.cluster.local\n\n      # Post-promotion analysis run which performs analysis after the service\n      # cutover. +optional\n      postPromotionAnalysis:\n        templates:\n        - templateName: success-rate\n        args:\n        - name: service-name\n          value: guestbook-svc.default.svc.cluster.local\n\n      # Name of the service that the rollout modifies as the preview service.\n      # +optional\n      previewService: preview-service\n\n      # The number of replicas to run under the preview service before the\n      # switchover. Once the rollout is resumed the new ReplicaSet will be fully\n      # scaled up before the switch occurs +optional\n      previewReplicaCount: 1\n\n      # Indicates if the rollout should automatically promote the new ReplicaSet\n      # to the active service or enter a paused state. If not specified, the\n      # default value is true. +optional\n      autoPromotionEnabled: false\n\n      # Automatically promotes the current ReplicaSet to active after the\n      # specified pause delay in seconds after the ReplicaSet becomes ready.\n      # If omitted, the Rollout enters and remains in a paused state until\n      # manually resumed by resetting spec.Paused to false. +optional\n      autoPromotionSeconds: 30\n\n      # Adds a delay before scaling down the previous ReplicaSet. If omitted,\n      # the Rollout waits 30 seconds before scaling down the previous ReplicaSet.\n      # A minimum of 30 seconds is recommended to ensure IP table propagation\n      # across the nodes in a cluster.\n      scaleDownDelaySeconds: 30\n\n      # Limits the number of old RS that can run at once before getting scaled\n      # down. Defaults to nil\n      scaleDownDelayRevisionLimit: 2\n\n      # Add a delay in second before scaling down the preview replicaset\n      # if update is aborted. 0 means not to scale down. Default is 30 second\n      abortScaleDownDelaySeconds: 30\n\n      # Anti Affinity configuration between desired and previous ReplicaSet.\n      # Only one must be specified\n      antiAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution: {}\n        preferredDuringSchedulingIgnoredDuringExecution:\n          weight: 1 # Between 1 - 100\n\n      # activeMetadata will be merged and updated in-place into the ReplicaSet's spec.template.metadata\n      # of the active pods. +optional\n      activeMetadata:\n        labels:\n          role: active\n\n      # Metadata which will be attached to the preview pods only during their preview phase.\n      # +optional\n      previewMetadata:\n        labels:\n          role: preview\n\n    # Canary update strategy\n    canary:\n\n      # Reference to a service which the controller will update to select\n      # canary pods. Required for traffic routing.\n      canaryService: canary-service\n\n      # Reference to a service which the controller will update to select\n      # stable pods. Required for traffic routing.\n      stableService: stable-service\n\n      # Metadata which will be attached to the canary pods. This metadata will\n      # only exist during an update, since there are no canary pods in a fully\n      # promoted rollout.\n      canaryMetadata:\n        annotations:\n          role: canary\n        labels:\n          role: canary\n\n      # metadata which will be attached to the stable pods\n      stableMetadata:\n        annotations:\n          role: stable\n        labels:\n          role: stable\n\n      # The maximum number of pods that can be unavailable during the update.\n      # Value can be an absolute number (ex: 5) or a percentage of total pods\n      # at the start of update (ex: 10%). Absolute number is calculated from\n      # percentage by rounding down. This can not be 0 if  MaxSurge is 0. By\n      # default, a fixed value of 1 is used. Example: when this is set to 30%,\n      # the old RC can be scaled down by 30% immediately when the rolling\n      # update starts. Once new pods are ready, old RC can be scaled down\n      # further, followed by scaling up the new RC, ensuring that at least 70%\n      # of original number of pods are available at all times during the\n      # update. +optional\n      maxUnavailable: 1\n\n      # The maximum number of pods that can be scheduled above the original\n      # number of pods. Value can be an absolute number (ex: 5) or a\n      # percentage of total pods at the start of the update (ex: 10%). This\n      # can not be 0 if MaxUnavailable is 0. Absolute number is calculated\n      # from percentage by rounding up. By default, a value of 1 is used.\n      # Example: when this is set to 30%, the new RC can be scaled up by 30%\n      # immediately when the rolling update starts. Once old pods have been\n      # killed, new RC can be scaled up further, ensuring that total number\n      # of pods running at any time during the update is at most 130% of\n      # original pods. +optional\n      maxSurge: \"20%\"\n\n      # Adds a delay before scaling down the previous ReplicaSet when the\n      # canary strategy is used with traffic routing (default 30 seconds).\n      # A delay in scaling down the previous ReplicaSet is needed after\n      # switching the stable service selector to point to the new ReplicaSet,\n      # in order to give time for traffic providers to re-target the new pods.\n      # This value is ignored with basic, replica-weighted canary without\n      # traffic routing.\n      scaleDownDelaySeconds: 30\n\n      # The minimum number of pods that will be requested for each ReplicaSet\n      # when using traffic routed canary. This is to ensure high availability\n      # of each ReplicaSet. Defaults to 1. +optional\n      minPodsPerReplicaSet: 2\n\n      # Limits the number of old RS that can run at one time before getting\n      # scaled down. Defaults to nil\n      scaleDownDelayRevisionLimit: 2\n\n      # Background analysis to run during a rollout update. Skipped upon\n      # initial deploy of a rollout. +optional\n      analysis:\n        templates:\n        - templateName: success-rate\n        args:\n        - name: service-name\n          value: guestbook-svc.default.svc.cluster.local\n\n        # valueFrom.podTemplateHashValue is a convenience to supply the\n        # rollouts-pod-template-hash value of either the Stable ReplicaSet\n        # or the Latest ReplicaSet\n        - name: stable-hash\n          valueFrom:\n            podTemplateHashValue: Stable\n        - name: latest-hash\n          valueFrom:\n            podTemplateHashValue: Latest\n\n        # valueFrom.fieldRef allows metadata about the rollout to be\n        # supplied as arguments to analysis.\n        - name: region\n          valueFrom:\n            fieldRef:\n              fieldPath: metadata.labels['region']\n\n      # Steps define sequence of steps to take during an update of the\n      # canary. Skipped upon initial deploy of a rollout. +optional\n      steps:\n\n      # Sets the ratio of canary ReplicaSet to 20%\n      - setWeight: 20\n\n      # Pauses the rollout for an hour. Supported units: s, m, h\n      - pause:\n          duration: 1h\n\n      # Pauses indefinitely until manually resumed\n      - pause: {}\n\n      # set canary scale to a explicit count without changing traffic weight\n      # (supported only with trafficRouting)\n      - setCanaryScale:\n          replicas: 3\n\n      # set canary scale to spec.Replica * (setweight / maxTrafficWeight) without changing traffic weight\n      # if maxTrafficWeight unspecified, it defaults to 100\n      # (supported only with trafficRouting)\n      - setCanaryScale:\n          weight: 25\n\n      # set canary scale to match the canary traffic weight (default behavior)\n      - setCanaryScale:\n          matchTrafficWeight: true\n\n      # Sets header based route with specified header values\n      # Setting header based route will send all traffic to the canary for the requests \n      # with a specified header, in this case request header \"version\":\"2\"\n      # (supported only with trafficRouting, for Istio only at the moment)\n      - setHeaderRoute:\n          # Name of the route that will be created by argo rollouts this must also be configured\n          # in spec.strategy.canary.trafficRouting.managedRoutes\n          name: \"header-route-1\"\n          # The matching rules for the header route, if this is missing it acts as a removal of the route.\n          match:\n              # headerName The name of the header to apply the match rules to.\n            - headerName: \"version\"\n              # headerValue must contain exactly one field of exact, regex, or prefix. Not all traffic routers support \n              # all types\n              headerValue:\n                # Exact will only match if the header value is exactly the same\n                exact: \"2\"\n                # Will match the rule if the regular expression matches\n                regex: \"2.0.(.*)\"\n                # prefix will be a prefix match of the header value\n                prefix: \"2.0\"\n\n        # Sets up a mirror/shadow based route with the specified match rules\n        # The traffic will be mirrored at the configured percentage to the canary service\n        # during the rollout\n        # (supported only with trafficRouting, for Istio only at the moment)\n      - setMirrorRoute:\n          # Name of the route that will be created by argo rollouts this must also be configured\n          # in spec.strategy.canary.trafficRouting.managedRoutes\n          name: \"header-route-1\"\n          # The percentage of the matched traffic to mirror to the canary\n          percentage: 100\n          # The matching rules for the header route, if this is missing it acts as a removal of the route.\n          # All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics.\n          # Each type within a match (method, path, headers) must have one and only one match type (exact, regex, prefix)\n          # Not all match types (exact, regex, prefix) will be supported by all traffic routers.\n          match:\n            - method: # What HTTP method to match\n                exact: \"GET\"\n                regex: \"P.*\"\n                prefix: \"POST\"\n              path: # What HTTP url paths to match.\n                exact: \"/test\"\n                regex: \"/test/.*\"\n                prefix: \"/\"\n              headers:\n                agent-1b: # What HTTP header name to use in the match.\n                  exact: \"firefox\"\n                  regex: \"firefox2(.*)\"\n                  prefix: \"firefox\"\n\n      # an inline analysis step\n      - analysis:\n          templates:\n          - templateName: success-rate\n\n      # an inline experiment step\n      - experiment:\n          duration: 1h\n          templates:\n          - name: baseline\n            specRef: stable\n            # optional, creates a service for the experiment if set\n            service:\n              # optional, service: {} is also acceptable if name is not included\n              name: test-service\n          - name: canary\n            specRef: canary\n            # optional, set the weight of traffic routed to this version\n            weight: 10\n          analyses:\n          - name : mann-whitney\n            templateName: mann-whitney\n            # Metadata which will be attached to the AnalysisRun.\n            analysisRunMetadata:\n              labels:\n                app.service.io/analysisType: smoke-test\n              annotations:\n                link.argocd.argoproj.io/external-link: http://my-loggin-platform.com/pre-generated-link\n\n      # Anti-affinity configuration between desired and previous ReplicaSet.\n      # Only one must be specified.\n      antiAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution: {}\n        preferredDuringSchedulingIgnoredDuringExecution:\n          weight: 1 # Between 1 - 100\n\n      # Traffic routing specifies the ingress controller or service mesh\n      # configuration to achieve advanced traffic splitting. If omitted,\n      # will achieve traffic split via a weighted replica counts between\n      # the canary and stable ReplicaSet.\n      trafficRouting:\n        # Supports nginx and plugins only: This lets you control the denominator or total weight of traffic.\n        # The total weight of traffic. If unspecified, it defaults to 100\n        maxTrafficWeight: 1000\n        # This is a list of routes that Argo Rollouts has the rights to manage it is currently only required for\n        # setMirrorRoute and setHeaderRoute. The order of managedRoutes array also sets the precedence of the route\n        # in the traffic router. Argo Rollouts will place these routes in the order specified above any routes already\n        # defined in the used traffic router if something exists. The names here must match the names from the \n        # setHeaderRoute and setMirrorRoute steps.\n        managedRoutes:\n          - name: set-header\n          - name: mirror-route\n        # Istio traffic routing configuration\n        istio:\n          # Either virtualService or virtualServices can be configured.\n          virtualService: \n            name: rollout-vsvc  # required\n            routes:\n            - primary # optional if there is a single route in VirtualService, required otherwise\n          virtualServices:\n          # One or more virtualServices can be configured\n          - name: rollouts-vsvc1  # required\n            routes:\n              - primary # optional if there is a single route in VirtualService, required otherwise\n          - name: rollouts-vsvc2  # required\n            routes:\n              - secondary # optional if there is a single route in VirtualService, required otherwise\n\n        # NGINX Ingress Controller routing configuration\n        nginx:\n          # Either stableIngress or stableIngresses must be configured, but not both.\n          stableIngress: primary-ingress\n          stableIngresses:\n            - primary-ingress\n            - secondary-ingress\n            - tertiary-ingress\n          annotationPrefix: customingress.nginx.ingress.kubernetes.io # optional\n          additionalIngressAnnotations:   # optional\n            canary-by-header: X-Canary\n            canary-by-header-value: iwantsit\n          canaryIngressAnnotations:   # optional\n            my-custom-annotation.mygroup.com/key: value\n\n        # ALB Ingress Controller routing configuration\n        alb:\n          ingress: ingress  # required\n          servicePort: 443  # required\n          annotationPrefix: custom.alb.ingress.kubernetes.io # optional\n\n        # Service Mesh Interface routing configuration\n        smi:\n          rootService: root-svc # optional\n          trafficSplitName: rollout-example-traffic-split # optional\n\n      # Add a delay in second before scaling down the canary pods when update\n      # is aborted for canary strategy with traffic routing (not applicable for basic canary).\n      # 0 means canary pods are not scaled down. Default is 30 seconds.\n      abortScaleDownDelaySeconds: 30\n\nstatus:\n  pauseConditions:\n  - reason: StepPause\n    startTime: 2019-10-00T1234\n  - reason: BlueGreenPause\n    startTime: 2019-10-00T1234\n  - reason: AnalysisRunInconclusive\n    startTime: 2019-10-00T1234 \n</code></pre>"},{"location":"features/specification/#examples","title":"Examples","text":"<p>You can find examples of Rollouts at:</p> <ul> <li>The example directory</li> <li>The Argo Rollouts Demo application</li> </ul>"},{"location":"features/vpa-support/","title":"Vertical Pod Autoscaling","text":"<p>Vertical Pod Autoscaling (VPA) reduces the maintenance cost and improve utilization of cluster resources by automating configuration of resource requirements.  </p>"},{"location":"features/vpa-support/#vpa-modes","title":"VPA modes","text":"<p>There are four modes in which VPAs operate  </p> <ol> <li> <p>\"Auto\": VPA assigns resource requests on pod creation as well as updates them on existing pods using the preferred update mechanism. Currently this is equivalent to \"Recreate\" (see below). Once restart free (\"in-place\") update of pod requests is available, it may be used as the preferred update mechanism by the \"Auto\" mode.  NOTE: This feature of VPA is experimental and may cause downtime for your applications.</p> </li> <li> <p>\"Recreate\": VPA assigns resource requests on pod creation as well as updates them on existing pods by evicting them when the requested resources differ significantly from the new recommendation (respecting the Pod Disruption Budget, if defined). This mode should be used rarely, only if you need to ensure that the pods are restarted whenever the resource request changes. Otherwise prefer the \"Auto\" mode which may take advantage of restart free updates once they are available.  NOTE: This feature of VPA is experimental and may cause downtime for your applications.</p> </li> <li> <p>\"Initial\": VPA only assigns resource requests on pod creation and never changes them later.  </p> </li> <li> <p>\"Off\": VPA does not automatically change resource requirements of the pods. The recommendations are calculated and can be inspected in the VPA object. </p> </li> </ol>"},{"location":"features/vpa-support/#example","title":"Example","text":"<p>Below is an example of a Vertical Pod Autoscaler with Argo-Rollouts.</p> <p>Rollout sample app:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: vpa-demo-rollout\n  namespace: test-vpa\nspec:\n  replicas: 5\n  strategy:\n    canary:\n      steps:\n      - setWeight: 20\n      - pause: {duration: 10}\n      - setWeight: 40\n      - pause: {duration: 10}\n      - setWeight: 60\n      - pause: {duration: 10}\n      - setWeight: 80\n      - pause: {duration: 10}\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: vpa-demo-rollout\n  template:\n    metadata:\n      labels:\n        app: vpa-demo-rollout\n    spec:\n      containers:\n      - name: vpa-demo-rollout\n        image: ravihari/nginx:v1\n        ports:\n        - containerPort: 80\n        resources:\n          requests:\n            cpu: \"5m\"       \n            memory: \"5Mi\" \n</code></pre> <p>VPA configuration for Rollout sample app:</p> <pre><code>apiVersion: \"autoscaling.k8s.io/v1beta2\"\nkind: VerticalPodAutoscaler  \nmetadata:  \n  name: vpa-rollout-example  \n  namespace: test-vpa  \nspec:  \n  targetRef:  \n    apiVersion: \"argoproj.io/v1alpha1\"  \n    kind: Rollout  \n    name: vpa-demo-rollout  \n  updatePolicy:  \n    updateMode: \"Auto\"  \n  resourcePolicy:  \n    containerPolicies:  \n    - containerName: '*'  \n    minAllowed:  \n      cpu: 5m  \n      memory: 5Mi  \n    maxAllowed:  \n      cpu: 1  \n      memory: 500Mi  \n    controlledResources: [\"cpu\", \"memory\"]  \n</code></pre> <p>Describe VPA when initially deployed we donot see recommendations as it will take few mins.</p> <pre><code>Name:         kubengix-vpa\nNamespace:    test-vpa\nLabels:       &lt;none&gt;\nAnnotations:  &lt;none&gt;\nAPI Version:  autoscaling.k8s.io/v1\nKind:         VerticalPodAutoscaler\nMetadata:\n  Creation Timestamp:  2022-03-14T12:54:06Z\n  Generation:          1\n  Managed Fields:\n    API Version:  autoscaling.k8s.io/v1beta2\n    Fields Type:  FieldsV1\n    fieldsV1:\n      f:metadata:\n        f:annotations:\n          .:\n          f:kubectl.kubernetes.io/last-applied-configuration:\n      f:spec:\n        .:\n        f:resourcePolicy:\n          .:\n          f:containerPolicies:\n        f:targetRef:\n          .:\n          f:apiVersion:\n          f:kind:\n          f:name:\n        f:updatePolicy:\n          .:\n          f:updateMode:\n    Manager:         kubectl-client-side-apply\n    Operation:       Update\n    Time:            2022-03-14T12:54:06Z\n  Resource Version:  3886\n  UID:               4ac64e4c-c84b-478e-92e4-5f072f985971\nSpec:\n  Resource Policy:\n    Container Policies:\n      Container Name:  *\n      Controlled Resources:\n        cpu\n        memory\n      Max Allowed:\n        Cpu:     1\n        Memory:  500Mi\n      Min Allowed:\n        Cpu:     5m\n        Memory:  5Mi\n  Target Ref:\n    API Version:  argoproj.io/v1alpha1\n    Kind:         Rollout\n    Name:         vpa-demo-rollout\n  Update Policy:\n    Update Mode:  Auto\nEvents:           &lt;none&gt;\n</code></pre> <p>After few minutes when VPA starts to process and provide recommendation:</p> <pre><code>Name:         kubengix-vpa\nNamespace:    test-vpa\nLabels:       &lt;none&gt;\nAnnotations:  &lt;none&gt;\nAPI Version:  autoscaling.k8s.io/v1\nKind:         VerticalPodAutoscaler\nMetadata:\n  Creation Timestamp:  2022-03-14T12:54:06Z\n  Generation:          2\n  Managed Fields:\n    API Version:  autoscaling.k8s.io/v1beta2\n    Fields Type:  FieldsV1\n    fieldsV1:\n      f:metadata:\n        f:annotations:\n          .:\n          f:kubectl.kubernetes.io/last-applied-configuration:\n      f:spec:\n        .:\n        f:resourcePolicy:\n          .:\n          f:containerPolicies:\n        f:targetRef:\n          .:\n          f:apiVersion:\n          f:kind:\n          f:name:\n        f:updatePolicy:\n          .:\n          f:updateMode:\n    Manager:      kubectl-client-side-apply\n    Operation:    Update\n    Time:         2022-03-14T12:54:06Z\n    API Version:  autoscaling.k8s.io/v1\n    Fields Type:  FieldsV1\n    fieldsV1:\n      f:status:\n        .:\n        f:conditions:\n        f:recommendation:\n          .:\n          f:containerRecommendations:\n    Manager:         recommender\n    Operation:       Update\n    Time:            2022-03-14T12:54:52Z\n  Resource Version:  3950\n  UID:               4ac64e4c-c84b-478e-92e4-5f072f985971\nSpec:\n  Resource Policy:\n    Container Policies:\n      Container Name:  *\n      Controlled Resources:\n        cpu\n        memory\n      Max Allowed:\n        Cpu:     1\n        Memory:  500Mi\n      Min Allowed:\n        Cpu:     5m\n        Memory:  5Mi\n  Target Ref:\n    API Version:  argoproj.io/v1alpha1\n    Kind:         Rollout\n    Name:         vpa-demo-rollout\n  Update Policy:\n    Update Mode:  Auto\nStatus:\n  Conditions:\n    Last Transition Time:  2022-03-14T12:54:52Z\n    Status:                True\n    Type:                  RecommendationProvided\n  Recommendation:\n    Container Recommendations:\n      Container Name:  vpa-demo-rollout\n      Lower Bound:\n        Cpu:     25m\n        Memory:  262144k\n      Target:\n        Cpu:     25m\n        Memory:  262144k\n      Uncapped Target:\n        Cpu:     25m\n        Memory:  262144k\n      Upper Bound:\n        Cpu:     1\n        Memory:  500Mi\nEvents:          &lt;none&gt;\n</code></pre> <p>Here we see the recommendation for cpu, memory with lowerbound, upper bound, Target etc., are provided. If we check the status of the pods.. the older pods with initial configuration would get terminated and newer pods get created.</p> <pre><code># kubectl get po -n test-vpa -w   \nNAME                               READY   STATUS    RESTARTS   AGE\nvpa-demo-rollout-f5df6d577-65f26   1/1     Running   0          17m\nvpa-demo-rollout-f5df6d577-d55cx   1/1     Running   0          17m\nvpa-demo-rollout-f5df6d577-fdpn2   1/1     Running   0          17m\nvpa-demo-rollout-f5df6d577-jg2pw   1/1     Running   0          17m\nvpa-demo-rollout-f5df6d577-vlx5x   1/1     Running   0          17m\n...\n\nvpa-demo-rollout-f5df6d577-jg2pw   1/1     Terminating   0          17m\nvpa-demo-rollout-f5df6d577-vlx5x   1/1     Terminating   0          17m\nvpa-demo-rollout-f5df6d577-jg2pw   0/1     Terminating   0          18m\nvpa-demo-rollout-f5df6d577-vlx5x   0/1     Terminating   0          18m\nvpa-demo-rollout-f5df6d577-w7tx4   0/1     Pending       0          0s\nvpa-demo-rollout-f5df6d577-w7tx4   0/1     Pending       0          0s\nvpa-demo-rollout-f5df6d577-w7tx4   0/1     ContainerCreating   0          0s\nvpa-demo-rollout-f5df6d577-vdlqq   0/1     Pending             0          0s\nvpa-demo-rollout-f5df6d577-vdlqq   0/1     Pending             0          1s\nvpa-demo-rollout-f5df6d577-jg2pw   0/1     Terminating         0          18m\nvpa-demo-rollout-f5df6d577-jg2pw   0/1     Terminating         0          18m\nvpa-demo-rollout-f5df6d577-vdlqq   0/1     ContainerCreating   0          1s\nvpa-demo-rollout-f5df6d577-w7tx4   1/1     Running             0          6s\nvpa-demo-rollout-f5df6d577-vdlqq   1/1     Running             0          7s\nvpa-demo-rollout-f5df6d577-vlx5x   0/1     Terminating         0          18m\nvpa-demo-rollout-f5df6d577-vlx5x   0/1     Terminating         0          18m\n</code></pre> <p>If we check the new pod cpu and memory they would be updated as per VPA recommendation:</p> <pre><code># kubectl describe po vpa-demo-rollout-f5df6d577-vdlqq -n test-vpa\nName:         vpa-demo-rollout-f5df6d577-vdlqq\nNamespace:    test-vpa\nPriority:     0\nNode:         argo-rollouts-control-plane/172.18.0.2\nStart Time:   Mon, 14 Mar 2022 12:55:06 +0000\nLabels:       app=vpa-demo-rollout\n              rollouts-pod-template-hash=f5df6d577\nAnnotations:  vpaObservedContainers: vpa-demo-rollout\n              vpaUpdates: Pod resources updated by kubengix-vpa: container 0: cpu request, memory request\nStatus:       Running\nIP:           10.244.0.17\nIPs:\n  IP:           10.244.0.17\nControlled By:  ReplicaSet/vpa-demo-rollout-f5df6d577\nContainers:\n  vpa-demo-rollout:\n    Container ID:   containerd://b79bd88851fe0622d33bc90a1560ca54ef2c27405a3bc9a4fc3a333eef5f9733\n    Image:          ravihari/nginx:v1\n    Image ID:       docker.io/ravihari/nginx@sha256:205961b09a80476af4c2379841bf6abec0022101a7e6c5585a88316f7115d17a\n    Port:           80/TCP\n    Host Port:      0/TCP\n    State:          Running\n      Started:      Mon, 14 Mar 2022 12:55:11 +0000\n    Ready:          True\n    Restart Count:  0\n    Requests:\n      cpu:        25m\n      memory:     262144k\n    Environment:  &lt;none&gt;\n    Mounts:\n      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-mk4fz (ro)\nConditions:\n  Type              Status\n  Initialized       True \n  Ready             True \n  ContainersReady   True \n  PodScheduled      True \nVolumes:\n  kube-api-access-mk4fz:\n    Type:                    Projected (a volume that contains injected data from multiple sources)\n    TokenExpirationSeconds:  3607\n    ConfigMapName:           kube-root-ca.crt\n    ConfigMapOptional:       &lt;nil&gt;\n    DownwardAPI:             true\nQoS Class:                   Burstable\nNode-Selectors:              &lt;none&gt;\nTolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s\n                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s\nEvents:\n  Type    Reason     Age   From               Message\n  ----    ------     ----  ----               -------\n  Normal  Scheduled  38s   default-scheduler  Successfully assigned test-vpa/vpa-demo-rollout-f5df6d577-vdlqq to argo-rollouts-control-plane\n  Normal  Pulled     35s   kubelet            Container image \"ravihari/nginx:v1\" already present on machine\n  Normal  Created    35s   kubelet            Created container vpa-demo-rollout\n  Normal  Started    33s   kubelet            Started container vpa-demo-rollout\n</code></pre>"},{"location":"features/vpa-support/#requirements","title":"Requirements","text":"<p>In order for the VPA to manipulate the rollout, the Kubernetes cluster hosting the rollout CRD needs the subresources support for CRDs.  This feature was introduced as alpha in Kubernetes version 1.10 and transitioned to beta in Kubernetes version 1.11.  If a user wants to use VPA on v1.10, the Kubernetes Cluster operator will need to add a custom feature flag to the API server.  After 1.10, the flag is turned on by default.  Check out the following link for more information on setting the custom feature flag.</p> <p>When installing VPA you may need to add the following in RBAC configurations for <code>system:vpa-target-reader</code> cluster role as by default VPA maynot support rollouts in all the versions.</p> <pre><code>  - apiGroups:\n      - argoproj.io\n    resources:\n      - rollouts\n      - rollouts/scale\n      - rollouts/status\n      - replicasets\n    verbs:\n      - get\n      - list\n      - watch\n</code></pre> <p>Makes sure Metrics-Server is installed in the cluster and openssl is upto date for VPA latest version to apply recommendations to the pods properly. </p>"},{"location":"features/anti-affinity/anti-affinity/","title":"Anti Affinity","text":""},{"location":"features/anti-affinity/anti-affinity/#background","title":"Background","text":"<p>Depending on a cluster's configuration, a Blue Green Rollout (or a Canary rollout that uses traffic management) can cause newly created pods to restart after deploying a new version. This can be problematic, especially for applications that cannot startup quickly or do not gracefully exit.</p> <p>This behavior occurs because cluster auto-scaler wants to scale down the extra capacity which was created to support a Rollout running in double capacity. When a node is scaled down, the pods it owns are deleted and recreated. This usually happens if a Rollout has its own dedicated instance group since a Rollout has a greater effect on cluster auto-scaling. Therefore, clusters with a large pool of shared nodes experience the behavior less often.</p> <p>For example, here is a Rollout is running with 8 pods spread across 2 nodes. Each node can hold 6 pods: </p> <p>When the <code>spec.template</code> of the Rollout changes, the controller creates a new ReplicaSet with the spec update and the total number of pods doubles. In this case, the number of pods increases to 16.</p> <p>Since each node can only hold 6 pods, the cluster autoscaler must increase the node count to 3 to accommodate all 16 pods. The resulting distribution of pods across nodes is shown here: </p> <p>Once the Rollout finishes progressing, the old version is scaled down. This leaves the cluster with more nodes than necessary, thus wasting resources (as shown below). </p> <p>The cluster auto-scaler terminates the extra node and the pods are rescheduled on the remaining 2 nodes. </p> <p>To reduce the chance of this behavior, a rollout can inject anti-affinity into the ReplicaSet. This prevents new pods from running on nodes which have the previous version's pods.</p> <p>You can learn more about anti-affinity here.</p> <p>Repeating the above example with anti-affinity enabled, here is what happens when the <code>.spec.template</code> of the Rollout changes. Due to anti-affinity, the new pods cannot be scheduled on nodes which run the old ReplicaSet's pods. As a result, the cluster auto-scaler must create 2 nodes to host the new ReplicaSet's pods. In this case, pods won't be started since the scaled-down nodes are guaranteed to not have the new pods.</p> <p></p>"},{"location":"features/anti-affinity/anti-affinity/#enabling-anti-affinity-in-rollouts","title":"Enabling Anti-Affinity in Rollouts","text":"<p>Anti-affinity is enabled by adding the anti-affinity struct to the Blue-Green or Canary strategy. When the anti-affinity struct is set, controller injects a PodAntiAffinity struct into the ReplicaSet's Affinity. This feature will not modify any of the ReplicaSet's pre-existing affinity rules. </p> <p>Users have a choice between these scheduling rules: <code>RequiredDuringSchedulingIgnoredDuringExecution</code> and <code>PreferredDuringSchedulingIgnoredDuringExecution</code>.</p> <p><code>RequiredDuringSchedulingIgnoredDuringExecution</code> requires a new version's pods to be on a separate node than the previous versions. If this is not possible, the the new version's pods will not be scheduled.</p> <pre><code>strategy:\n    bluegreen:\n      antiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution: {}\n</code></pre> <p>Unlike the Required strategy, <code>PreferredDuringSchedulingIgnoredDuringExecution</code> does not force a new version's pods to be on a separate node than the previous versions. The scheduler attempts to place the new version's pods on separate node(s). If that's not possible, the new version's pods will still be scheduled. The <code>Weight</code> is used to create a priority order for preferred anti-affinity rules. </p> <pre><code>strategy:\n    canary:\n      antiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n            weight: 1 # Between 1 - 100\n</code></pre> <p>Important</p> <p>The main downside to this approach is that deployments can take longer because new nodes are more likely to be created in order to schedule pods with respect to anti-affinity rules. This delay most frequently occurs when a rollout has its own dedicated instance group, since new nodes are more likely to be created to honor anti-affinity rules.</p>"},{"location":"features/traffic-management/","title":"Traffic management","text":"<p>Traffic management is controlling the data plane to have intelligent routing rules for an application. These routing rules can manipulate the flow of traffic to different versions of an application enabling Progressive Delivery. These controls limit the blast radius of a new release by ensuring a small percentage of users receive a new version while it is verified.</p> <p>There are various techniques to achieve traffic management:</p> <ul> <li>Raw percentages (i.e., 5% of traffic should go to the new version while the rest goes to the stable version)</li> <li>Header-based routing (i.e., send requests with a specific header to the new version)</li> <li>Mirrored traffic where all the traffic is copied and send to the new version in parallel (but the response is ignored)</li> </ul>"},{"location":"features/traffic-management/#traffic-management-tools-in-kubernetes","title":"Traffic Management tools in Kubernetes","text":"<p>The core Kubernetes objects do not have fine-grained tools needed to fulfill all the requirements of traffic management. At most, Kubernetes offers native load balancing capabilities through the Service object by offering an endpoint that routes traffic to a grouping of pods based on that Service's selector. Functionality like traffic mirroring or routing by headers is not possible with the default core Service object, and the only way to control the percentage of traffic to different versions of an application is by manipulating replica counts of those versions. </p> <p>Service Meshes fill this missing functionality in Kubernetes. They introduce new concepts and functionality to control the data plane through the use of CRDs and other core Kubernetes resources. </p>"},{"location":"features/traffic-management/#how-does-argo-rollouts-enable-traffic-management","title":"How does Argo Rollouts enable traffic management?","text":"<p>Argo Rollouts enables traffic management by manipulating the Service Mesh resources to match the intent of the Rollout. Argo Rollouts currently supports the following traffic providers:</p> <ul> <li>AWS ALB Ingress Controller</li> <li>Ambassador Edge Stack</li> <li>Apache APISIX</li> <li>Google Cloud</li> <li>Gateway API</li> <li>Istio</li> <li>Kong Ingress</li> <li>Nginx Ingress Controller</li> <li>Service Mesh Interface (SMI)</li> <li>Traefik Proxy</li> <li>Multiple Providers</li> <li>File a ticket here if you would like another implementation (or thumbs up it if that issue already exists)</li> </ul> <p>Regardless of the Service Mesh used, the Rollout object has to set a canary Service and a stable Service in its spec. Here is an example with those fields set: <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nspec:\n  ...\n  strategy:\n    canary:\n      canaryService: canary-service\n      stableService: stable-service\n      trafficRouting:\n       ...\n</code></pre></p> <p>The controller modifies these Services to route traffic to the appropriate canary and stable ReplicaSets as the Rollout progresses. These Services are used by the Service Mesh to define what group of pods should receive the canary and stable traffic.</p> <p>Additionally, the Argo Rollouts controller needs to treat the Rollout object differently when using traffic management. In particular, the Stable ReplicaSet owned by the Rollout remains fully scaled up as the Rollout progresses through the Canary steps.</p> <p>Since the traffic is controlled independently by the Service Mesh resources, the controller needs to make a best effort to ensure that the Stable and New ReplicaSets are not overwhelmed by the traffic sent to them. By leaving the Stable ReplicaSet scaled up, the controller is ensuring that the Stable ReplicaSet can handle 100% of the traffic at any time<sup>1</sup>. The New ReplicaSet follows the same behavior as without traffic management. The new ReplicaSet's replica count is equal to the latest SetWeight step percentage multiple by the total replica count of the Rollout. This calculation ensures that the canary version does not receive more traffic than it can handle.</p>"},{"location":"features/traffic-management/#traffic-routing-with-managed-routes-and-route-precedence","title":"Traffic routing with managed routes and route precedence","text":""},{"location":"features/traffic-management/#traffic-router-support-istio","title":"Traffic router support: (Istio)","text":"<p>When traffic routing is enabled, you have the ability to also let argo rollouts add and manage other routes besides just controlling the traffic weight to the canary. Two such routing rules are header and mirror based routes. When using these routes we also have to set a route precedence with the upstream traffic router. We do this using the <code>spec.strategy.canary.trafficRouting.managedRoutes</code> field which is an array the order of the items in the array determine the precedence. This set of routes will also be placed in the order specified on top of any other routes defined manually. </p> <p>Warning</p> <p>All routes listed in managed routes will be removed at the end of a rollout or on an abort. Do not put any manually created routes in the list.</p> <p>Here is an example:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nspec:\n  ...\n  strategy:\n    canary:\n      ...\n      trafficRouting:\n        managedRoutes:\n          - name: priority-route-1\n          - name: priority-route-2\n          - name: priority-route-3\n</code></pre>"},{"location":"features/traffic-management/#traffic-routing-based-on-a-header-values-for-canary","title":"Traffic routing based on a header values for Canary","text":""},{"location":"features/traffic-management/#traffic-router-support-istio_1","title":"Traffic router support: (Istio)","text":"<p>Argo Rollouts has ability to send all traffic to the canary-service based on a http request header value. The step for the header based traffic routing is <code>setHeaderRoute</code> and has a list of matchers for the header. </p> <p><code>name</code> - name of the header route.</p> <p><code>match</code> - header matching rules is an array of <code>headerName, headerValue</code> pairs.</p> <p><code>headerName</code> - name of the header to match.</p> <p><code>headerValue</code>-  contains exactly one of <code>exact</code> - specify the exact header value,  <code>regex</code> - value in a regex format, <code>prefix</code> - the prefix of the value could be provided. Not all traffic routers will support all match types.</p> <p>To disable header based traffic routing just need to specify empty <code>setHeaderRoute</code> with only the name of the route.</p> <p>Example:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nspec:\n  ...\n  strategy:\n    canary:\n      canaryService: canary-service\n      stableService: stable-service\n      trafficRouting:\n        managedRoutes:\n          - name: set-header-1\n        istio:\n          virtualService:\n            name: rollouts-demo-vsvc\n      steps:\n      - setWeight: 20\n      - setHeaderRoute: # enable header based traffic routing where\n          name: \"set-header-1\"\n          match:\n          - headerName: Custom-Header1 # Custom-Header1=Mozilla\n            headerValue:\n              exact: Mozilla\n          - headerName: Custom-Header2 # or Custom-Header2 has a prefix Mozilla\n            headerValue:\n              prefix: Mozilla\n          - headerName: Custom-Header3 # or Custom-Header3 value match regex: Mozilla(.*)\n            headerValue:\n              regex: Mozilla(.*)\n      - pause: {}\n      - setHeaderRoute:\n          name: \"set-header-1\" # disable header based traffic routing\n</code></pre>"},{"location":"features/traffic-management/#traffic-routing-mirroring-traffic-to-canary","title":"Traffic routing mirroring traffic to canary","text":""},{"location":"features/traffic-management/#traffic-router-support-istio_2","title":"Traffic router support: (Istio)","text":"<p>Argo Rollouts has ability to mirror traffic to the canary-service based on a various matching rules. The step for the mirror based traffic routing is <code>setMirrorRoute</code> and has a list of matchers for the header.</p> <p><code>name</code> - name of the mirror route.</p> <p><code>percentage</code> - what percentage of the matched traffic to mirror</p> <p><code>match</code> - The matching rules for the header route, if this is missing it acts as a removal of the route. All conditions inside a single match block have AND semantics, while the list of match blocks have OR semantics. Each type within a match (method, path, headers) must have one and only one match type (exact, regex, prefix) Not all match types (exact, regex, prefix) will be supported by all traffic routers.</p> <p>To disable mirror based traffic route you just need to specify a <code>setMirrorRoute</code> with only the name of the route.</p> <p>This example will mirror 35% of HTTP traffic that matches a <code>GET</code> requests and with the url prefix of <code>/</code> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nspec:\n  ...\n  strategy:\n    canary:\n      canaryService: canary-service\n      stableService: stable-service\n      trafficRouting:\n        managedRoutes:\n          - name: mirror-route\n        istio:\n          virtualService:\n            name: rollouts-demo-vsvc\n      steps:\n        - setCanaryScale:\n            weight: 25\n      - setMirrorRoute:\n          name: mirror-route\n          percentage: 35\n          match:\n            - method:\n                exact: GET\n              path:\n                prefix: /\n      - pause:\n          duration: 10m\n      - setMirrorRoute:\n          name: \"mirror-route\" # removes mirror based traffic route\n</code></pre></p> <ol> <li> <p>The Rollout has to assume that the application can handle 100% of traffic if it is fully scaled up. It should outsource to the HPA to detect if the Rollout needs to more replicas if 100% isn't enough.\u00a0\u21a9</p> </li> </ol>"},{"location":"features/traffic-management/alb/","title":"AWS Load Balancer Controller (ALB)","text":""},{"location":"features/traffic-management/alb/#requirements","title":"Requirements","text":"<ul> <li>AWS Load Balancer Controller v1.1.5 or greater</li> </ul>"},{"location":"features/traffic-management/alb/#overview","title":"Overview","text":"<p>AWS Load Balancer Controller (also known as AWS ALB Ingress Controller) enables traffic management through an Ingress object, which configures an AWS Application Load Balancer (ALB) to route traffic to one or more Kubernetes services. ALBs provides advanced traffic splitting capability through the concept of weighted target groups. This feature is supported by the AWS Load Balancer Controller through annotations made to the Ingress object to configure \"actions.\"</p>"},{"location":"features/traffic-management/alb/#how-it-works","title":"How it works","text":"<p>ALBs are configured via Listeners, and Rules which contain Actions. Listeners define how traffic from a client comes in, and Rules define how to handle those requests with various Actions. One type of Action allows users to forward traffic to multiple TargetGroups (with each being defined as a Kubernetes service). You can read more about ALB concepts here.</p> <p>An Ingress which is managed by the AWS Load Balancer Controller, controls an ALB's Listener and Rules through the Ingress' annotations and spec. In order to split traffic among multiple target groups (e.g. different Kubernetes services), the AWS Load Balancer controller looks to a specific \"action\" annotation on the Ingress, <code>alb.ingress.kubernetes.io/actions.&lt;service-name&gt;</code>. This annotation is injected and updated automatically by a Rollout during an update according to the desired traffic weights.</p>"},{"location":"features/traffic-management/alb/#usage","title":"Usage","text":"<p>To configure a Rollout to use the ALB integration and split traffic between the canary and stable services during updates, the Rollout should be configured with the following fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\n...\nspec:\n  strategy:\n    canary:\n      # canaryService and stableService are references to Services which the Rollout will modify\n      # to target the canary ReplicaSet and stable ReplicaSet respectively (required).\n      canaryService: canary-service\n      stableService: stable-service\n      trafficRouting:\n        alb:\n          # The referenced ingress will be injected with a custom action annotation, directing\n          # the AWS Load Balancer Controller to split traffic between the canary and stable\n          # Service, according to the desired traffic weight (required).\n          ingress: ingress\n          # If you want to controll multiple ingress resources you can use the ingresses field, if ingresses is specified\n          # the ingress field will need to be omitted.\n          ingresses:\n           - ingress-1\n           - ingress-2\n          # Reference to a Service that the Ingress must target in one of the rules (optional).\n          # If omitted, uses canary.stableService.\n          rootService: root-service\n          # Service port is the port which the Service listens on (required).\n          servicePort: 443\n</code></pre> <p>The referenced Ingress should be deployed with an ingress rule that matches the Rollout service:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress\n  annotations:\n    kubernetes.io/ingress.class: alb\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            # serviceName must match either: canary.trafficRouting.alb.rootService (if specified),\n            # or canary.stableService (if rootService is omitted)\n            name: root-service\n            # servicePort must be the value: use-annotation\n            # This instructs AWS Load Balancer Controller to look to annotations on how to direct traffic\n            port:\n              name: use-annotation\n</code></pre> <p>During an update, the rollout controller injects the <code>alb.ingress.kubernetes.io/actions.&lt;SERVICE-NAME&gt;</code> annotation, containing a JSON payload understood by the AWS Load Balancer Controller, directing it to split traffic between the <code>canaryService</code> and <code>stableService</code> according to the current canary weight.</p> <p>The following is an example of our example Ingress after the rollout has injected the custom action annotation that splits traffic between the canary-service and stable-service, with a traffic weight of 10 and 90 respectively:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress\n  annotations:\n    kubernetes.io/ingress.class: alb\n    alb.ingress.kubernetes.io/actions.root-service: |\n      {\n        \"Type\":\"forward\",\n        \"ForwardConfig\":{\n          \"TargetGroups\":[\n            {\n                \"Weight\":10,\n                \"ServiceName\":\"canary-service\",\n                \"ServicePort\":\"80\"\n            },\n            {\n                \"Weight\":90,\n                \"ServiceName\":\"stable-service\",\n                \"ServicePort\":\"80\"\n            }\n          ]\n        }\n      }\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: root-service\n            port:\n              name: use-annotation\n</code></pre> <p>Note</p> <p>Argo rollouts additionally injects an annotation, <code>rollouts.argoproj.io/managed-alb-actions</code>, to the Ingress for bookkeeping purposes. The annotation indicates which actions are being managed by the Rollout object (since multiple Rollouts can reference one Ingress). Upon a rollout deletion, the rollout controller looks to this annotation to understand that this action is no longer managed, and is reset to point only the stable service with 100 weight.</p>"},{"location":"features/traffic-management/alb/#rootservice","title":"rootService","text":"<p>By default, a rollout will inject the <code>alb.ingress.kubernetes.io/actions.&lt;SERVICE-NAME&gt;</code> annotation using the service/action name specified under <code>spec.strategy.canary.stableService</code>. However, it may be desirable to specify an explicit service/action name different from the <code>stableService</code>. For example, one pattern is to use a single Ingress containing three different rules to reach the canary, stable, and root service separately (e.g. for testing purposes). In this case, you may want to specify a \"root\" service as the service/action name instead of stable. To do so, reference a service under <code>rootService</code> under the alb specification:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nspec:\n  strategy:\n    canary:\n      canaryService: guestbook-canary\n      stableService: guestbook-stable\n      trafficRouting:\n        alb:\n          rootService: guestbook-root\n...\n</code></pre>"},{"location":"features/traffic-management/alb/#sticky-session","title":"Sticky session","text":"<p>Because at least two target groups (canary and stable) are used, target group stickiness requires additional configuration: Sticky session must be activated on the target group via</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nspec:\n  strategy:\n    canary:\n...\n      trafficRouting:\n        alb:\n          stickinessConfig:\n            enabled: true\n            durationSeconds: 3600\n...\n</code></pre> <p>More information can be found in the AWS ALB API</p>"},{"location":"features/traffic-management/alb/#zero-downtime-updates-with-aws-targetgroup-verification","title":"Zero-Downtime Updates with AWS TargetGroup Verification","text":"<p>Argo Rollouts contains two features to help ensure zero-downtime updates when used with the AWS LoadBalancer controller: TargetGroup IP verification and TargetGroup weight verification. Both features involve the Rollout controller performing additional safety checks to AWS, to verify the changes made to the Ingress object are reflected in the underlying AWS TargetGroup.</p>"},{"location":"features/traffic-management/alb/#targetgroup-ip-verification","title":"TargetGroup IP Verification","text":"<p>Note</p> <p>Target Group IP verification available since Argo Rollouts v1.1</p> <p>The AWS LoadBalancer controller can run in one of two modes:</p> <ul> <li>Instance mode</li> <li>IP mode</li> </ul> <p>TargetGroup IP Verification is only applicable when the AWS LoadBalancer controller in IP mode. When using the AWS LoadBalancer controller in IP mode (e.g. using the AWS CNI), the ALB LoadBalancer targets individual Pod IPs, as opposed to K8s node instances. Targeting Pod IPs comes with an increased risk of downtime during an update, because the Pod IPs behind the underlying AWS TargetGroup can more easily become outdated from the actual availability and status of pods, causing HTTP 502 errors when the TargetGroup points to pods which have already been scaled down.</p> <p>To mitigate this risk, AWS recommends the use of pod readiness gate injection when running the AWS LoadBalancer in IP mode. Readiness gates allow for the AWS LoadBalancer controller to verify that TargetGroups are accurate before marking newly created Pods as \"ready\", preventing premature scale down of the older ReplicaSet.</p> <p>Pod readiness gate injection uses a mutating webhook which decides to inject readiness gates when a pod is created based on the following conditions:</p> <ul> <li>There exists a service matching the pod labels in the same namespace</li> <li>There exists at least one target group binding that refers to the matching service</li> </ul> <p>Another way to describe this is: the AWS LoadBalancer controller injects readiness gates onto Pods only if they are \"reachable\"  from an ALB Ingress at the time of pod creation. A pod is considered reachable if an (ALB) Ingress references a Service which matches the pod labels. It ignores all other Pods.</p> <p>One challenge with this manner of pod readiness gate injection, is that modifications to the Service selector labels (<code>spec.selector</code>) do not allow for the AWS LoadBalancer controller to inject the readiness gates, because by that time the Pod was already created (and readiness gates are immutable). Note that this is an issue when you change Service selectors of any ALB Service, not just ones involved in Argo Rollouts.</p> <p>Because Argo Rollout's blue-green strategy works by modifying the activeService selector to the new ReplicaSet labels during promotion, it suffers from the issue where readiness gates for the <code>spec.strategy.blueGreen.activeService</code> fail to be injected. This means there is a possibility of downtime in the following problematic scenario during an update from V1 to V2:</p> <ol> <li>Update is triggered and V2 ReplicaSet stack is scaled up</li> <li>V2 ReplicaSet pods become fully available and ready to be promoted</li> <li>Rollout promotes V2 by updating the label selectors of the active service to point to the V2 stack (from V1)</li> <li>Due to unknown issues (e.g. AWS load balancer controller downtime, AWS rate limiting), registration    of the V2 Pod IPs to the TargetGroup does not happen or is delayed.</li> <li>V1 ReplicaSet is scaled down to complete the update</li> </ol> <p>After step 5, when the V1 ReplicaSet is scaled down, the outdated TargetGroup would still be pointing to the V1 Pods IPs which no longer exist, causing downtime.</p> <p>To allow for zero-downtime updates, Argo Rollouts has the ability to perform TargetGroup IP verification as an additional safety measure during an update. When this feature is enabled, whenever a service selector modification is made, the Rollout controller blocks progression of the update until it can verify the TargetGroup is accurately targeting the new Pod IPs of the <code>bluegreen.activeService</code>. Verification is achieved by querying AWS APIs to describe the underlying TargetGroup, iterating its registered IPs, and ensuring all Pod IPs of the activeService's <code>Endpoints</code> list are registered in the TargetGroup. Verification must succeed before running postPromotionAnalysis or scaling down the old ReplicaSet.</p> <p>Similarly for the canary strategy, after updating the <code>canary.stableService</code> selector labels to point to the new ReplicaSet, the TargetGroup IP verification feature allows the controller to block the scale down of the old ReplicaSet until it verifies the Pods IP behind the stableService TargetGroup are accurate.</p>"},{"location":"features/traffic-management/alb/#targetgroup-weight-verification","title":"TargetGroup Weight Verification","text":"<p>Note</p> <p>TargetGroup weight verification available since Argo Rollouts v1.0</p> <p>TargetGroup weight verification addresses a similar problem to TargetGroup IP verification, but instead of verifying that the Pod IPs of a service are reflected accurately in the TargetGroup, the controller verifies that the traffic weights are accurate from what was set in the ingress annotations. Weight verification is applicable to AWS LoadBalancer controllers which are running either in IP mode or Instance mode.</p> <p>After Argo Rollouts adjusts a canary weight by updating the Ingress annotation, it moves on to the next step. However, due to external factors (e.g. AWS rate limiting, AWS load balancer controller downtime) it is possible that the weight modifications made to the Ingress, did not take effect in the underlying TargetGroup. This is potentially dangerous as the controller will believe it is safe to scale down the old stable stack when in reality, the outdated TargetGroup may still be pointing to it.</p> <p>Using the TargetGroup weight verification feature, the rollout controller will additionally verify the canary weight after a <code>setWeight</code> canary step. It accomplishes this by querying AWS LoadBalancer APIs directly, to confirm that the Rules, Actions, and TargetGroups reflect the desire of Ingress annotation.</p>"},{"location":"features/traffic-management/alb/#usage_1","title":"Usage","text":"<p>To enable AWS target group verification, add <code>--aws-verify-target-group</code> flag to the rollout-controller flags:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: argo-rollouts\nspec:\n  template:\n    spec:\n      containers:\n      - name: argo-rollouts\n        args: [--aws-verify-target-group]\n        # NOTE: in v1.0, the --alb-verify-weight flag should be used instead\n</code></pre> <p>For this feature to work, the argo-rollouts deployment requires the following AWS API permissions under the Elastic Load Balancing API:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Action\": [\n                \"elasticloadbalancing:DescribeTargetGroups\",\n                \"elasticloadbalancing:DescribeLoadBalancers\",\n                \"elasticloadbalancing:DescribeListeners\",\n                \"elasticloadbalancing:DescribeRules\",\n                \"elasticloadbalancing:DescribeTags\",\n                \"elasticloadbalancing:DescribeTargetHealth\"\n            ],\n            \"Resource\": \"*\",\n            \"Effect\": \"Allow\"\n        }\n    ]\n}\n</code></pre> <p>There are various ways of granting AWS privileges to the argo-rollouts pods, which is highly dependent to your cluster's AWS environment, and out-of-scope of this documentation. Some solutions include:</p> <ul> <li>AWS access and secret keys</li> <li>kiam</li> <li>kube2iam</li> <li>EKS ServiceAccount IAM Roles</li> </ul>"},{"location":"features/traffic-management/alb/#zero-downtime-updates-with-ping-pong-feature","title":"Zero-Downtime Updates with Ping-Pong feature","text":"<p>Above there was described the recommended way by AWS to solve zero-downtime issue. Is a use a pod readiness gate injection when running the AWS LoadBalancer in IP mode. There is a challenge with that approach, modifications of the Service selector labels (<code>spec.selector</code>) not allowed the AWS LoadBalancer controller to mutate the readiness gates. And Ping-Pong feature helps to deal with that challenge. At some particular moment one of the services (e.g. ping) is \"wearing a hat\" of stable service another one (e.g. pong) is \"wearing a hat\" of canary. At the end of the promotion step all 100% of traffic sending to the \"canary\" (e.g. pong). And then the Rollout swapped the hats of ping and pong services so the pong became a stable one. The Rollout status object holds the value of who is currently the stable ping or pong (<code>status.canary.currentPingPong</code>). And this way allows the rollout to use pod readiness gate injection as the services are not changing their labels at the end of the rollout progress.</p> <p>Important</p> <p>Ping-Pong feature available since Argo Rollouts v1.2</p>"},{"location":"features/traffic-management/alb/#example","title":"Example","text":"<pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: example-rollout\nspec:\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.15.4\n        ports:\n        - containerPort: 80\n  strategy:\n    canary:\n      pingPong: #Indicates that the ping-pong services enabled\n        pingService: ping-service\n        pongService: pong-service\n      trafficRouting:\n        alb:\n          ingress: alb-ingress\n          servicePort: 80\n      steps:\n      - setWeight: 20\n      - pause: {}\n</code></pre>"},{"location":"features/traffic-management/alb/#custom-annotations-prefix","title":"Custom annotations-prefix","text":"<p>The AWS Load Balancer Controller allows users to customize the annotation prefix used by the Ingress controller using a flag to the controller, <code>--annotations-prefix</code> (from the default of <code>alb.ingress.kubernetes.io</code>). If your AWS Load Balancer Controller is customized to use a different annotation prefix, <code>annotationPrefix</code> field should be specified such that the Ingress object will be annotated in a manner understood by the cluster's aws load balancer controller.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nspec:\n  strategy:\n    canary:\n      trafficRouting:\n        alb:\n          annotationPrefix: custom.alb.ingress.kubernetes.io\n</code></pre>"},{"location":"features/traffic-management/alb/#custom-ingress-class","title":"Custom Ingress Class","text":"<p>By default, Argo Rollout will operate on Ingresses with the annotation:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    kubernetes.io/ingress.class: alb\n</code></pre> <p>Or with the <code>ingressClassName</code>: <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nspec:\n  ingressClassName: alb\n</code></pre></p> <p>To configure the controller to operate on Ingresses with a different class name, you can specify a different value through the <code>--alb-ingress-classes</code> flag in the controller command line arguments.</p> <p>Note that the <code>--alb-ingress-classes</code> flag can be specified multiple times if the Argo Rollouts controller should operate on multiple values. This may be desired when a cluster has multiple Ingress controllers that operate on different <code>kubernetes.io/ingress.class</code> or <code>spec.ingressClassName</code> values.</p> <p>If the controller needs to operate on any Ingress without the <code>kubernetes.io/ingress.class</code> annotation or <code>spec.ingressClassName</code>, the flag can be specified with an empty string (e.g. <code>--alb-ingress-classes ''</code>).</p>"},{"location":"features/traffic-management/ambassador/","title":"Ambassador Edge Stack","text":"<p>Ambassador Edge Stack provides the functionality you need at the edge your Kubernetes cluster (hence, an \"edge stack\"). This includes an API gateway, ingress controller, load balancer, developer portal, canary traffic routing and more. It provides a group of CRDs that users can configure to enable different functionalities. </p> <p>Argo-Rollouts provides an integration that leverages Ambassador's canary routing capability. This allows the traffic to your application to be gradually incremented while new versions are being deployed.</p>"},{"location":"features/traffic-management/ambassador/#how-it-works","title":"How it works","text":"<p>Ambassador Edge Stack provides a resource called <code>Mapping</code> that is used to configure how to route traffic to services. Ambassador canary deployment is achieved by creating 2 mappings with the same URL prefix pointing to different services. Consider the following example:</p> <pre><code>apiVersion: getambassador.io/v2\nkind:  Mapping\nmetadata:\n  name: stable-mapping\nspec:\n  prefix: /someapp\n  rewrite: /\n  service: someapp-stable:80\n---\napiVersion: getambassador.io/v2\nkind:  Mapping\nmetadata:\n  name: canary-mapping\nspec:\n  prefix: /someapp\n  rewrite: /\n  service: someapp-canary:80\n  weight: 30\n</code></pre> <p>In the example above we are configuring Ambassador to route 30% of the traffic coming from <code>&lt;public ingress&gt;/someapp</code> to the service <code>someapp-canary</code> and the rest of the traffic will go to the service <code>someapp-stable</code>. If users want to gradually increase the traffic to the canary service, they have to update the <code>canary-mapping</code> setting the weight to the desired value either manually or automating it somehow. </p> <p>With Argo-Rollouts there is no need to create the <code>canary-mapping</code>. The process of creating it and gradually updating its weight is fully automated by the Argo-Rollouts controller. The following example shows how to configure the <code>Rollout</code> resource to use Ambassador as a traffic router for canary deployments:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\n...\nspec:\n  strategy:\n    canary:\n      stableService: someapp-stable\n      canaryService: someapp-canary\n      trafficRouting:\n        ambassador:\n          mappings:\n            - stable-mapping\n      steps:\n      - setWeight: 30\n      - pause: {duration: 60s}\n      - setWeight: 60\n      - pause: {duration: 60s}\n</code></pre> <p>Under <code>spec.strategy.canary.trafficRouting.ambassador</code> there are 2 possible attributes:</p> <ul> <li><code>mappings</code>: Required. At least one Ambassador mapping must be provided for Argo-Rollouts to be able to manage the canary deployment. Multiple mappings are also supported in case there are multiple routes to the service (e.g., your service has multiple ports, or can be accessed via different URLs). If no mapping is provided Argo-Rollouts will send an error event and the rollout will be aborted. </li> </ul> <p>When Ambassador is configured in the <code>trafficRouting</code> attribute of the manifest, the Rollout controller will: 1. Create one canary mapping for each stable mapping provided in the Rollout manifest 1. Proceed with the steps according to the configuration updating the canary mapping weight 1. At the end of the process Argo-Rollout will delete all the canary mappings created</p>"},{"location":"features/traffic-management/ambassador/#endpoint-resolver","title":"Endpoint Resolver","text":"<p>By default, Ambassador uses kube-proxy to route traffic to Pods. However we should configure it to bypass kube-proxy and route traffic directly to pods. This will provide true L7 load balancing which is desirable in a canary workflow. This approach is called endpoint routing and can be achieve by configuring endpoint resolvers.</p> <p>To configure Ambassador to use endpoint resolver it is necessary to apply the following resource in the cluster:</p> <pre><code>apiVersion: getambassador.io/v2\nkind: KubernetesEndpointResolver\nmetadata:\n  name: endpoint\n</code></pre> <p>And then configure the mapping to use it setting the <code>resolver</code> attribute:</p> <pre><code>apiVersion: getambassador.io/v2\nkind:  Mapping\nmetadata:\n  name: stable-mapping\nspec:\n  resolver: endpoint\n  prefix: /someapp\n  rewrite: /\n  service: someapp-stable:80\n</code></pre> <p>For more details about the Ambassador and Argo-Rollouts integration, see the Ambassador Argo documentation.</p>"},{"location":"features/traffic-management/apisix/","title":"Apache APISIX","text":"<p>You can use the Apache APISIX and Apache APISIX Ingress Controller for traffic management with Argo Rollouts.</p> <p>The ApisixRoute is the object that supports the ability for weighted round robin load balancing  when using Apache APISIX Ingress Controller as ingress.</p> <p>This guide shows you how to integrate ApisixRoute with Argo Rollouts using it as weighted round robin load balancer</p>"},{"location":"features/traffic-management/apisix/#prerequisites","title":"Prerequisites","text":"<p>Argo Rollouts requires  Apache APISIX v2.15 or newer and Apache APISIX Ingress Controller v1.5.0 or newer.</p> <p>Install Apache APISIX and Apache APISIX Ingress Controller with Helm v3:</p> <pre><code>helm repo add apisix https://charts.apiseven.com\nkubectl create ns apisix\n\nhelm upgrade -i apisix apisix/apisix --version=0.11.3 \\\n--namespace apisix \\\n--set ingress-controller.enabled=true \\\n--set ingress-controller.config.apisix.serviceNamespace=apisix\n</code></pre>"},{"location":"features/traffic-management/apisix/#bootstrap","title":"Bootstrap","text":"<p>First, we need to create the ApisixRoute object using its ability for weighted round robin load balancing.</p> <pre><code>apiVersion: apisix.apache.org/v2\nkind: ApisixRoute\nmetadata:\n  name: rollouts-apisix-route\nspec:\n  http:\n    - name: rollouts-apisix\n      match:\n        paths:\n          - /*\n        hosts:\n          - rollouts-demo.apisix.local\n      backends:\n        - serviceName: rollout-apisix-canary-stable\n          servicePort: 80\n        - serviceName: rollout-apisix-canary-canary\n          servicePort: 80\n</code></pre> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/examples/apisix/route.yaml\n</code></pre> <p>Notice, we don't specify the <code>weight</code> field. It is necessary to be synced with ArgoCD. If we specify this field and Argo Rollouts controller changes it, then the ArgoCD controller will notice it and will show that this resource is out of sync (if you are using Argo CD to manage your Rollout).</p> <p>Secondly, we need to create the Argo Rollouts object.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollout-apisix-canary\nspec:\n  replicas: 5\n  strategy:\n    canary:\n      canaryService: rollout-apisix-canary-canary\n      stableService: rollout-apisix-canary-stable\n      trafficRouting:\n        managedRoutes:\n          - name: set-header\n        apisix:\n          route:\n            name: rollouts-apisix-route\n            rules:\n              - rollouts-apisix\n      steps:\n        - setCanaryScale:\n            replicas: 1\n          setHeaderRoute:\n            match:\n              - headerName: trace\n                headerValue:\n                  exact: debug\n            name: set-header\n        - setWeight: 20\n        - pause: {}\n        - setWeight: 40\n        - pause:\n            duration: 15\n        - setWeight: 60\n        - pause:\n            duration: 15\n        - setWeight: 80\n        - pause:\n            duration: 15\n  revisionHistoryLimit: 2\n  selector:\n    matchLabels:\n      app: rollout-apisix-canary\n  template:\n    metadata:\n      labels:\n        app: rollout-apisix-canary\n    spec:\n      containers:\n        - name: rollout-apisix-canary\n          image: argoproj/rollouts-demo:blue\n          ports:\n            - name: http\n              containerPort: 8080\n              protocol: TCP\n          resources:\n            requests:\n              memory: 32Mi\n              cpu: 5m\n</code></pre> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/examples/apisix/rollout.yaml\n</code></pre> <p>Finally, we need to create the services for the Argo Rollouts object.</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: rollout-apisix-canary-canary\nspec:\n  ports:\n    - port: 80\n      targetPort: http\n      protocol: TCP\n      name: http\n  selector:\n    app: rollout-apisix-canary\n    # This selector will be updated with the pod-template-hash of the canary ReplicaSet. e.g.:\n    # rollouts-pod-template-hash: 7bf84f9696\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: rollout-apisix-canary-stable\nspec:\n  ports:\n    - port: 80\n      targetPort: http\n      protocol: TCP\n      name: http\n  selector:\n    app: rollout-apisix-canary\n    # This selector will be updated with the pod-template-hash of the stable ReplicaSet. e.g.:\n    # rollouts-pod-template-hash: 789746c88d\n</code></pre> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/examples/apisix/services.yaml\n</code></pre> <p>Initial creations of any Rollout will immediately scale up the replicas to 100% (skipping any canary upgrade steps, analysis, etc...) since there was no upgrade that occurred.</p> <p>The Argo Rollouts kubectl plugin allows you to visualize the Rollout, its related resources (ReplicaSets, Pods, AnalysisRuns), and presents live state changes as they occur. To watch the rollout as it deploys, run the get rollout --watch command from plugin:</p> <pre><code>kubectl argo rollouts get rollout rollout-apisix-canary --watch\n</code></pre>"},{"location":"features/traffic-management/apisix/#updating-a-rollout","title":"Updating a Rollout","text":"<p>Next it is time to perform an update. Just as with Deployments, any change to the Pod template field (<code>spec.template</code>) results in a new version (i.e. ReplicaSet) to be deployed. Updating a Rollout involves modifying the rollout spec, typically changing the container image field with a new version, and then running  <code>kubectl apply</code> against the new manifest. As a convenience, the rollouts plugin provides a <code>set image</code> command, which performs these steps against the live rollout object in-place. Run the following command to update the <code>rollout-apisix-canary</code> Rollout with the \"yellow\" version of the container:</p> <pre><code>kubectl argo rollouts set image rollout-apisix-canary \\\n  rollouts-demo=argoproj/rollouts-demo:yellow\n</code></pre> <p>During a rollout update, the controller will progress through the steps defined in the Rollout's update strategy. The example rollout sets a 20% traffic weight to the canary, and pauses the rollout indefinitely until user action is taken to unpause/promote the rollout.</p> <p>You can check ApisixRoute's backend weights by the following command <pre><code>kubectl describe apisixroute rollouts-apisix-route\n\n......\nSpec:\n  Http:\n    Backends:\n      Service Name:  rollout-apisix-canary-stable\n      Service Port:  80\n      Weight:        80\n      Service Name:  rollout-apisix-canary-canary\n      Service Port:  80\n      Weight:        20\n......\n</code></pre> The <code>rollout-apisix-canary-canary</code> service gets 20% traffic through the Apache APISIX.</p> <p>You can check SetHeader ApisixRoute's match by the following command <pre><code>kubectl describe apisixroute set-header\n\n......\nSpec:\n  Http:\n    Backends:\n      Service Name:  rollout-apisix-canary-canary\n      Service Port:  80\n      Weight:        100\n    Match:\n      Exprs:\n        Op:  Equal\n        Subject:\n          Name:   trace\n          Scope:  Header\n        Value:    debug\n......\n</code></pre></p>"},{"location":"features/traffic-management/google-cloud/","title":"Google Cloud","text":"<p>With the introduction of the Kubernetes Gateway API it is now possible to use Argo Rollouts with all compliant implementations that support it. The integration is available with the Argo Rollouts Gateway API plugin currently hosted in Argo Labs.</p> <p>Useful resources:</p> <ul> <li>The Gateway API specification</li> <li>Support of the Gateway API in Google Cloud</li> <li>Argo Rollouts Plugin capabilities </li> <li>Plugin for the Gateway API</li> </ul> <p>The process involves the following steps:</p> <ol> <li>Creating a Kubernetes cluster with support for the Gateway API in Google Cloud</li> <li>Creating a Load balancer that is managed by the Gateway API in Google Cloud</li> <li>Installing Argo Rollouts + gateway API plugin in the cluster</li> <li>Defining a Rollout that takes advantage of the plugin</li> </ol> <p>For a full application that includes all manifests see the plugin example.</p>"},{"location":"features/traffic-management/istio/","title":"Istio","text":"<p>Istio is a service mesh that offers a rich feature-set to control the flow of traffic to a web service. Istio offers this functionality through a set of CRDs, and Argo Rollouts automates the management of these resources to provide advanced traffic shaping capabilities to the different versions of the Rollout during an update.</p>"},{"location":"features/traffic-management/istio/#how-it-works","title":"How it works","text":"<p>Traffic splitting is accomplished in Istio by adjusting traffic weights defined in an Istio VirtualService. When using Argo Rollouts with Istio, a user deploys a VirtualService containing at least one HTTP route containing two HTTP route destinations: a route destination targeting the pods of canary ReplicaSet, and a route destination targeting the pods stable ReplicaSet. Istio provides two approaches for weighted traffic splitting, both approaches are available as options in Argo Rollouts:</p> <ol> <li>Host-level traffic splitting</li> <li>Subset-level traffic splitting</li> </ol>"},{"location":"features/traffic-management/istio/#host-level-traffic-splitting","title":"Host-level Traffic Splitting","text":"<p>The first approach to traffic splitting using Argo Rollouts and Istio, is splitting between two hostnames, or Kubernetes Services: a canary Service and a stable Service. This approach is similar to the way all other Argo Rollouts mesh/ingress-controller integrations work (e.g. ALB, SMI, Nginx). Using this approach, the user is required to deploy the following resources:</p> <ul> <li>Rollout</li> <li>Service (canary)</li> <li>Service (stable)</li> <li>VirtualService</li> </ul> <p>The Rollout should define the following fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollout-example\nspec:\n  ...\n  strategy:\n    canary:\n      canaryService: canary-svc  # required\n      stableService: stable-svc  # required\n      trafficRouting:\n        istio:\n          virtualService:\n            name: rollout-vsvc   # required\n            routes:\n            - primary            # optional if there is a single route in VirtualService, required otherwise\n      steps:\n      - setWeight: 5\n      - pause:\n          duration: 10m\n</code></pre> <p>The VirtualService must contain an HTTP route with a name referenced in the Rollout, containing two route destinations with <code>host</code> values that match the <code>canaryService</code> and <code>stableService</code> referenced in the Rollout.  If the VirtualService is defined in a different namespace than the rollout, its name should be <code>rollout-vsvc.&lt;vsvc namespace name&gt;</code>. Note that Istio requires that all weights add to 100, so the initial weights can be 100% to stable, and 0% to canary.</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: rollout-vsvc\nspec:\n  gateways:\n  - istio-rollout-gateway\n  hosts:\n  - istio-rollout.dev.argoproj.io\n  http:\n  - name: primary        # referenced in canary.trafficRouting.istio.virtualService.routes\n    route:\n    - destination:\n        host: stable-svc # referenced in canary.stableService\n      weight: 100\n    - destination:\n        host: canary-svc # referenced in canary.canaryService\n      weight: 0\n</code></pre> <p>Finally, a canary and stable Service should be deployed. The selector of these Services will be modified by the Rollout during an update to target the canary and stable ReplicaSet pods. Note that if the VirtualService and destination host resides in different namespaces (e.g., VirtualService and Rollout are not in the same namespace), the namespace should be included in the destination host (e.g. <code>stable-svc.&lt;namespace&gt;</code>).</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: canary-svc\nspec:\n  ports:\n  - port: 80\n    targetPort: http\n    protocol: TCP\n    name: http\n  selector:\n    app: rollouts-demo\n    # This selector will be updated with the pod-template-hash of the canary ReplicaSet. e.g.:\n    # rollouts-pod-template-hash: 7bf84f9696\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: stable-svc\nspec:\n  ports:\n  - port: 80\n    targetPort: http\n    protocol: TCP\n    name: http\n  selector:\n    app: rollouts-demo\n    # This selector will be updated with the pod-template-hash of the stable ReplicaSet. e.g.:\n    # rollouts-pod-template-hash: 123746c88d\n</code></pre> <p>During the lifecycle of a Rollout update, Argo Rollouts will continuously:</p> <ul> <li>modify the canary Service <code>spec.selector</code> to contain the <code>rollouts-pod-template-hash</code> label of the canary ReplicaSet</li> <li>modify the stable Service <code>spec.selector</code> to contain the <code>rollouts-pod-template-hash</code> label of the stable ReplicaSet</li> <li>modify the VirtualService <code>spec.http[].route[].weight</code> to match the current desired canary weight</li> </ul> <p>Note</p> <p>Rollout does not make any other assumptions about the fields within the VirtualService or the Istio mesh. The user could specify additional configurations for the VirtualService like URI rewrite rules on the primary route or any other route if desired. The user can also create specific DestinationRules for each of the services.</p>"},{"location":"features/traffic-management/istio/#subset-level-traffic-splitting","title":"Subset-level Traffic Splitting","text":"<p>Important</p> <p>Available since v1.0</p> <p>The second approach to traffic splitting using Argo Rollouts and Istio, is splitting between two Istio DestinationRule Subsets: a canary subset and a stable subset. When splitting by DestinationRule subsets, the user is required to deploy the following resources:</p> <ul> <li>Rollout</li> <li>Service</li> <li>VirtualService</li> <li>DestinationRule</li> </ul> <p>The Rollout should define the following fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollout-example\nspec:\n  ...\n  strategy:\n    canary:\n      trafficRouting:\n        istio:\n          virtualService:\n            name: rollout-vsvc        # required\n            routes:\n            - primary                 # optional if there is a single route in VirtualService, required otherwise\n          destinationRule:\n            name: rollout-destrule    # required\n            canarySubsetName: canary  # required\n            stableSubsetName: stable  # required\n      steps:\n      - setWeight: 5\n      - pause:\n          duration: 10m\n</code></pre> <p>A single service should be defined, which targets the Rollout pods. Note that unlike the first approach, where traffic splitting is against multiple Services which are modified to contain the rollout-pod-template-hash of the canary/stable ReplicaSets, this Service is not modified by the rollout controller.</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: rollout-example\nspec:\n  ports:\n  - port: 80\n    targetPort: http\n    protocol: TCP\n    name: http\n  selector:\n    app: rollout-example\n</code></pre> <p>The VirtualService must contain an HTTP route with a name referenced in the Rollout, containing two route destinations with <code>subset</code> values that match the <code>canarySubsetName</code> and <code>stableSubsetName</code> referenced in the Rollout. Note that Istio requires that all weights add to 100, so the initial weights can be 100% to stable, and 0% to canary.</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: rollout-vsvc\nspec:\n  gateways:\n  - istio-rollout-gateway\n  hosts:\n  - istio-rollout.dev.argoproj.io\n  http:\n  - name: primary       # referenced in canary.trafficRouting.istio.virtualService.routes\n    route:\n    - destination:\n        host: rollout-example\n        subset: stable  # referenced in canary.trafficRouting.istio.destinationRule.stableSubsetName\n      weight: 100\n    - destination:\n        host: rollout-example\n        subset: canary  # referenced in canary.trafficRouting.istio.destinationRule.canarySubsetName\n      weight: 0\n</code></pre> <p>Finally, the DestinationRule containing the canary and stable subsets referenced in the Rollout.</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: rollout-destrule\nspec:\n  host: rollout-example\n  subsets:\n  - name: canary   # referenced in canary.trafficRouting.istio.destinationRule.canarySubsetName\n    labels:        # labels will be injected with canary rollouts-pod-template-hash value\n      app: rollout-example\n  - name: stable   # referenced in canary.trafficRouting.istio.destinationRule.stableSubsetName\n    labels:        # labels will be injected with stable rollouts-pod-template-hash value\n      app: rollout-example\n</code></pre> <p>During the lifecycle of a Rollout using Istio DestinationRule, Argo Rollouts will continuously:</p> <ul> <li>modify the VirtualService <code>spec.http[].route[].weight</code> to match the current desired canary weight</li> <li>modify the DestinationRule <code>spec.subsets[].labels</code> to contain the <code>rollouts-pod-template-hash</code>   label of the canary and stable ReplicaSets</li> </ul>"},{"location":"features/traffic-management/istio/#tcp-traffic-splitting","title":"TCP Traffic Splitting","text":"<p>Important</p> <p>Available since v1.2.2</p> <p>Support for splitting TCP traffic was introduced and requires the Rollout to define the following fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollout-example\nspec:\n  ...\n  strategy:\n    canary:\n      canaryService: canary-svc  # required\n      stableService: stable-svc  # required\n      trafficRouting:\n        istio:\n          virtualService:\n            name: rollout-vsvc   # required\n            tcpRoutes:\n              # Below fields are optional but if defined, they should match exactly with at least one of the TCP route match rules in your VirtualService\n              - port: 3000 # Only required if you want to match any rule in your VirtualService which contains this port\n      steps:\n      - setWeight: 5\n      - pause:\n          duration: 10m\n</code></pre> <p>The VirtualService must contain a TCP route with a matching port referenced in the Rollout</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: rollout-vsvc\nspec:\n  gateways:\n    - istio-rollout-gateway\n  hosts:\n    - istio-rollout.dev.argoproj.io\n  tcp:\n    - match:\n        - port: 3000\n      route:\n        - destination:\n            host: stable-svc # referenced in canary.stableService\n          weight: 100\n        - destination:\n            host: canary-svc # referenced in canary.canaryService\n          weight: 0\n</code></pre>"},{"location":"features/traffic-management/istio/#multicluster-setup","title":"Multicluster Setup","text":"<p>If you have Istio multicluster setup where the primary Istio cluster is different than the cluster where the Argo Rollout controller is running, then you need to do the following setup:</p> <ol> <li>Create a <code>ServiceAccount</code> in the Istio primary cluster. <pre><code>apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: argo-rollouts-istio-primary\n  namespace: &lt;any-namespace-preferrably-config-namespace&gt;\n</code></pre></li> <li>Create a <code>ClusterRole</code> that provides access to Rollout controller in the Istio primary cluster. <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: argo-rollouts-istio-primary\nrules:\n- apiGroups:\n  - networking.istio.io\n  resources:\n  - virtualservices\n  - destinationrules\n  verbs:\n  - get\n  - list\n  - watch\n  - update\n  - patch\n</code></pre> Note: If Argo Rollout controller is also installed in the Istio primary cluster, then you can reuse the <code>argo-rollouts-clusterrole</code> ClusterRole instead of creating a new one.</li> <li>Link the <code>ClusterRole</code> with the <code>ServiceAccount</code> in the Istio primary cluster. <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: argo-rollouts-istio-primary\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: argo-rollouts-istio-primary\nsubjects:\n- kind: ServiceAccount\n  name: argo-rollouts-istio-primary\n  namespace: &lt;namespace-of-the-service-account&gt;\n</code></pre></li> <li>Now, use the following command to generate a secret for Rollout controller to access the Istio primary cluster.    This secret will be applied to the cluster where Argo Rollout is running (i.e, Istio remote cluster),    but will be generated from the Istio primary cluster. This secret can be generated right after Step 1,    it only requires <code>ServiceAccount</code> to exist.    Reference to the command. <pre><code>istioctl x create-remote-secret --type remote --name &lt;cluster-name&gt; \\\n    --namespace &lt;namespace-of-the-service-account&gt; \\\n    --service-account &lt;service-account-created-in-step1&gt; \\\n    --context=\"&lt;ISTIO_PRIMARY_CLUSTER&gt;\" | \\\n    kubectl apply -f - --context=\"&lt;ARGO_ROLLOUT_CLUSTER/ISTIO_REMOTE_CLUSTER&gt;\"\n</code></pre></li> <li>Label the secret. <pre><code>kubectl label secret &lt;istio-remote-secret&gt; istio.argoproj.io/primary-cluster=\"true\" -n &lt;namespace-of-the-secret&gt;\n</code></pre></li> </ol>"},{"location":"features/traffic-management/istio/#comparison-between-approaches","title":"Comparison Between Approaches","text":"<p>There are some advantages and disadvantages of host-level traffic splitting vs. subset-level traffic splitting.</p>"},{"location":"features/traffic-management/istio/#dns-requirements","title":"DNS requirements","text":"<p>With host-level splitting, the VirtualService requires different <code>host</code> values to split among the two destinations. However, using two host values implies the use of different DNS names (one for the canary, the other for the stable). For north-south traffic, which reaches the Service through the Istio Gateway, having multiple DNS names to reach the canary vs. stable pods may not matter. However, for east-west or intra-cluster traffic, it forces microservice-to-microservice communication to choose whether to hit the stable or the canary DNS name, go through the gateway, or add DNS entries for the VirtualServices. In this situation, the DestinationRule subset traffic splitting would be a better option for intra-cluster canarying.</p>"},{"location":"features/traffic-management/istio/#metrics","title":"Metrics","text":"<p>Depending on the choice of host-level splitting vs. subset-level splitting, there will be different styles of prometheus metrics available. For example, if using host-level splitting, the metrics of the canary vs. stable would appear in the Istio Service metrics dashboard:</p> <p></p> <p>On the other hand, when splitting via subsets, it would be necessary to query prometheus using different parameters, such as the workload name:</p> <p></p>"},{"location":"features/traffic-management/istio/#integrating-with-gitops","title":"Integrating with GitOps","text":"<p>Earlier it was explained that VirtualServices should be deployed with an initial canary and stable weight of 0 and 100, respectively, such as in the following example:</p> <pre><code>  http:\n  - name: primary\n    route:\n    - destination:\n        host: stable-svc\n      weight: 100\n    - destination:\n        host: canary-svc\n      weight: 0\n</code></pre> <p>This introduces a problem for users practicing GitOps. Since a Rollout will modify these VirtualService weights as the Rollout progresses through its steps, it unfortunately causes the VirtualService to become OutOfSync with the version in git. Additionally, if the VirtualService in git were to be applied while the Rollout is in this state (splitting traffic between the services), the apply would revert the weights back to the values in git (i.e. 100 to stable, 0 to canary).</p> <p>One protection which is implemented in Argo Rollouts, is that it continually watches for changes to managed VirtualServices. In the event that a <code>kubectl apply</code> were to happen using the VirtualService in git, the change would be detected immediately by the rollout controller, and the controller will instantly set the VirtualService weights back to the canary weight appropriate for the given step of the Rollout. But since there is momentary flapping of weights, this behavior should be understood.</p> <p>Some best practices to follow when using Argo CD with Argo Rollouts to prevent this behavior, is to leverage the following Argo CD features:</p> <ol> <li> <p>Configure the application to ignore differences in the VirtualService. e.g.:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: guestbook\nspec:\n  ignoreDifferences:\n  - group: networking.istio.io\n    kind: VirtualService\n    jsonPointers:\n    - /spec/http/0\n</code></pre> <p>Ignoring the differences in the VirtualServices HTTP route, prevents gitops differences in the VirtualService HTTP routes to contribute to the overall sync status of the Argo CD application. This adds the additional benefit of prevent auto-sync operations from being triggered.</p> </li> <li> <p>Configure the Application to only apply OutOfSync resources:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: guestbook\nspec:\n  syncPolicy:\n    syncOptions:\n    - ApplyOutOfSyncOnly=true\n</code></pre> <p>By default, when Argo CD  syncs an application, it runs <code>kubectl apply</code> against all resources in git which are part of the application. The <code>ApplyOutOfSyncOnly=true</code> sync option indicates to Argo CD to skip applying resources which it already considers <code>Synced</code>, and only apply the ones which are <code>OutOfSync</code>. This option, when used in conjunction with the <code>ignoreDifferences</code> feature, provides a way to manage the conflict in the desired state of a VirtualService between Argo CD and Argo Rollouts.</p> </li> </ol> <p>Argo CD also has an open issue here which would help address this problem. The proposed solution is to introduce an annotation to resources, which indicates to Argo CD to respect and preserve the differences at a specified path, in order to allow other controllers (e.g. Argo Rollouts) controller manage them instead.</p>"},{"location":"features/traffic-management/istio/#ping-pong","title":"Ping Pong","text":"<p>Important</p> <p>Available since v1.7</p> <p>Argo Rollouts also supports ping pong when using Istio this was added to support configuring both ALB and Istio traffic routers at the same time. When using an ALB, ping-pong is generally a best practice especially with ALB readiness  gates enabled. However, when we change the service selectors when a rollout is aborted back to stable pod hash it causes a blip  of traffic outage because the ALB controller will set the pod readiness gates to false for a short while due to the label changes. If we configure both ALB and Istio with ping-pong this selector change does not happen and hence we do not see any outages.</p>"},{"location":"features/traffic-management/istio/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"features/traffic-management/istio/#rollout-ownership-over-the-virtual-service","title":"Rollout ownership over the Virtual Service","text":"<p>An early design alternative was that instead of the controller modifying a referenced VirtualService, the Rollout controller would create, manage, and own a Virtual Service. While this approach is GitOps friendly, it introduces other issues:</p> <ul> <li>To provide the same flexibility as referencing VirtualService within a Rollout, the Rollout needs to inline a large portion of the Istio spec. However, networking is outside the responsibility of the Rollout and makes the Rollout spec unnecessarily complicated.</li> <li>If Istio introduces a feature, that feature will not be available in Argo Rollouts until implemented within Argo Rollouts.</li> </ul> <p>Both of these issues adds more complexity to the users and Argo Rollouts developers compared to referencing a Virtual Service.</p>"},{"location":"features/traffic-management/istio/#istio-support-through-the-smi-adapter-for-istio","title":"Istio support through the SMI Adapter for Istio","text":"<p>SMI is the Service Mesh Interface, which serves as a standard interface for all common features of a service mesh. This feature is GitOps friendly, but native Istio has extra functionality that SMI does not currently provide.</p>"},{"location":"features/traffic-management/kong/","title":"Kong Ingress","text":"<p>With the introduction of the Kubernetes Gateway API it is now possible to use Argo Rollouts with all compliant implementations that support it. The integration is available with the Argo Rollouts Gateway API plugin currently hosted in Argo Labs.</p> <p>Useful resources:</p> <ul> <li>The Gateway API specification</li> <li>Support of the Gateway API in Kong</li> <li>Argo Rollouts Plugin capabilities </li> <li>Plugin for the Gateway API</li> </ul> <p>The process involves the following steps:</p> <ol> <li>Installing the Gateway API CRDs in your cluster</li> <li>Installing Kong and enabling the Gateway API support feature</li> <li>Creating a GatewayClass and Gateway resources </li> <li>Installing Argo Rollouts + gateway API plugin in the cluster</li> <li>Defining a Rollout that takes advantage of the plugin</li> </ol> <p>For a full application that includes all manifests see the plugin example.</p>"},{"location":"features/traffic-management/mixed/","title":"Multiple Providers","text":"<p>Note</p> <p>Multiple trafficRouting is available since Argo Rollouts v1.2</p> <p>The usage of multiple providers tries to cover scenarios where, for some reason, we have to use different providers on North-South and West-East traffic routing or any other hybrid architecture that requires the use of multiple providers.</p>"},{"location":"features/traffic-management/mixed/#examples-of-when-you-can-use-multiple-providers","title":"Examples of when you can use multiple providers","text":""},{"location":"features/traffic-management/mixed/#avoid-injecting-sidecars-on-your-ingress-controller","title":"Avoid injecting sidecars on your Ingress controller","text":"<p>This is a common requirement of the service mesh and with multiple trafficRoutings you can leverage North-South traffic shifting to NGiNX  and West-East traffic shifting to SMI, avoiding the need of adding the Ingress controller inside the mesh.</p>"},{"location":"features/traffic-management/mixed/#avoid-manipulation-of-the-host-header-at-the-ingress","title":"Avoid manipulation of the host header at the Ingress","text":"<p>Another common side effect of adding some of the Ingress controllers into the mesh, and is caused by the usage of those  mesh host headers to be pointing into a mesh hostname in order to be routed.</p>"},{"location":"features/traffic-management/mixed/#avoid-big-bang","title":"Avoid Big-Bang","text":"<p>This takes place on existing fleets where downtime is very reduced or nearly impossible. To avoid big-bang-adoption the use of multiple providers can ease how teams can implement gradually new technologies. An example, where an existing fleet that is using a provider such as Ambassador and is already performing canary in a North-South fashion as part of their rollouts can gradually  implement more providers such as Istio, SMI, etc.</p>"},{"location":"features/traffic-management/mixed/#hybrid-scenarios","title":"Hybrid Scenarios","text":"<p>In this case, its very similar to avoiding the Big-Bang, either if it is part of the platform roadmap or a new redesign of the architecture, there are multiple scenarios where having the capacity of using multiple trafficRoutings is very  much in need: gradual implementation, eased rollback of architecture or even for a fallback.</p>"},{"location":"features/traffic-management/mixed/#requirements","title":"Requirements","text":"<p>The use of multiple providers requires that both providers comply with its minimum requirements independently. By example, if you want to use NGiNX and SMI you would need to have both SMI and NGiNX in place and produce the rollout configuration for both.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollouts-demo\nspec:\n  strategy:\n    canary:\n      # Reference to a Service which the controller will update to point to the canary ReplicaSet\n      canaryService: rollouts-demo-canary\n      # Reference to a Service which the controller will update to point to the stable ReplicaSet\n      stableService: rollouts-demo-stable\n      trafficRouting:\n        nginx:\n          # Reference to an Ingress which has a rule pointing to the stable service (e.g. rollouts-demo-stable)\n          # This ingress will be cloned with a new name, in order to achieve NGINX traffic splitting.\n          stableIngress: rollouts-demo-stable\n        smi: {}\n</code></pre>"},{"location":"features/traffic-management/nginx/","title":"Nginx","text":"<p>The Nginx Ingress Controller enables traffic management through one or more Ingress objects to configure an Nginx deployment that routes traffic directly to pods. Each Nginx Ingress contains multiple annotations that modify the behavior of the Nginx Deployment. For traffic management between different versions of an application, the Nginx Ingress controller provides the capability to split traffic by introducing a second Ingress object (referred to as the canary Ingress) with some special annotations. You can read more about these canary annotations on the official canary annotations documentation page. The canary Ingress ignores any other non-canary nginx annotations. Instead, it leverages the annotation settings from the primary Ingress.</p> <p>The Rollout controller will always set the following two annotations on the canary Ingress (using your configured or the default <code>nginx.ingress.kubernetes.io</code> prefix):</p> <ul> <li><code>canary: true</code> to indicate that this is the canary Ingress</li> <li><code>canary-weight: &lt;num&gt;</code> to indicate what percentage of traffic to send to the canary. If all traffic is routed to the stable Service, this is set to <code>0</code></li> </ul> <p>You can provide additional annotations to add to the canary Ingress via the <code>additionalIngressAnnotations</code> or <code>canaryIngressAnnotations</code> field to enable features like routing by header or cookie. While the former offers the possibility of reusing a common, injectable nginx annotation prefix, the latter allows defining custom full annotations of any group, which may be relevant for other, independent mechanisms, such as a third-party metrics scraper or some other infrastructure integration.</p>"},{"location":"features/traffic-management/nginx/#integration-with-argo-rollouts","title":"Integration with Argo Rollouts","text":"<p>There are a couple of required fields in a Rollout to send split traffic between versions using Nginx. Below is an example of a Rollout with those fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nspec:\n  ...\n  strategy:\n    canary:\n      canaryService: canary-service  # required\n      stableService: stable-service  # required\n      trafficRouting:\n        nginx:\n          # Either stableIngress or stableIngresses must be configured, but not both.\n          stableIngress: primary-ingress\n          stableIngresses:\n            - primary-ingress\n            - secondary-ingress\n            - tertiary-ingress\n          annotationPrefix: customingress.nginx.ingress.kubernetes.io # optional\n          additionalIngressAnnotations:   # optional\n            canary-by-header: X-Canary\n            canary-by-header-value: iwantsit\n          canaryIngressAnnotations:     # optional\n            my-custom-annotation.mygroup.com/key: value\n</code></pre> <p>The stable Ingress field is a reference to an Ingress in the same namespace of the Rollout. The Rollout requires the primary Ingress routes traffic to the stable Service. The Rollout checks that condition by confirming the Ingress has a backend that matches the Rollout's stableService.</p> <p>The controller routes traffic to the canary Service by creating a second Ingress with the canary annotations. As the Rollout progresses through the Canary steps, the controller updates the canary Ingress's canary annotations to reflect the desired state of the Rollout enabling traffic splitting between two different versions.</p> <p>Since the Nginx Ingress controller allows users to configure the annotation prefix used by the Ingress controller, Rollouts can specify the optional <code>annotationPrefix</code> field. The canary Ingress uses that prefix instead of the default <code>nginx.ingress.kubernetes.io</code> if the field set.</p> <p>If full annotations, as defined in the Kubernetes docs, perhaps from different groups, need to be declared instead, the <code>canaryIngressAnnotations</code> field can be used, which accepts a similar key-value structure, but performs no prefix injection. Note that, in case of collision with <code>additionalIngressAnnotations</code>, the value under <code>canaryIngressAnnotations</code> prevails.</p>"},{"location":"features/traffic-management/nginx/#using-argo-rollouts-with-multiple-nginx-ingress-controllers-per-service","title":"Using Argo Rollouts with multiple NGINX ingress controllers per service","text":"<p>Starting with v1.5, argo rollouts supports multiple Nginx ingress controllers pointing at one service with canary deployments. If only one ingress controller is needed, utilize the existing key <code>stableIngress</code>. If multiple ingress controllers are needed (e.g., separating internal vs external traffic), use the key <code>stableIngresses</code> instead. It takes an array of string values that are the names of the ingress controllers. Canary steps are applied identically across all ingress controllers.</p>"},{"location":"features/traffic-management/nginx/#using-argo-rollouts-with-custom-nginx-ingress-controller-names","title":"Using Argo Rollouts with custom NGINX ingress controller names","text":"<p>As a default, the Argo Rollouts controller only operates on ingresses with the <code>kubernetes.io/ingress.class</code> annotation or <code>spec.ingressClassName</code> set to <code>nginx</code>. A user can configure the controller to operate on Ingresses with different class name by specifying the <code>--nginx-ingress-classes</code> flag. A user can list the <code>--nginx-ingress-classes</code> flag multiple times if the Argo Rollouts controller should operate on multiple values. This solves the case where a cluster has multiple Ingress controllers operating on different class values.</p> <p>If the user would like the controller to operate on any Ingress without the <code>kubernetes.io/ingress.class</code> annotation or <code>spec.ingressClassName</code>, a user should add the following <code>--nginx-ingress-classes ''</code>.</p>"},{"location":"features/traffic-management/plugins/","title":"Traffic Router Plugins","text":"<p>Important</p> <p>Available since v1.5 - Status: Alpha</p> <p>Argo Rollouts supports getting analysis metrics via 3rd party plugin system. This allows users to extend the capabilities of Rollouts to support metric providers that are not natively supported. Rollout's uses a plugin library called go-plugin to do this. You can find a sample plugin here: rollouts-plugin-trafficrouter-sample-nginx</p>"},{"location":"features/traffic-management/plugins/#using-a-traffic-router-plugin","title":"Using a Traffic Router Plugin","text":"<p>There are two methods of installing and using an argo rollouts plugin. The first method is to mount up the plugin executable into the rollouts controller container. The second method is to use a HTTP(S) server to host the plugin executable.</p>"},{"location":"features/traffic-management/plugins/#mounting-the-plugin-executable-into-the-rollouts-controller-container","title":"Mounting the plugin executable into the rollouts controller container","text":"<p>There are a few ways to mount the plugin executable into the rollouts controller container. Some of these will depend on your particular infrastructure. Here are a few methods:</p> <ul> <li>Using an init container to download the plugin executable</li> <li>Using a Kubernetes volume mount with a shared volume such as NFS, EBS, etc.</li> <li>Building the plugin into the rollouts controller container</li> </ul> <p>Then you can use the configmap to point to the plugin executable file location. Example:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-config\ndata:\n  trafficRouterPlugins: |-\n    - name: \"argoproj-labs/sample-nginx\" # name of the plugin, it must match the name required by the plugin so it can find it's configuration\n      location: \"file://./my-custom-plugin\" # supports http(s):// urls and file://\n</code></pre>"},{"location":"features/traffic-management/plugins/#using-a-https-server-to-host-the-plugin-executable","title":"Using a HTTP(S) server to host the plugin executable","text":"<p>Argo Rollouts supports downloading the plugin executable from a HTTP(S) server. To use this method, you will need to configure the controller via the <code>argo-rollouts-config</code> configmap and set <code>pluginLocation</code> to a http(s) url. Example:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-config\ndata:\n  trafficRouterPlugins: |-\n    - name: \"argoproj-labs/sample-nginx\" # name of the plugin, it must match the name required by the plugin so it can find it's configuration\n      location: \"https://github.com/argoproj-labs/rollouts-plugin-trafficrouter-sample-nginx/releases/download/v0.0.1/metric-plugin-linux-amd64\" # supports http(s):// urls and file://\n      sha256: \"08f588b1c799a37bbe8d0fc74cc1b1492dd70b2c\" #optional sha256 checksum of the plugin executable\n</code></pre>"},{"location":"features/traffic-management/plugins/#some-words-of-caution","title":"Some words of caution","text":"<p>Depending on which method you use to install and the plugin, there are some things to be aware of. The rollouts controller will not start if it can not download or find the plugin executable. This means that if you are using a method of installation that requires a download of the plugin and the server hosting the plugin for some reason is not available and the rollouts controllers pod got deleted while the server was down or is coming up for the first time, it will not be able to start until the server hosting the plugin is available again.</p> <p>Argo Rollouts will download the plugin at startup only once but if the pod is deleted it will need to download the plugin again on next startup. Running Argo Rollouts in HA mode can help a little with this situation because each pod will download the plugin at startup. So if a single pod gets deleted during a server outage, the other pods will still be able to take over because there will already be a plugin executable available to it. It is the responsibility of the Argo Rollouts administrator to define the plugin installation method considering the risks of each approach.</p>"},{"location":"features/traffic-management/plugins/#list-of-available-plugins-alphabetical-order","title":"List of Available Plugins (alphabetical order)","text":""},{"location":"features/traffic-management/plugins/#add-your-plugin-here","title":"Add Your Plugin Here","text":"<ul> <li>If you have created a plugin, please submit a PR to add it to this list.</li> </ul>"},{"location":"features/traffic-management/plugins/#rollouts-plugin-trafficrouter-sample-nginx","title":"rollouts-plugin-trafficrouter-sample-nginx","text":"<ul> <li>This is just a sample plugin that can be used as a starting point for creating your own plugin.   It is not meant to be used in production. It is based on the built-in prometheus provider.</li> </ul>"},{"location":"features/traffic-management/plugins/#consul","title":"Consul","text":"<ul> <li>This is a plugin that allows argo-rollouts to work with Consul's service mesh for traffic shaping patterns.</li> </ul>"},{"location":"features/traffic-management/plugins/#contour","title":"Contour","text":"<ul> <li>This is a plugin that allows argo-rollouts to work with contour's resource: HTTPProxy. It enables traffic shaping patterns such as canary releases and more.</li> </ul>"},{"location":"features/traffic-management/plugins/#gateway-api","title":"Gateway API","text":"<ul> <li>Provide support for Gateway API, which includes Kuma, Traefix, cilium, Contour, GloodMesh, HAProxy, and many others.</li> </ul>"},{"location":"features/traffic-management/smi/","title":"Service Mesh Interface (SMI)","text":"<p>Important</p> <p>Available since v0.9.0</p> <p>Warning</p> <p>The Cloud Native Computing Foundation has archived the SMI Spec. The recommended way forward is to look at the Gateway API, Project Gamma and the Argo Rollouts Gateway API Plugin. </p> <p>Service Mesh Interface (SMI) is a standard interface for service meshes on Kubernetes leveraged by many Service Mesh implementations (like Linkerd). SMI offers this functionality through a set of CRDs, and the Argo Rollouts controller creates these resources to manipulate the traffic routing into the desired state. </p> <p>The Argo Rollout controller achieves traffic shaping by creating and manipulating the TrafficSplit CR. A TrafficSplit describes the desired traffic routing for an application and relies on the underlying Service Meshes implement that desired state. Instead of worrying about the details of a specific service mesh, a user needs to specify a root Service that clients use to communicate and a list of backends consisting of a Service and weight. The Service Mesh implementing SMI uses this spec to route traffic to the backends Services based on the weights of the backends. For Rollout users, the Argo Rollout controller creates and manipulates the TrafficSplit using the following information:</p> <ul> <li>Canary Service: Name of the service that sends traffic only to the canary pods</li> <li>Stable Service: Name of the service that sends traffic only to the stable pods</li> <li>Root Service: Name of the service that clients use to communicate. If a request comes to this root service not through a proxy, the standard Kubernetes service routing will be used.</li> </ul> <p>Below is an example of a Rollout with all the required fields configured:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollout-example\nspec:\n  ...\n  strategy:\n    canary:\n      steps:\n      - setWeight: 5\n      - pause:\n          duration: 600\n      canaryService: canary-svc # required\n      stableService: stable-svc # required\n      trafficRouting:\n        smi:\n         rootService: root-svc # optional\n         trafficSplitName: rollout-example-traffic-split # optional\n</code></pre> <p></p> <p>With the above configuration, the controller can automate dynamic traffic splitting. First, the controller manipulates the canary and stable Service listed in the Rollout to make them only receive traffic from the respective canary and stable ReplicaSets. The controller achieves this by adding the ReplicaSet's unique pod template hash to that Service's selector. With the stable and canary Services configured, the controller creates a TrafficSplit using these Services in the backend, and the weights of the backend are dynamically configured from the current desired weight of the Rollout's canary steps. The controller sets the TrafficSplit's root service to the stableService unless the Rollout has the rootService field specified. This configured TrafficSplit along with the Service and Rollout resources enable fine-grained percentages of traffic between two versions of an application. Optionally, the user can specify a name for the traffic split. If there is no name listed in the Rollout, the controller uses the Rollout's name for the TrafficSplit. If a TrafficSplit with that name already exists and isn't owned by that Rollout, the controller marks the Rollout as an error state.</p> <p>Here is the TrafficSplit created from the above Rollout:</p> <pre><code>apiVersion: split.smi-spec.io/v1alpha1\nkind: TrafficSplit\nmetadata:\n  name: rollout-example-traffic-split\nspec:\n  service: root-svc # controller uses the stableService if Rollout does not specify the rootService field\n  backends:\n  - service: stable-svc\n    weight: 95\n  - service: canary-svc\n    weight: 5\n</code></pre> <p>As a Rollout progresses through all its steps, the controller updates the TrafficSplit's backend weights to reflect the current weight of the Rollout. When the Rollout has successfully finished executing all the steps, the controller modifies the stable Service's selector to point at the desired ReplicaSet and TrafficSplit's weight to send 100% of traffic to the stable Service.</p> <p>Note</p> <p>The controller defaults to using the <code>v1alpha1</code> version of the TrafficSplit. The Argo Rollouts operator can change the api version used by specifying a <code>--traffic-split-api-version</code> flag in the controller args.</p>"},{"location":"features/traffic-management/traefik/","title":"Traefik","text":"<p>You can use the Traefik Proxy for traffic management with Argo Rollouts.</p> <p>The TraefikService is the object that supports the ability for weighted round robin load balancing and traffic mirroring when using Traefik as ingress.</p> <p>Note</p> <p>Traefik is also supported via the  Argo Rollouts Gateway API plugin. </p>"},{"location":"features/traffic-management/traefik/#how-to-integrate-traefikservice-with-argo-rollouts-using-it-as-weighted-round-robin-load-balancer","title":"How to integrate TraefikService with Argo Rollouts using it as weighted round robin load balancer","text":"<p>First, we need to create the TraefikService object using its ability for weighted round robin load balancing.</p> <pre><code>apiVersion: traefik.containo.us/v1alpha1\nkind: TraefikService\nmetadata:\n  name: traefik-service\nspec:\n  weighted:\n    services:\n      - name: stable-rollout # k8s service name that you need to create for stable application version\n        port: 80\n      - name: canary-rollout # k8s service name that you need to create for new application version\n        port: 80\n</code></pre> <p>Notice, we don't specify the <code>weight</code> field. It is necessary to be synced with ArgoCD. If we specify this field and Argo Rollouts controller changes it, then the ArgoCD controller will notice it and will show that this resource is out of sync (if you are using Argo CD to manage your Rollout).</p> <p>Secondly, we need to create the Argo Rollouts object.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollouts-demo\nspec:\n  replicas: 5\n  strategy:\n    canary:\n      canaryService: canary-rollout\n      stableService: stable-rollout\n      trafficRouting:\n        traefik:\n          weightedTraefikServiceName: traefik-service # specify traefikService resource name that we have created before\n      steps:\n      - setWeight: 30\n      - pause: {}\n      - setWeight: 40\n      - pause: {duration: 10}\n      - setWeight: 60\n      - pause: {duration: 10}\n      - setWeight: 80\n      - pause: {duration: 10}\n  ...\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/","title":"Rollouts","text":"<p>Manage argo rollouts</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands which can be used to manage Argo Rollouts.</p> <pre><code>kubectl argo rollouts COMMAND [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/#examples","title":"Examples","text":"<pre><code># Get guestbook rollout and watch progress\nkubectl argo rollouts get rollout guestbook -w\n\n# Pause the guestbook rollout\nkubectl argo rollouts pause guestbook\n\n# Promote the guestbook rollout\nkubectl argo rollouts promote guestbook\n\n# Abort the guestbook rollout\nkubectl argo rollouts abort guestbook\n\n# Retry the guestbook rollout\nkubectl argo rollouts retry guestbook\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/#options","title":"Options","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n  -h, --help                           help for kubectl-argo-rollouts\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts abort   - Abort a rollout</li> <li>rollouts completion     - Generate completion script</li> <li>rollouts create     - Create a Rollout, Experiment, AnalysisTemplate, ClusterAnalysisTemplate, or AnalysisRun resource</li> <li>rollouts dashboard   - Start UI dashboard</li> <li>rollouts get   - Get details about rollouts and experiments</li> <li>rollouts lint     - Lint and validate a Rollout</li> <li>rollouts list     - List rollouts or experiments</li> <li>rollouts notifications   - Set of CLI commands that helps manage notifications settings</li> <li>rollouts pause   - Pause a rollout</li> <li>rollouts promote   - Promote a rollout</li> <li>rollouts restart   - Restart the pods of a rollout</li> <li>rollouts retry   - Retry a rollout or experiment</li> <li>rollouts set   - Update various values on resources</li> <li>rollouts status     - Show the status of a rollout</li> <li>rollouts terminate   - Terminate an AnalysisRun or Experiment</li> <li>rollouts undo     - Undo a rollout</li> <li>rollouts version   - Print version</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/","title":"Rollouts Abort","text":"<p>Abort a rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#synopsis","title":"Synopsis","text":"<p>This command stops progressing the current rollout and reverts all steps. The previous ReplicaSet will be active.</p> <p>Note the 'spec.template' still represents the new rollout version. If the Rollout leaves the aborted state, it will try to go to the new version.  Updating the 'spec.template' back to the previous version will fully revert the rollout.</p> <pre><code>kubectl argo rollouts abort ROLLOUT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#examples","title":"Examples","text":"<pre><code># Abort a rollout\nkubectl argo rollouts abort guestbook\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#options","title":"Options","text":"<pre><code>  -h, --help   help for abort\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_abort/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_completion/","title":"Rollouts Completion","text":"<p>Generate completion script</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_completion/#synopsis","title":"Synopsis","text":"<p>To load completions:</p> <pre><code>Bash:\n\n  $ source &lt;(yourprogram completion bash)\n\n  # To load completions for each session, execute once:\n  # Linux:\n  $ yourprogram completion bash &gt; /etc/bash_completion.d/yourprogram\n  # macOS:\n  $ yourprogram completion bash &gt; /usr/local/etc/bash_completion.d/yourprogram\n\nZsh:\n\n  # If shell completion is not already enabled in your environment,\n  # you will need to enable it.  You can execute the following once:\n\n  $ echo \"autoload -U compinit; compinit\" &gt;&gt; ~/.zshrc\n\n  # To load completions for each session, execute once:\n  $ yourprogram completion zsh &gt; \"${fpath[1]}/_yourprogram\"\n\n  # You will need to start a new shell for this setup to take effect.\n\nfish:\n\n  $ yourprogram completion fish | source\n\n  # To load completions for each session, execute once:\n  $ yourprogram completion fish &gt; ~/.config/fish/completions/yourprogram.fish\n\nPowerShell:\n\n  PS&gt; yourprogram completion powershell | Out-String | Invoke-Expression\n\n  # To load completions for every new session, run:\n  PS&gt; yourprogram completion powershell &gt; yourprogram.ps1\n  # and source this file from your PowerShell profile.\n</code></pre> <pre><code>kubectl argo rollouts completion [bash|zsh|fish|powershell]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_completion/#options","title":"Options","text":"<pre><code>  -h, --help   help for completion\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_completion/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_completion/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/","title":"Rollouts Create","text":"<p>Create a Rollout, Experiment, AnalysisTemplate, ClusterAnalysisTemplate, or AnalysisRun resource</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#synopsis","title":"Synopsis","text":"<p>This command creates a new Rollout, Experiment, AnalysisTemplate, ClusterAnalysisTemplate, or AnalysisRun resource from a file.</p> <pre><code>kubectl argo rollouts create [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#examples","title":"Examples","text":"<pre><code># Create an experiment and watch it\nkubectl argo rollouts create -f my-experiment.yaml -w\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#options","title":"Options","text":"<pre><code>  -f, --filename stringArray   Files to use to create the resource\n  -h, --help                   help for create\n      --no-color               Do not colorize output\n  -w, --watch                  Watch live updates to the resource after creating\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts create analysisrun     - Create an AnalysisRun from an AnalysisTemplate or a ClusterAnalysisTemplate</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/","title":"Rollouts Create Analysisrun","text":"<p>Create an AnalysisRun from an AnalysisTemplate or a ClusterAnalysisTemplate</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#synopsis","title":"Synopsis","text":"<p>This command creates a new AnalysisRun from an existing AnalysisTemplate resources or from an AnalysisTemplate file.</p> <pre><code>kubectl argo rollouts create analysisrun [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#examples","title":"Examples","text":"<pre><code># Create an AnalysisRun from a local AnalysisTemplate file\nkubectl argo rollouts create analysisrun --from-file my-analysis-template.yaml\n\n# Create an AnalysisRun from a AnalysisTemplate in the cluster\nkubectl argo rollouts create analysisrun --from my-analysis-template\n\n# Create an AnalysisRun from a local ClusterAnalysisTemplate file\nkubectl argo rollouts create analysisrun --global --from my-analysis-cluster-template.yaml\n\n# Create an AnalysisRun from a ClusterAnalysisTemplate in the cluster\nkubectl argo rollouts create analysisrun --global --from my-analysis-cluster-template\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#options","title":"Options","text":"<pre><code>  -a, --argument stringArray   Arguments to the parameter template\n      --from string            Create an AnalysisRun from an AnalysisTemplate or ClusterAnalysisTemplate in the cluster\n      --from-file string       Create an AnalysisRun from an AnalysisTemplate or ClusterAnalysisTemplate in a local file\n      --generate-name string   Use the specified generateName for the run\n      --global                 Use a ClusterAnalysisTemplate instead of a AnalysisTemplate\n  -h, --help                   help for analysisrun\n      --instance-id string     Instance-ID for the AnalysisRun\n      --name string            Use the specified name for the run\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_create_analysisrun/#see-also","title":"See Also","text":"<ul> <li>rollouts create     - Create a Rollout, Experiment, AnalysisTemplate, ClusterAnalysisTemplate, or AnalysisRun resource</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_dashboard/","title":"Rollouts Dashboard","text":"<p>Start UI dashboard</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_dashboard/#synopsis","title":"Synopsis","text":"<p>Start UI dashboard</p> <pre><code>kubectl argo rollouts dashboard [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_dashboard/#examples","title":"Examples","text":"<pre><code># Start UI dashboard\nkubectl argo rollouts dashboard\n\n# Start UI dashboard on a specific port\nkubectl argo rollouts dashboard --port 8080\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_dashboard/#options","title":"Options","text":"<pre><code>  -h, --help               help for dashboard\n  -p, --port int           port to listen on (default 3100)\n      --root-path string   changes the root path of the dashboard (default \"rollouts\")\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_dashboard/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_dashboard/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/","title":"Rollouts Get","text":"<p>Get details about rollouts and experiments</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands which can be used to get extended information about a rollout or experiment.</p> <pre><code>kubectl argo rollouts get &lt;rollout|experiment&gt; RESOURCE_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#examples","title":"Examples","text":"<pre><code># Get a rollout\nkubectl argo rollouts get rollout guestbook\n\n# Watch a rollouts progress\nkubectl argo rollouts get rollout guestbook -w\n\n# Get an experiment\nkubectl argo rollouts get experiment my-experiment\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#options","title":"Options","text":"<pre><code>  -h, --help   help for get\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts get experiment     - Get details about an Experiment</li> <li>rollouts get rollout   - Get details about a rollout</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/","title":"Rollouts Get Experiment","text":"<p>Get details about an Experiment</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#synopsis","title":"Synopsis","text":"<p>Get details about and visual representation of a experiment. It returns a bunch of metadata on a resource and a tree view of the child resources created by the parent.</p> <p>Tree view icons</p> Icon Kind \u27f3 Rollout \u03a3 Experiment \u03b1 AnalysisRun # Revision \u29c9 ReplicaSet \u25a1 Pod \u229e Job <pre><code>kubectl argo rollouts get experiment EXPERIMENT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#examples","title":"Examples","text":"<pre><code># Get an experiment\nkubectl argo rollouts get experiment my-experiment\n\n# Watch experiment progress\nkubectl argo rollouts get experiment my-experiment -w\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#options","title":"Options","text":"<pre><code>  -h, --help       help for experiment\n      --no-color   Do not colorize output\n  -w, --watch      Watch live updates to the rollout\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_experiment/#see-also","title":"See Also","text":"<ul> <li>rollouts get   - Get details about rollouts and experiments</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/","title":"Rollouts Get Rollout","text":"<p>Get details about a rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#synopsis","title":"Synopsis","text":"<p>Get details about and visual representation of a rollout. It returns a bunch of metadata on a resource and a tree view of the child resources created by the parent.</p> <p>Tree view icons</p> Icon Kind \u27f3 Rollout \u03a3 Experiment \u03b1 AnalysisRun # Revision \u29c9 ReplicaSet \u25a1 Pod \u229e Job <pre><code>kubectl argo rollouts get rollout ROLLOUT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#examples","title":"Examples","text":"<pre><code># Get a rollout\nkubectl argo rollouts get rollout guestbook\n\n# Watch progress of a rollout\nkubectl argo rollouts get rollout guestbook -w\n\n# Watch the rollout, fail if it takes more than 60 seconds\nkubectl argo rollouts get rollout guestbook -w --timeout-seconds 60\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#options","title":"Options","text":"<pre><code>  -h, --help                  help for rollout\n      --no-color              Do not colorize output\n      --timeout-seconds int   Timeout after specified seconds\n  -w, --watch                 Watch live updates to the rollout\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_get_rollout/#see-also","title":"See Also","text":"<ul> <li>rollouts get   - Get details about rollouts and experiments</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_lint/","title":"Rollouts Lint","text":"<p>Lint and validate a Rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_lint/#synopsis","title":"Synopsis","text":"<p>This command lints and validates a new Rollout resource from a file.</p> <pre><code>kubectl argo rollouts lint [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_lint/#examples","title":"Examples","text":"<pre><code># Lint a rollout\nkubectl argo rollouts lint -f my-rollout.yaml\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_lint/#options","title":"Options","text":"<pre><code>  -f, --filename string   File to lint\n  -h, --help              help for lint\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_lint/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_lint/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/","title":"Rollouts List","text":"<p>List rollouts or experiments</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands which can be used to lists all of the  rollouts or experiments for a specified namespace (uses current namespace context if namespace not specified).</p> <pre><code>kubectl argo rollouts list &lt;rollout|experiment&gt; [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#examples","title":"Examples","text":"<pre><code># List rollouts\nkubectl argo rollouts list rollouts\n\n# List experiments\nkubectl argo rollouts list experiments\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#options","title":"Options","text":"<pre><code>  -h, --help   help for list\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts list experiments     - List experiments</li> <li>rollouts list rollouts   - List rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/","title":"Rollouts List Experiments","text":"<p>List experiments</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#synopsis","title":"Synopsis","text":"<p>This command lists all of the experiments for a specified namespace (uses current namespace context if namespace not specified).</p> <pre><code>kubectl argo rollouts list experiments [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#examples","title":"Examples","text":"<pre><code># List rollouts\nkubectl argo rollouts list experiments\n\n# List rollouts from all namespaces\nkubectl argo rollouts list experiments --all-namespaces\n\n# List rollouts and watch for changes\nkubectl argo rollouts list experiments --watch\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#options","title":"Options","text":"<pre><code>  -A, --all-namespaces   Include all namespaces\n  -h, --help             help for experiments\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_experiments/#see-also","title":"See Also","text":"<ul> <li>rollouts list     - List rollouts or experiments</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/","title":"Rollouts List Rollouts","text":"<p>List rollouts</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#synopsis","title":"Synopsis","text":"<p>This command lists all of the rollouts for a specified namespace (uses current namespace context if namespace not specified).</p> <pre><code>kubectl argo rollouts list rollouts [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#examples","title":"Examples","text":"<pre><code># List rollouts\nkubectl argo rollouts list rollouts\n\n# List rollouts with a specific name\nkubectl argo rollouts list rollouts --name my-rollout\n\n# List rollouts from all namespaces\nkubectl argo rollouts list rollouts --all-namespaces\n\n# List rollouts and watch for changes\nkubectl argo rollouts list rollouts --watch\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#options","title":"Options","text":"<pre><code>  -A, --all-namespaces   Include all namespaces\n  -h, --help             help for rollouts\n      --name string      Only show rollout with specified name\n      --timestamps       Print timestamps on updates\n  -w, --watch            Watch for changes\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_list_rollouts/#see-also","title":"See Also","text":"<ul> <li>rollouts list     - List rollouts or experiments</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications/","title":"Rollouts Notifications","text":"<p>Set of CLI commands that helps manage notifications settings</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications/#synopsis","title":"Synopsis","text":"<p>Set of CLI commands that helps manage notifications settings</p> <pre><code>kubectl argo rollouts notifications [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications/#options","title":"Options","text":"<pre><code>      --as string                      Username to impersonate for the operation\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --config-map string              argo-rollouts-notification-configmap.yaml file path\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n  -h, --help                           help for notifications\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n      --kubeconfig string              Path to a kube config. Only required if out-of-cluster\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --password string                Password for basic authentication to the API server\n      --proxy-url string               If provided, this URL will be used to connect via proxy\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n      --secret string                  argo-rollouts-notification-secret.yaml file path. Use empty secret if provided value is ':empty'\n      --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n      --username string                Username for basic authentication to the API server\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --cache-dir string   Default cache directory (default \"$HOME/.kube/cache\")\n  -v, --kloglevel int      Log level for kubernetes client library\n      --loglevel string    Log level for kubectl argo rollouts (default \"info\")\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts notifications template     - Notification templates related commands</li> <li>rollouts notifications trigger   - Notification triggers related commands</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template/","title":"Rollouts Notifications Template","text":"<p>Notification templates related commands</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template/#synopsis","title":"Synopsis","text":"<p>Notification templates related commands</p> <pre><code>kubectl argo rollouts notifications template [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template/#options","title":"Options","text":"<pre><code>  -h, --help   help for template\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --config-map string              argo-rollouts-notification-configmap.yaml file path\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to a kube config. Only required if out-of-cluster\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --password string                Password for basic authentication to the API server\n      --proxy-url string               If provided, this URL will be used to connect via proxy\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n      --secret string                  argo-rollouts-notification-secret.yaml file path. Use empty secret if provided value is ':empty'\n      --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n      --username string                Username for basic authentication to the API server\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts notifications template get     - Prints information about configured templates</li> <li>rollouts notifications template notify   - Generates notification using the specified template and send it to specified recipients</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template/#see-also","title":"See Also","text":"<ul> <li>rollouts notifications   - Set of CLI commands that helps manage notifications settings</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_get/","title":"Rollouts Notifications Template Get","text":"<p>Prints information about configured templates</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_get/#synopsis","title":"Synopsis","text":"<p>Prints information about configured templates</p> <pre><code>kubectl argo rollouts notifications template get [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_get/#examples","title":"Examples","text":"<pre><code># prints all templates\nkubectl argo rollouts notifications template get\n# print YAML formatted app-sync-succeeded template definition\nkubectl argo rollouts notifications template get app-sync-succeeded -o=yaml\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_get/#options","title":"Options","text":"<pre><code>  -h, --help            help for get\n  -o, --output string   Output format. One of:json|yaml|wide|name (default \"wide\")\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_get/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --config-map string              argo-rollouts-notification-configmap.yaml file path\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to a kube config. Only required if out-of-cluster\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --password string                Password for basic authentication to the API server\n      --proxy-url string               If provided, this URL will be used to connect via proxy\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n      --secret string                  argo-rollouts-notification-secret.yaml file path. Use empty secret if provided value is ':empty'\n      --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n      --username string                Username for basic authentication to the API server\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_get/#see-also","title":"See Also","text":"<ul> <li>rollouts notifications template     - Notification templates related commands</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_notify/","title":"Rollouts Notifications Template Notify","text":"<p>Generates notification using the specified template and send it to specified recipients</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_notify/#synopsis","title":"Synopsis","text":"<p>Generates notification using the specified template and send it to specified recipients</p> <pre><code>kubectl argo rollouts notifications template notify NAME RESOURCE_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_notify/#examples","title":"Examples","text":"<pre><code># Trigger notification using in-cluster config map and secret\nkubectl argo rollouts notifications template notify app-sync-succeeded guestbook --recipient slack:my-slack-channel\n\n# Render notification render generated notification in console\nkubectl argo rollouts notifications template notify app-sync-succeeded guestbook\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_notify/#options","title":"Options","text":"<pre><code>  -h, --help                    help for notify\n      --recipient stringArray   List of recipients (default [console:stdout])\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_notify/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --config-map string              argo-rollouts-notification-configmap.yaml file path\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to a kube config. Only required if out-of-cluster\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --password string                Password for basic authentication to the API server\n      --proxy-url string               If provided, this URL will be used to connect via proxy\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n      --secret string                  argo-rollouts-notification-secret.yaml file path. Use empty secret if provided value is ':empty'\n      --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n      --username string                Username for basic authentication to the API server\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_template_notify/#see-also","title":"See Also","text":"<ul> <li>rollouts notifications template     - Notification templates related commands</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger/","title":"Rollouts Notifications Trigger","text":"<p>Notification triggers related commands</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger/#synopsis","title":"Synopsis","text":"<p>Notification triggers related commands</p> <pre><code>kubectl argo rollouts notifications trigger [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger/#options","title":"Options","text":"<pre><code>  -h, --help   help for trigger\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --config-map string              argo-rollouts-notification-configmap.yaml file path\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to a kube config. Only required if out-of-cluster\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --password string                Password for basic authentication to the API server\n      --proxy-url string               If provided, this URL will be used to connect via proxy\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n      --secret string                  argo-rollouts-notification-secret.yaml file path. Use empty secret if provided value is ':empty'\n      --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n      --username string                Username for basic authentication to the API server\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts notifications trigger get   - Prints information about configured triggers</li> <li>rollouts notifications trigger run   - Evaluates specified trigger condition and prints the result</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger/#see-also","title":"See Also","text":"<ul> <li>rollouts notifications   - Set of CLI commands that helps manage notifications settings</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_get/","title":"Rollouts Notifications Trigger Get","text":"<p>Prints information about configured triggers</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_get/#synopsis","title":"Synopsis","text":"<p>Prints information about configured triggers</p> <pre><code>kubectl argo rollouts notifications trigger get [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_get/#examples","title":"Examples","text":"<pre><code># prints all triggers\nkubectl argo rollouts notifications trigger get\n# print YAML formatted on-sync-failed trigger definition\nkubectl argo rollouts notifications trigger get on-sync-failed -o=yaml\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_get/#options","title":"Options","text":"<pre><code>  -h, --help            help for get\n  -o, --output string   Output format. One of:json|yaml|wide|name (default \"wide\")\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_get/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --config-map string              argo-rollouts-notification-configmap.yaml file path\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to a kube config. Only required if out-of-cluster\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --password string                Password for basic authentication to the API server\n      --proxy-url string               If provided, this URL will be used to connect via proxy\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n      --secret string                  argo-rollouts-notification-secret.yaml file path. Use empty secret if provided value is ':empty'\n      --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n      --username string                Username for basic authentication to the API server\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_get/#see-also","title":"See Also","text":"<ul> <li>rollouts notifications trigger   - Notification triggers related commands</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_run/","title":"Rollouts Notifications Trigger Run","text":"<p>Evaluates specified trigger condition and prints the result</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_run/#synopsis","title":"Synopsis","text":"<p>Evaluates specified trigger condition and prints the result</p> <pre><code>kubectl argo rollouts notifications trigger run NAME RESOURCE_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_run/#examples","title":"Examples","text":"<pre><code># Execute trigger configured in 'argocd-notification-cm' ConfigMap\nkubectl argo rollouts notifications trigger run on-sync-status-unknown ./sample-app.yaml\n\n# Execute trigger using my-config-map.yaml instead of 'argo-rollouts-notification-configmap' ConfigMap\nkubectl argo rollouts notifications trigger run on-sync-status-unknown ./sample-app.yaml \\\n--config-map ./my-config-map.yaml\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_run/#options","title":"Options","text":"<pre><code>  -h, --help   help for run\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_run/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --config-map string              argo-rollouts-notification-configmap.yaml file path\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to a kube config. Only required if out-of-cluster\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --password string                Password for basic authentication to the API server\n      --proxy-url string               If provided, this URL will be used to connect via proxy\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n      --secret string                  argo-rollouts-notification-secret.yaml file path. Use empty secret if provided value is ':empty'\n      --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         If provided, this name will be used to validate server certificate. If this is not provided, hostname used to contact the server is used.\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n      --username string                Username for basic authentication to the API server\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_notifications_trigger_run/#see-also","title":"See Also","text":"<ul> <li>rollouts notifications trigger   - Notification triggers related commands</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/","title":"Rollouts Pause","text":"<p>Pause a rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#synopsis","title":"Synopsis","text":"<p>Set the rollout paused state to 'true'</p> <pre><code>kubectl argo rollouts pause ROLLOUT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#examples","title":"Examples","text":"<pre><code># Pause a rollout\nkubectl argo rollouts pause guestbook\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#options","title":"Options","text":"<pre><code>  -h, --help   help for pause\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_pause/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/","title":"Rollouts Promote","text":"<p>Promote a rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#synopsis","title":"Synopsis","text":"<p>Promote a rollout</p> <p>Promotes a rollout paused at a canary step, or a paused blue-green pre-promotion. To skip analysis, pauses and steps entirely, use '--full' to fully promote the rollout</p> <pre><code>kubectl argo rollouts promote ROLLOUT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#examples","title":"Examples","text":"<pre><code># Promote a paused rollout\nkubectl argo rollouts promote guestbook\n\n# Fully promote a rollout to desired version, skipping analysis, pauses, and steps\nkubectl argo rollouts promote guestbook --full\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#options","title":"Options","text":"<pre><code>      --full   Perform a full promotion, skipping analysis, pauses, and steps\n  -h, --help   help for promote\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_promote/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/","title":"Rollouts Restart","text":"<p>Restart the pods of a rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#synopsis","title":"Synopsis","text":"<p>Restart the pods of a rollout</p> <pre><code>kubectl argo rollouts restart ROLLOUT [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#examples","title":"Examples","text":"<pre><code># Restart the pods of a rollout in now\nkubectl argo rollouts restart ROLLOUT_NAME\n\n# Restart the pods of a rollout in ten seconds\nkubectl argo rollouts restart ROLLOUT_NAME --in 10s\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#options","title":"Options","text":"<pre><code>  -h, --help        help for restart\n  -i, --in string   Amount of time before a restart. (e.g. 30s, 5m, 1h)\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_restart/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/","title":"Rollouts Retry","text":"<p>Retry a rollout or experiment</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands which can be used to restart an aborted rollout or a failed experiment.</p> <pre><code>kubectl argo rollouts retry &lt;rollout|experiment&gt; RESOURCE_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#examples","title":"Examples","text":"<pre><code># Retry an aborted rollout\nkubectl argo rollouts retry rollout guestbook\n\n# Retry a failed experiment\nkubectl argo rollouts retry experiment my-experiment\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#options","title":"Options","text":"<pre><code>  -h, --help   help for retry\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts retry experiment     - Retry an experiment</li> <li>rollouts retry rollout   - Retry an aborted rollout</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/","title":"Rollouts Retry Experiment","text":"<p>Retry an experiment</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#synopsis","title":"Synopsis","text":"<p>Retry a failed experiment.</p> <pre><code>kubectl argo rollouts retry experiment EXPERIMENT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#examples","title":"Examples","text":"<pre><code># Retry an experiment\nkubectl argo rollouts retry experiment my-experiment\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#options","title":"Options","text":"<pre><code>  -h, --help   help for experiment\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_experiment/#see-also","title":"See Also","text":"<ul> <li>rollouts retry   - Retry a rollout or experiment</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/","title":"Rollouts Retry Rollout","text":"<p>Retry an aborted rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#synopsis","title":"Synopsis","text":"<p>Retry an aborted rollout</p> <pre><code>kubectl argo rollouts retry rollout ROLLOUT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#examples","title":"Examples","text":"<pre><code># Retry an aborted rollout\nkubectl argo rollouts retry rollout guestbook\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#options","title":"Options","text":"<pre><code>  -h, --help   help for rollout\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_retry_rollout/#see-also","title":"See Also","text":"<ul> <li>rollouts retry   - Retry a rollout or experiment</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/","title":"Rollouts Set","text":"<p>Update various values on resources</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands which can be used to update rollout resources.</p> <pre><code>kubectl argo rollouts set COMMAND [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#examples","title":"Examples","text":"<pre><code># Set rollout image\nkubectl argo rollouts set image my-rollout demo=argoproj/rollouts-demo:yellow\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#options","title":"Options","text":"<pre><code>  -h, --help   help for set\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts set image   - Update the image of a rollout</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/","title":"Rollouts Set Image","text":"<p>Update the image of a rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#synopsis","title":"Synopsis","text":"<p>Update the image of a rollout</p> <pre><code>kubectl argo rollouts set image ROLLOUT_NAME CONTAINER=IMAGE [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#examples","title":"Examples","text":"<pre><code># Set rollout image (containers contains 'initContainer', 'container', 'ephemeralContainer')\nkubectl argo rollouts set image my-rollout containerName=imageName\n\n# Set rollout image for all containers\nkubectl argo rollouts set image my-rollout *=imageName\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#options","title":"Options","text":"<pre><code>  -h, --help   help for image\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_set_image/#see-also","title":"See Also","text":"<ul> <li>rollouts set   - Update various values on resources</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_status/","title":"Rollouts Status","text":"<p>Show the status of a rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_status/#synopsis","title":"Synopsis","text":"<p>Watch rollout until it finishes or the timeout is exceeded. Returns success if the rollout is healthy upon completion and an error otherwise.</p> <pre><code>kubectl argo rollouts status ROLLOUT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_status/#examples","title":"Examples","text":"<pre><code># Watch the rollout until it succeeds\nkubectl argo rollouts status guestbook\n\n# Show the rollout status\nkubectl argo rollouts status guestbook --watch false\n\n# Watch the rollout until it succeeds, fail if it takes more than 60 seconds\nkubectl argo rollouts status --timeout 60s guestbook\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_status/#options","title":"Options","text":"<pre><code>  -h, --help               help for status\n  -t, --timeout duration   The length of time to watch before giving up. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). Zero means wait forever\n  -w, --watch              Watch the status of the rollout until it's done (default true)\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_status/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_status/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/","title":"Rollouts Terminate","text":"<p>Terminate an AnalysisRun or Experiment</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#synopsis","title":"Synopsis","text":"<p>This command consists of multiple subcommands which can be used to terminate an AnalysisRun or Experiment that is in progress.</p> <pre><code>kubectl argo rollouts terminate &lt;analysisrun|experiment&gt; RESOURCE_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#examples","title":"Examples","text":"<pre><code># Terminate an AnalysisRun\nkubectl argo rollouts terminate analysisrun guestbook-877894d5b-4-success-rate.1\n\n# Terminate a failed experiment\nkubectl argo rollouts terminate experiment my-experiment\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#options","title":"Options","text":"<pre><code>  -h, --help   help for terminate\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#available-commands","title":"Available Commands","text":"<ul> <li>rollouts terminate analysisrun   - Terminate an AnalysisRun</li> <li>rollouts terminate experiment     - Terminate an experiment</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/","title":"Rollouts Terminate Analysisrun","text":"<p>Terminate an AnalysisRun</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#synopsis","title":"Synopsis","text":"<p>This command terminates an AnalysisRun.</p> <pre><code>kubectl argo rollouts terminate analysisrun ANALYSISRUN_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#examples","title":"Examples","text":"<pre><code># Terminate an AnalysisRun\nkubectl argo rollouts terminate analysisrun guestbook-877894d5b-4-success-rate.1\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#options","title":"Options","text":"<pre><code>  -h, --help   help for analysisrun\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_analysisrun/#see-also","title":"See Also","text":"<ul> <li>rollouts terminate   - Terminate an AnalysisRun or Experiment</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/","title":"Rollouts Terminate Experiment","text":"<p>Terminate an experiment</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#synopsis","title":"Synopsis","text":"<p>This command terminates an Experiment.</p> <pre><code>kubectl argo rollouts terminate experiment EXPERIMENT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#examples","title":"Examples","text":"<pre><code># Terminate an experiment\nkubectl argo rollouts terminate experiment my-experiment\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#options","title":"Options","text":"<pre><code>  -h, --help   help for experiment\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_terminate_experiment/#see-also","title":"See Also","text":"<ul> <li>rollouts terminate   - Terminate an AnalysisRun or Experiment</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_undo/","title":"Rollouts Undo","text":"<p>Undo a rollout</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_undo/#synopsis","title":"Synopsis","text":"<p>Rollback to the previous rollout.</p> <pre><code>kubectl argo rollouts undo ROLLOUT_NAME [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_undo/#examples","title":"Examples","text":"<pre><code># Undo a rollout\nkubectl argo rollouts undo guestbook\n\n# Undo a rollout to revision 3\nkubectl argo rollouts undo guestbook --to-revision=3\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_undo/#options","title":"Options","text":"<pre><code>  -h, --help              help for undo\n      --to-revision int   The revision to rollback to. Default to 0 (last revision).\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_undo/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_undo/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/","title":"Rollouts Version","text":"<p>Print version</p>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#synopsis","title":"Synopsis","text":"<p>Show the version and build information of the Argo Rollouts plugin.</p> <pre><code>kubectl argo rollouts version [flags]\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#examples","title":"Examples","text":"<pre><code># Get full version info\nkubectl argo rollouts version\n\n# Get just plugin version number\nkubectl argo rollouts version --short\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#options","title":"Options","text":"<pre><code>  -h, --help    help for version\n      --short   print just the version number\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#options-inherited-from-parent-commands","title":"Options inherited from parent commands","text":"<pre><code>      --as string                      Username to impersonate for the operation. User could be a regular user or a service account in a namespace.\n      --as-group stringArray           Group to impersonate for the operation, this flag can be repeated to specify multiple groups.\n      --as-uid string                  UID to impersonate for the operation.\n      --cache-dir string               Default cache directory (default \"$HOME/.kube/cache\")\n      --certificate-authority string   Path to a cert file for the certificate authority\n      --client-certificate string      Path to a client certificate file for TLS\n      --client-key string              Path to a client key file for TLS\n      --cluster string                 The name of the kubeconfig cluster to use\n      --context string                 The name of the kubeconfig context to use\n      --disable-compression            If true, opt-out of response compression for all requests to the server\n      --insecure-skip-tls-verify       If true, the server's certificate will not be checked for validity. This will make your HTTPS connections insecure\n  -v, --kloglevel int                  Log level for kubernetes client library\n      --kubeconfig string              Path to the kubeconfig file to use for CLI requests.\n      --loglevel string                Log level for kubectl argo rollouts (default \"info\")\n  -n, --namespace string               If present, the namespace scope for this CLI request\n      --request-timeout string         The length of time to wait before giving up on a single server request. Non-zero values should contain a corresponding time unit (e.g. 1s, 2m, 3h). A value of zero means don't timeout requests. (default \"0\")\n  -s, --server string                  The address and port of the Kubernetes API server\n      --tls-server-name string         Server name to use for server certificate validation. If it is not provided, the hostname used to contact the server is used\n      --token string                   Bearer token for authentication to the API server\n      --user string                    The name of the kubeconfig user to use\n</code></pre>"},{"location":"generated/kubectl-argo-rollouts/kubectl-argo-rollouts_version/#see-also","title":"See Also","text":"<ul> <li>rollouts   - Manage argo rollouts</li> </ul>"},{"location":"generated/notification-services/alertmanager/","title":"Alertmanager","text":""},{"location":"generated/notification-services/alertmanager/#parameters","title":"Parameters","text":"<p>The notification service is used to push events to Alertmanager, and the following settings need to be specified:</p> <ul> <li><code>targets</code> - the alertmanager service address, array type</li> <li><code>scheme</code> - optional, default is \"http\", e.g. http or https</li> <li><code>apiPath</code> - optional, default is \"/api/v2/alerts\"</li> <li><code>insecureSkipVerify</code> - optional, default is \"false\", when scheme is https whether to skip the verification of ca</li> <li><code>basicAuth</code> - optional, server auth</li> <li><code>bearerToken</code> - optional, server auth</li> <li><code>timeout</code> - optional, the timeout in seconds used when sending alerts, default is \"3 seconds\"</li> </ul> <p><code>basicAuth</code> or <code>bearerToken</code> is used for authentication, you can choose one. If the two are set at the same time, <code>basicAuth</code> takes precedence over <code>bearerToken</code>.</p>"},{"location":"generated/notification-services/alertmanager/#example","title":"Example","text":""},{"location":"generated/notification-services/alertmanager/#prometheus-alertmanager-config","title":"Prometheus Alertmanager config","text":"<pre><code>global:\n  resolve_timeout: 5m\n\nroute:\n  group_by: ['alertname']\n  group_wait: 10s\n  group_interval: 10s\n  repeat_interval: 1h\n  receiver: 'default'\nreceivers:\n- name: 'default'\n  webhook_configs:\n  - send_resolved: false\n    url: 'http://10.5.39.39:10080/api/alerts/webhook'\n</code></pre> <p>You should turn off \"send_resolved\" or you will receive unnecessary recovery notifications after \"resolve_timeout\".</p>"},{"location":"generated/notification-services/alertmanager/#send-one-alertmanager-without-auth","title":"Send one alertmanager without auth","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.alertmanager: |\n    targets:\n    - 10.5.39.39:9093\n</code></pre>"},{"location":"generated/notification-services/alertmanager/#send-alertmanager-cluster-with-custom-api-path","title":"Send alertmanager cluster with custom api path","text":"<p>If your alertmanager has changed the default api, you can customize \"apiPath\".</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.alertmanager: |\n    targets:\n    - 10.5.39.39:443\n    scheme: https\n    apiPath: /api/events\n    insecureSkipVerify: true\n</code></pre>"},{"location":"generated/notification-services/alertmanager/#send-high-availability-alertmanager-with-auth","title":"Send high availability alertmanager with auth","text":"<p>Store auth token in <code>argo-rollouts-notification-secret</code> Secret and use configure in <code>argo-rollouts-notification-configmap</code> ConfigMap.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  alertmanager-username: &lt;username&gt;\n  alertmanager-password: &lt;password&gt;\n  alertmanager-bearer-token: &lt;token&gt;\n</code></pre> <ul> <li>with basicAuth</li> </ul> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.alertmanager: |\n    targets:\n    - 10.5.39.39:19093\n    - 10.5.39.39:29093\n    - 10.5.39.39:39093\n    scheme: https\n    apiPath: /api/v2/alerts\n    insecureSkipVerify: true\n    basicAuth:\n      username: $alertmanager-username\n      password: $alertmanager-password   \n</code></pre> <ul> <li>with bearerToken</li> </ul> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.alertmanager: |\n    targets:\n    - 10.5.39.39:19093\n    - 10.5.39.39:29093\n    - 10.5.39.39:39093\n    scheme: https\n    apiPath: /api/v2/alerts\n    insecureSkipVerify: true\n    bearerToken: $alertmanager-bearer-token\n</code></pre>"},{"location":"generated/notification-services/alertmanager/#templates","title":"Templates","text":"<ul> <li><code>labels</code> - at least one label pair required, implement different notification strategies according to alertmanager routing</li> <li><code>annotations</code> - optional, specifies a set of information labels, which can be used to store longer additional information, but only for display</li> <li><code>generatorURL</code> - optional, default is '{{.app.spec.source.repoURL}}', backlink used to identify the entity that caused this alert in the client</li> </ul> <p>the <code>label</code> or <code>annotations</code> or <code>generatorURL</code> values can be templated.</p> <pre><code>context: |\n  argocdUrl: https://example.com/argocd\n\ntemplate.app-deployed: |\n  message: Application {{.app.metadata.name}} has been healthy.\n  alertmanager:\n    labels:\n      fault_priority: \"P5\"\n      event_bucket: \"deploy\"\n      event_status: \"succeed\"\n      recipient: \"{{.recipient}}\"\n    annotations:\n      application: '&lt;a href=\"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}\"&gt;{{.app.metadata.name}}&lt;/a&gt;'\n      author: \"{{(call .repo.GetCommitMetadata .app.status.sync.revision).Author}}\"\n      message: \"{{(call .repo.GetCommitMetadata .app.status.sync.revision).Message}}\"\n</code></pre> <p>You can do targeted push on Alertmanager according to labels.</p> <pre><code>template.app-deployed: |\n  message: Application {{.app.metadata.name}} has been healthy.\n  alertmanager:\n    labels:\n      alertname: app-deployed\n      fault_priority: \"P5\"\n      event_bucket: \"deploy\"\n</code></pre> <p>There is a special label <code>alertname</code>. If you don\u2019t set its value, it will be equal to the template name by default.</p>"},{"location":"generated/notification-services/awssqs/","title":"AWS SQS","text":""},{"location":"generated/notification-services/awssqs/#parameters","title":"Parameters","text":"<p>This notification service is capable of sending simple messages to AWS SQS queue.</p> <ul> <li><code>queue</code> - name of the queue you are intending to send messages to. Can be overridden with target destination annotation.</li> <li><code>region</code> - region of the sqs queue can be provided via env variable AWS_DEFAULT_REGION</li> <li><code>key</code> - optional, aws access key must be either referenced from a secret via variable or via env variable AWS_ACCESS_KEY_ID</li> <li><code>secret</code> - optional, aws access secret must be either referenced from a secret via variable or via env variable AWS_SECRET_ACCESS_KEY</li> <li><code>account</code> optional, external accountId of the queue</li> <li><code>endpointUrl</code> optional, useful for development with localstack</li> </ul>"},{"location":"generated/notification-services/awssqs/#example","title":"Example","text":""},{"location":"generated/notification-services/awssqs/#using-secret-for-credential-retrieval","title":"Using Secret for credential retrieval:","text":"<p>Resource Annotation: <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  annotations:\n    notifications.argoproj.io/subscribe.on-deployment-ready.awssqs: \"overwrite-myqueue\"\n</code></pre></p> <ul> <li>ConfigMap <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.awssqs: |\n    region: \"us-east-2\"\n    queue: \"myqueue\"\n    account: \"1234567\"\n    key: \"$awsaccess_key\"\n    secret: \"$awsaccess_secret\"\n\n  template.deployment-ready: |\n    message: |\n      Deployment {{.obj.metadata.name}} is ready!\n\n  trigger.on-deployment-ready: |\n    - when: any(obj.status.conditions, {.type == 'Available' &amp;&amp; .status == 'True'})\n      send: [deployment-ready]\n    - oncePer: obj.metadata.annotations[\"generation\"]\n</code></pre>  Secret <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  awsaccess_key: test\n  awsaccess_secret: test\n</code></pre></li> </ul>"},{"location":"generated/notification-services/awssqs/#minimal-configuration-using-aws-env-variables","title":"Minimal configuration using AWS Env variables","text":"<p>Ensure the following list of environment variables are injected via OIDC, or another method. And assuming SQS is local to the account. You may skip usage of secret for sensitive data and omit other parameters. (Setting parameters via ConfigMap takes precedent.)</p> <p>Variables:</p> <pre><code>export AWS_ACCESS_KEY_ID=\"test\"\nexport AWS_SECRET_ACCESS_KEY=\"test\"\nexport AWS_DEFAULT_REGION=\"us-east-1\"\n</code></pre> <p>Resource Annotation: <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  annotations:\n    notifications.argoproj.io/subscribe.on-deployment-ready.awssqs: \"\"\n</code></pre></p> <ul> <li>ConfigMap <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.awssqs: |\n    queue: \"myqueue\"\n\n  template.deployment-ready: |\n    message: |\n      Deployment {{.obj.metadata.name}} is ready!\n\n  trigger.on-deployment-ready: |\n    - when: any(obj.status.conditions, {.type == 'Available' &amp;&amp; .status == 'True'})\n      send: [deployment-ready]\n    - oncePer: obj.metadata.annotations[\"generation\"]\n</code></pre></li> </ul>"},{"location":"generated/notification-services/awssqs/#fifo-sqs-queues","title":"FIFO SQS Queues","text":"<p>FIFO queues require a MessageGroupId to be sent along with every message, every message with a matching MessageGroupId will be processed one by one in order.</p> <p>To send to a FIFO SQS Queue you must include a <code>messageGroupId</code> in the template such as in the example below:</p> <pre><code>template.deployment-ready: |\n  message: |\n    Deployment {{.obj.metadata.name}} is ready!\n  messageGroupId: {{.obj.metadata.name}}-deployment\n</code></pre>"},{"location":"generated/notification-services/email/","title":"Email","text":""},{"location":"generated/notification-services/email/#parameters","title":"Parameters","text":"<p>The Email notification service sends email notifications using SMTP protocol and requires specifying the following settings:</p> <ul> <li><code>host</code> - the SMTP server host name</li> <li><code>port</code> - the SMTP server port</li> <li><code>username</code> - username</li> <li><code>password</code> - password</li> <li><code>from</code> - from email address</li> <li><code>html</code> - optional bool, true or false</li> <li><code>insecure_skip_verify</code> - optional bool, true or false</li> </ul>"},{"location":"generated/notification-services/email/#example","title":"Example","text":"<p>The following snippet contains sample Gmail service configuration:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.email.gmail: |\n    username: $email-username\n    password: $email-password\n    host: smtp.gmail.com\n    port: 465\n    from: $email-username\n</code></pre> <p>Without authentication:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.email.example: |\n    host: smtp.example.com\n    port: 587\n    from: $email-username\n</code></pre>"},{"location":"generated/notification-services/email/#template","title":"Template","text":"<p>Notification templates support specifying subject for email notifications:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  template.app-sync-succeeded: |\n    email:\n      subject: Application {{.app.metadata.name}} has been successfully synced.\n    message: |\n      {{if eq .serviceType \"slack\"}}:white_check_mark:{{end}} Application {{.app.metadata.name}} has been successfully synced at {{.app.status.operationState.finishedAt}}.\n      Sync operation details are available at: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true .\n</code></pre>"},{"location":"generated/notification-services/github/","title":"GitHub","text":""},{"location":"generated/notification-services/github/#parameters","title":"Parameters","text":"<p>The GitHub notification service changes commit status using GitHub Apps and requires specifying the following settings:</p> <ul> <li><code>appID</code> - the app id</li> <li><code>installationID</code> - the app installation id</li> <li><code>privateKey</code> - the app private key</li> <li><code>enterpriseBaseURL</code> - optional URL, e.g. https://git.example.com/</li> </ul>"},{"location":"generated/notification-services/github/#configuration","title":"Configuration","text":"<ol> <li>Create a GitHub Apps using https://github.com/settings/apps/new</li> <li>Change repository permissions to enable write commit statuses and/or deployments and/or pull requests comments </li> <li>Generate a private key, and download it automatically </li> <li>Install app to account</li> <li>Store privateKey in <code>argo-rollouts-notification-secret</code> Secret and configure GitHub integration in <code>argo-rollouts-notification-configmap</code> ConfigMap</li> </ol> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.github: |\n    appID: &lt;app-id&gt;\n    installationID: &lt;installation-id&gt;\n    privateKey: $github-privateKey\n</code></pre> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  github-privateKey: |\n    -----BEGIN RSA PRIVATE KEY-----\n    (snip)\n    -----END RSA PRIVATE KEY-----\n</code></pre> <ol> <li>Create subscription for your GitHub integration</li> </ol> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.&lt;trigger-name&gt;.github: \"\"\n</code></pre>"},{"location":"generated/notification-services/github/#templates","title":"Templates","text":"<pre><code>template.app-deployed: |\n  message: |\n    Application {{.app.metadata.name}} is now running new version of deployments manifests.\n  github:\n    repoURLPath: \"{{.app.spec.source.repoURL}}\"\n    revisionPath: \"{{.app.status.operationState.syncResult.revision}}\"\n    status:\n      state: success\n      label: \"continuous-delivery/{{.app.metadata.name}}\"\n      targetURL: \"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true\"\n    deployment:\n      state: success\n      environment: production\n      environmentURL: \"https://{{.app.metadata.name}}.example.com\"\n      logURL: \"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true\"\n      requiredContexts: []\n      autoMerge: true\n      transientEnvironment: false\n    pullRequestComment:\n      content: |\n        Application {{.app.metadata.name}} is now running new version of deployments manifests.\n        See more here: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true\n</code></pre> <p>Notes: - If the message is set to 140 characters or more, it will be truncated. - If <code>github.repoURLPath</code> and <code>github.revisionPath</code> are same as above, they can be omitted. - Automerge is optional and <code>true</code> by default for github deployments to ensure the requested ref is up to date with the default branch.   Setting this option to <code>false</code> is required if you would like to deploy older refs in your default branch.   For more information see the GitHub Deployment API Docs. - If <code>github.pullRequestComment.content</code> is set to 65536 characters or more, it will be truncated.</p>"},{"location":"generated/notification-services/googlechat/","title":"Google Chat","text":""},{"location":"generated/notification-services/googlechat/#parameters","title":"Parameters","text":"<p>The Google Chat notification service send message notifications to a google chat webhook. This service uses the following settings:</p> <ul> <li><code>webhooks</code> - a map of the form <code>webhookName: webhookUrl</code></li> </ul>"},{"location":"generated/notification-services/googlechat/#configuration","title":"Configuration","text":"<ol> <li>Open <code>Google chat</code> and go to the space to which you want to send messages</li> <li>From the menu at the top of the page, select Configure Webhooks</li> <li>Under Incoming Webhooks, click Add Webhook</li> <li>Give a name to the webhook, optionally add an image and click Save</li> <li>Copy the URL next to your webhook</li> <li>Store the URL in <code>argocd-notification-secret</code> and declare it in <code>argo-rollouts-notification-configmap</code></li> </ol> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.googlechat: |\n    webhooks:\n      spaceName: $space-webhook-url\n</code></pre> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  space-webhook-url: https://chat.googleapis.com/v1/spaces/&lt;space_id&gt;/messages?key=&lt;key&gt;&amp;token=&lt;token&gt;  \n</code></pre> <ol> <li>Create a subscription for your space</li> </ol> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-sync-succeeded.googlechat: spaceName\n</code></pre>"},{"location":"generated/notification-services/googlechat/#templates","title":"Templates","text":"<p>You can send simple text or card messages to a Google Chat space. A simple text message template can be defined as follows:</p> <pre><code>template.app-sync-succeeded: |\n  message: The app {{ .app.metadata.name }} has successfully synced!\n</code></pre> <p>A card message can be defined as follows:</p> <p><pre><code>template.app-sync-succeeded: |\n  googlechat:\n    cardsV2: |\n      - header:\n          title: ArgoCD Bot Notification\n        sections:\n          - widgets:\n              - decoratedText:\n                  text: The app {{ .app.metadata.name }} has successfully synced!\n          - widgets:\n              - decoratedText:\n                  topLabel: Repository\n                  text: {{ call .repo.RepoURLToHTTPS .app.spec.source.repoURL }}\n              - decoratedText:\n                  topLabel: Revision\n                  text: {{ .app.spec.source.targetRevision }}\n              - decoratedText:\n                  topLabel: Author\n                  text: {{ (call .repo.GetCommitMetadata .app.status.sync.revision).Author }}\n</code></pre> All Card fields are supported and can be used in notifications. It is also possible to use the previous (now deprecated) <code>cards</code> key to use the legacy card fields, but this is not recommended as Google has deprecated this field and recommends using the newer <code>cardsV2</code>.</p> <p>The card message can be written in JSON too.</p>"},{"location":"generated/notification-services/googlechat/#chat-threads","title":"Chat Threads","text":"<p>It is possible send both simple text and card messages in a chat thread by specifying a unique key for the thread. The thread key can be defined as follows:</p> <pre><code>template.app-sync-succeeded: |\n  message: The app {{ .app.metadata.name }} has successfully synced!\n  googlechat:\n    threadKey: {{ .app.metadata.name }}\n</code></pre>"},{"location":"generated/notification-services/grafana/","title":"Grafana","text":"<p>To be able to create Grafana annotation with argocd-notifications you have to create an API Key inside your Grafana.</p> <p></p> <p>Available parameters :</p> <ul> <li><code>apiURL</code> - the server url, e.g. https://grafana.example.com</li> <li><code>apiKey</code> - the API key for the serviceaccount</li> <li> <p><code>insecureSkipVerify</code> - optional bool, true or false</p> </li> <li> <p>Login to your Grafana instance as <code>admin</code></p> </li> <li>On the left menu, go to Configuration / API Keys</li> <li>Click \"Add API Key\" </li> <li>Fill the Key with name <code>ArgoCD Notification</code>, role <code>Editor</code> and Time to Live <code>10y</code> (for example)</li> <li>Click on Add button</li> <li>Store apiKey in <code>argo-rollouts-notification-secret</code> Secret and Copy your API Key and define it in <code>argo-rollouts-notification-configmap</code> ConfigMap</li> </ul> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.grafana: |\n    apiUrl: https://grafana.example.com/api\n    apiKey: $grafana-api-key\n</code></pre> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  grafana-api-key: api-key\n</code></pre> <ol> <li>Create subscription for your Grafana integration</li> </ol> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.&lt;trigger-name&gt;.grafana: tag1|tag2 # list of tags separated with |\n</code></pre> <ol> <li>Change the annotations settings </li> </ol>"},{"location":"generated/notification-services/mattermost/","title":"Mattermost","text":""},{"location":"generated/notification-services/mattermost/#parameters","title":"Parameters","text":"<ul> <li><code>apiURL</code> - the server url, e.g. https://mattermost.example.com</li> <li><code>token</code> - the bot token</li> <li><code>insecureSkipVerify</code> - optional bool, true or false</li> </ul>"},{"location":"generated/notification-services/mattermost/#configuration","title":"Configuration","text":"<ol> <li>Create a bot account and copy token after creating it </li> <li>Invite team </li> <li>Store token in <code>argo-rollouts-notification-secret</code> Secret and configure Mattermost integration in <code>argo-rollouts-notification-configmap</code> ConfigMap</li> </ol> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.mattermost: |\n    apiURL: &lt;api-url&gt;\n    token: $mattermost-token\n</code></pre> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  mattermost-token: token\n</code></pre> <ol> <li> <p>Copy channel id </p> </li> <li> <p>Create subscription for your Mattermost integration</p> </li> </ol> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.&lt;trigger-name&gt;.mattermost: &lt;channel-id&gt;\n</code></pre>"},{"location":"generated/notification-services/mattermost/#templates","title":"Templates","text":"<p>You can reuse the template of slack. Mattermost is compatible with attachments of Slack. See Mattermost Integration Guide.</p> <pre><code>template.app-deployed: |\n  message: |\n    Application {{.app.metadata.name}} is now running new version of deployments manifests.\n  mattermost:\n    attachments: |\n      [{\n        \"title\": \"{{.app.metadata.name}}\",\n        \"title_link\": \"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}\",\n        \"color\": \"#18be52\",\n        \"fields\": [{\n          \"title\": \"Sync Status\",\n          \"value\": \"{{.app.status.sync.status}}\",\n          \"short\": true\n        }, {\n          \"title\": \"Repository\",\n          \"value\": \"{{.app.spec.source.repoURL}}\",\n          \"short\": true\n        }]\n      }]\n</code></pre>"},{"location":"generated/notification-services/newrelic/","title":"NewRelic","text":""},{"location":"generated/notification-services/newrelic/#parameters","title":"Parameters","text":"<ul> <li><code>apiURL</code> - the api server url, e.g. https://api.newrelic.com</li> <li><code>apiKey</code> - a NewRelic ApiKey</li> </ul>"},{"location":"generated/notification-services/newrelic/#configuration","title":"Configuration","text":"<ol> <li>Create a NewRelic Api Key</li> <li>Store apiKey in <code>argo-rollouts-notification-secret</code> Secret and configure NewRelic integration in <code>argo-rollouts-notification-configmap</code> ConfigMap</li> </ol> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.newrelic: |\n    apiURL: &lt;api-url&gt;\n    apiKey: $newrelic-apiKey\n</code></pre> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  newrelic-apiKey: apiKey\n</code></pre> <ol> <li>Copy Application ID</li> <li>Create subscription for your NewRelic integration</li> </ol> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.&lt;trigger-name&gt;.newrelic: &lt;app-id&gt;\n</code></pre>"},{"location":"generated/notification-services/newrelic/#templates","title":"Templates","text":"<ul> <li><code>description</code> - optional, high-level description of this deployment, visible in the Summary page and on the Deployments page when you select an individual deployment.</li> <li>Defaults to <code>message</code></li> <li><code>changelog</code> - optional, A summary of what changed in this deployment, visible in the Deployments page when you select (selected deployment) &gt; Change log.</li> <li>Defaults to <code>{{(call .repo.GetCommitMetadata .app.status.sync.revision).Message}}</code></li> <li><code>user</code> - optional, A username to associate with the deployment, visible in the Summary and on the Deployments.</li> <li>Defaults to <code>{{(call .repo.GetCommitMetadata .app.status.sync.revision).Author}}</code></li> </ul> <pre><code>context: |\n  argocdUrl: https://example.com/argocd\n\ntemplate.app-deployed: |\n  message: Application {{.app.metadata.name}} has successfully deployed.\n  newrelic:\n    description: Application {{.app.metadata.name}} has successfully deployed\n</code></pre>"},{"location":"generated/notification-services/opsgenie/","title":"Opsgenie","text":"<p>To be able to send notifications with argocd-notifications you have to create an API Integration inside your Opsgenie Team.</p> <ol> <li>Login to Opsgenie at https://app.opsgenie.com or https://app.eu.opsgenie.com (if you have an account in the european union)</li> <li>Make sure you already have a team, if not follow this guide https://docs.opsgenie.com/docs/teams</li> <li>Click \"Teams\" in the Menu on the left</li> <li>Select the team that you want to notify</li> <li>In the teams configuration menu select \"Integrations\"</li> <li>Click \"Add Integration\" in the top right corner</li> <li>Select \"API\" integration</li> <li>Give your integration a name, copy the \"API key\" and safe it somewhere for later</li> <li>Click \"Edit\" in the integration settings</li> <li>Make sure the checkbox for \"Create and Update Access\" is selected, disable the other checkboxes to remove unnecessary permissions</li> <li>Click \"Save\" at the bottom</li> <li>Click \"Turn on integration\" in the top right corner</li> <li>Check your browser for the correct server apiURL. If it is \"app.opsgenie.com\" then use the US/international api url <code>api.opsgenie.com</code> in the next step, otherwise use <code>api.eu.opsgenie.com</code> (European API). </li> <li>You are finished with configuring Opsgenie. Now you need to configure argocd-notifications. Use the apiUrl, the team name and the apiKey to configure the Opsgenie integration in the <code>argo-rollouts-notification-secret</code> secret.</li> <li>You can find the example <code>argo-rollouts-notification-configmap</code> configuration at the below.</li> </ol> Option Required Type Description Example <code>description</code> True <code>string</code> Description field of the alert that is generally used to provide a detailed information about the alert. <code>Hello from Argo CD!</code> <code>priority</code> False <code>string</code> Priority level of the alert. Possible values are P1, P2, P3, P4 and P5. Default value is P3. <code>P1</code> <code>alias</code> False <code>string</code> Client-defined identifier of the alert, that is also the key element of Alert De-Duplication. <code>Life is too short for no alias</code> <code>note</code> False <code>string</code> Additional note that will be added while creating the alert. <code>Error from Argo CD!</code> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.opsgenie: |\n    apiUrl: &lt;api-url&gt;\n    apiKeys:\n      &lt;your-team&gt;: &lt;integration-api-key&gt;\n  template.opsgenie: |\n    message: |\n      [Argo CD] Application {{.app.metadata.name}} has a problem.\n    opsgenie:\n      description: |\n        Application: {{.app.metadata.name}}\n        Health Status: {{.app.status.health.status}}\n        Operation State Phase: {{.app.status.operationState.phase}}\n        Sync Status: {{.app.status.sync.status}}\n      priority: P1\n      alias: {{.app.metadata.name}}\n      note: Error from Argo CD!\n  trigger.on-a-problem: |\n    - description: Application has a problem.\n      send:\n      - opsgenie\n      when: app.status.health.status == 'Degraded' or app.status.operationState.phase in ['Error', 'Failed'] or app.status.sync.status == 'Unknown'\n</code></pre> <ol> <li>Add annotation in application yaml file to enable notifications for specific Argo CD app. <pre><code>  apiVersion: argoproj.io/v1alpha1\n  kind: Application\n  metadata:\n    annotations:\n      notifications.argoproj.io/subscribe.on-a-problem.opsgenie: &lt;your-team&gt;\n</code></pre></li> </ol>"},{"location":"generated/notification-services/overview/","title":"Overview","text":"<p>The notification services represent integration with services such as slack, email or custom webhook. Services are configured in <code>argo-rollouts-notification-configmap</code> ConfigMap using <code>service.&lt;type&gt;.(&lt;custom-name&gt;)</code> keys and might reference sensitive data from <code>argo-rollouts-notification-secret</code> Secret. Following example demonstrates slack service configuration:</p> <pre><code>  service.slack: |\n    token: $slack-token\n</code></pre> <p>The <code>slack</code> indicates that service sends slack notification; name is missing and defaults to <code>slack</code>.</p>"},{"location":"generated/notification-services/overview/#sensitive-data","title":"Sensitive Data","text":"<p>Sensitive data like authentication tokens should be stored in <code>&lt;secret-name&gt;</code> Secret and can be referenced in service configuration using <code>$&lt;secret-key&gt;</code> format. For example <code>$slack-token</code> referencing value of key <code>slack-token</code> in <code>&lt;secret-name&gt;</code> Secret.</p>"},{"location":"generated/notification-services/overview/#custom-names","title":"Custom Names","text":"<p>Service custom names allow configuring two instances of the same service type.</p> <pre><code>  service.slack.workspace1: |\n    token: $slack-token-workspace1\n  service.slack.workspace2: |\n    token: $slack-token-workspace2\n</code></pre> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-sync-succeeded.workspace1: my-channel\n    notifications.argoproj.io/subscribe.on-sync-succeeded.workspace2: my-channel\n</code></pre>"},{"location":"generated/notification-services/overview/#service-types","title":"Service Types","text":"<ul> <li>AwsSqs</li> <li>Email</li> <li>GitHub</li> <li>Slack</li> <li>Mattermost</li> <li>Opsgenie</li> <li>Grafana</li> <li>Webhook</li> <li>Telegram</li> <li>Teams</li> <li>Google Chat</li> <li>Rocket.Chat</li> <li>Pushover</li> <li>Alertmanager</li> </ul>"},{"location":"generated/notification-services/pagerduty/","title":"PagerDuty","text":""},{"location":"generated/notification-services/pagerduty/#parameters","title":"Parameters","text":"<p>The PagerDuty notification service is used to create PagerDuty incidents and requires specifying the following settings:</p> <ul> <li><code>pagerdutyToken</code> - the PagerDuty auth token</li> <li><code>from</code> - email address of a valid user associated with the account making the request.</li> <li><code>serviceID</code> - The ID of the resource.</li> </ul>"},{"location":"generated/notification-services/pagerduty/#example","title":"Example","text":"<p>The following snippet contains sample PagerDuty service configuration:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  pagerdutyToken: &lt;pd-api-token&gt;\n</code></pre> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.pagerduty: |\n    token: $pagerdutyToken\n    from: &lt;emailid&gt;\n</code></pre>"},{"location":"generated/notification-services/pagerduty/#template","title":"Template","text":"<p>Notification templates support specifying subject for PagerDuty notifications:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  template.rollout-aborted: |\n    message: Rollout {{.rollout.metadata.name}} is aborted.\n    pagerduty:\n      title: \"Rollout {{.rollout.metadata.name}}\"\n      urgency: \"high\"\n      body: \"Rollout {{.rollout.metadata.name}} aborted \"\n      priorityID: \"&lt;priorityID of incident&gt;\"\n</code></pre> <p>NOTE: A Priority is a label representing the importance and impact of an incident. This is only available on Standard and Enterprise plans of pagerduty.</p>"},{"location":"generated/notification-services/pagerduty/#annotation","title":"Annotation","text":"<p>Annotation sample for pagerduty notifications: <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-rollout-aborted.pagerduty: \"&lt;serviceID for PagerDuty&gt;\"\n</code></pre></p>"},{"location":"generated/notification-services/pagerduty_v2/","title":"PagerDuty V2","text":""},{"location":"generated/notification-services/pagerduty_v2/#parameters","title":"Parameters","text":"<p>The PagerDuty notification service is used to trigger PagerDuty events and requires specifying the following settings:</p> <ul> <li><code>serviceKeys</code> - a dictionary with the following structure:</li> <li><code>service-name: $pagerduty-key-service-name</code> where <code>service-name</code> is the name you want to use for the service to make events for, and <code>$pagerduty-key-service-name</code> is a reference to the secret that contains the actual PagerDuty integration key (Events API v2 integration)</li> </ul> <p>If you want multiple Argo apps to trigger events to their respective PagerDuty services, create an integration key in each service you want to setup alerts for.</p> <p>To create a PagerDuty integration key, follow these instructions to add an Events API v2 integration to the service of your choice.</p>"},{"location":"generated/notification-services/pagerduty_v2/#configuration","title":"Configuration","text":"<p>The following snippet contains sample PagerDuty service configuration. It assumes the service you want to alert on is called <code>my-service</code>.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  pagerduty-key-my-service: &lt;pd-integration-key&gt;\n</code></pre> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.pagerdutyv2: |\n    serviceKeys:\n      my-service: $pagerduty-key-my-service\n</code></pre>"},{"location":"generated/notification-services/pagerduty_v2/#template","title":"Template","text":"<p>Notification templates support specifying subject for PagerDuty notifications:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  template.rollout-aborted: |\n    message: Rollout {{.rollout.metadata.name}} is aborted.\n    pagerdutyv2:\n      summary: \"Rollout {{.rollout.metadata.name}} is aborted.\"\n      severity: \"critical\"\n      source: \"{{.rollout.metadata.name}}\"\n</code></pre> <p>The parameters for the PagerDuty configuration in the template generally match with the payload for the Events API v2 endpoint. All parameters are strings.</p> <ul> <li><code>summary</code> - (required) A brief text summary of the event, used to generate the summaries/titles of any associated alerts.</li> <li><code>severity</code> - (required) The perceived severity of the status the event is describing with respect to the affected system. Allowed values: <code>critical</code>, <code>warning</code>, <code>error</code>, <code>info</code></li> <li><code>source</code> - (required) The unique location of the affected system, preferably a hostname or FQDN.</li> <li><code>component</code> - Component of the source machine that is responsible for the event.</li> <li><code>group</code> - Logical grouping of components of a service.</li> <li><code>class</code> - The class/type of the event.</li> <li><code>url</code> - The URL that should be used for the link \"View in ArgoCD\" in PagerDuty.</li> </ul> <p>The <code>timestamp</code> and <code>custom_details</code> parameters are not currently supported.</p>"},{"location":"generated/notification-services/pagerduty_v2/#annotation","title":"Annotation","text":"<p>Annotation sample for PagerDuty notifications:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-rollout-aborted.pagerdutyv2: \"&lt;serviceID for PagerDuty&gt;\"\n</code></pre>"},{"location":"generated/notification-services/pushover/","title":"Pushover","text":"<ol> <li>Create an app at pushover.net.</li> <li>Store the API key in <code>&lt;secret-name&gt;</code> Secret and define the secret name in <code>argo-rollouts-notification-configmap</code> ConfigMap:</li> </ol> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.pushover: |\n    token: $pushover-token\n</code></pre> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  pushover-token: avtc41pn13asmra6zaiyf7dh6cgx97\n</code></pre> <ol> <li>Add your user key to your Application resource:</li> </ol> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-sync-succeeded.pushover: uumy8u4owy7bgkapp6mc5mvhfsvpcd\n</code></pre>"},{"location":"generated/notification-services/rocketchat/","title":"Rocket.Chat","text":""},{"location":"generated/notification-services/rocketchat/#parameters","title":"Parameters","text":"<p>The Rocket.Chat notification service configuration includes following settings:</p> <ul> <li><code>email</code> - the Rocker.Chat user's email</li> <li><code>password</code> - the Rocker.Chat user's password</li> <li><code>alias</code> - optional alias that should be used to post message</li> <li><code>icon</code> - optional message icon</li> <li><code>avatar</code> - optional message avatar</li> <li><code>serverUrl</code> - optional Rocket.Chat server url</li> </ul>"},{"location":"generated/notification-services/rocketchat/#configuration","title":"Configuration","text":"<ol> <li>Login to your RocketChat instance</li> <li>Go to user management</li> </ol> <ol> <li>Add new user with <code>bot</code> role. Also note that <code>Require password change</code> checkbox mus be not checked</li> </ol> <ol> <li>Copy username and password that you was created for bot user</li> <li>Create a public or private channel, or a team, for this example <code>my_channel</code></li> <li>Add your bot to this channel otherwise it won't work</li> <li>Store email and password in argocd_notifications-secret Secret</li> </ol> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  rocketchat-email: &lt;email&gt;\n  rocketchat-password: &lt;password&gt;\n</code></pre> <ol> <li>Finally, use these credentials to configure the RocketChat integration in the <code>argocd-configmap</code> config map: </li> </ol> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.rocketchat: |\n    email: $rocketchat-email\n    password: $rocketchat-password\n</code></pre> <ol> <li>Create a subscription for your Rocket.Chat integration:</li> </ol> <p>Note: channel, team or user must be prefixed with # or @ elsewhere we will be interpretative destination as a room ID</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-sync-succeeded.rocketchat: #my_channel\n</code></pre>"},{"location":"generated/notification-services/rocketchat/#templates","title":"Templates","text":"<p>Notification templates can be customized with RocketChat attachments.</p> <p>Note: Attachments structure in Rocketchat is same with Slack attachments feature.</p> <p>The message attachments can be specified in <code>attachments</code> string fields under <code>rocketchat</code> field:</p> <pre><code>template.app-sync-status: |\n  message: |\n    Application {{.app.metadata.name}} sync is {{.app.status.sync.status}}.\n    Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.\n  rocketchat:\n    attachments: |\n      [{\n        \"title\": \"{{.app.metadata.name}}\",\n        \"title_link\": \"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}\",\n        \"color\": \"#18be52\",\n        \"fields\": [{\n          \"title\": \"Sync Status\",\n          \"value\": \"{{.app.status.sync.status}}\",\n          \"short\": true\n        }, {\n          \"title\": \"Repository\",\n          \"value\": \"{{.app.spec.source.repoURL}}\",\n          \"short\": true\n        }]\n      }]\n</code></pre>"},{"location":"generated/notification-services/slack/","title":"Slack","text":"<p>If you want to send message using incoming webhook, you can use webhook.</p>"},{"location":"generated/notification-services/slack/#parameters","title":"Parameters","text":"<p>The Slack notification service configuration includes following settings:</p> Option Required Type Description Example <code>apiURL</code> False <code>string</code> The server URL. <code>https://example.com/api</code> <code>channels</code> False <code>list[string]</code> <code>[\"my-channel-1\", \"my-channel-2\"]</code> <code>icon</code> False <code>string</code> The app icon. <code>:robot_face:</code> or <code>https://example.com/image.png</code> <code>insecureSkipVerify</code> False <code>bool</code> <code>true</code> <code>signingSecret</code> False <code>string</code> <code>8f742231b10e8888abcd99yyyzzz85a5</code> <code>token</code> True <code>string</code> The app's OAuth access token. <code>xoxb-1234567890-1234567890123-5n38u5ed63fgzqlvuyxvxcx6</code> <code>username</code> False <code>string</code> The app username. <code>argocd</code> <code>disableUnfurl</code> False <code>bool</code> Disable slack unfurling links in messages <code>true</code>"},{"location":"generated/notification-services/slack/#configuration","title":"Configuration","text":"<ol> <li>Create Slack Application using https://api.slack.com/apps?new_app=1 </li> <li>Once application is created navigate to <code>Enter OAuth &amp; Permissions</code> </li> <li>Click <code>Permissions</code> under <code>Add features and functionality</code> section and add <code>chat:write</code> scope. To use the optional username and icon overrides in the Slack notification service also add the <code>chat:write.customize</code> scope. </li> <li>Scroll back to the top, click 'Install App to Workspace' button and confirm the installation. </li> <li> <p>Once installation is completed copy the OAuth token. </p> </li> <li> <p>Create a public or private channel, for this example <code>my_channel</code></p> </li> <li>Invite your slack bot to this channel otherwise slack bot won't be able to deliver notifications to this channel</li> <li> <p>Store Oauth access token in <code>argo-rollouts-notification-secret</code> secret</p> <pre><code>  apiVersion: v1\n  kind: Secret\n  metadata:\n      name: &lt;secret-name&gt;\n  stringData:\n      slack-token: &lt;Oauth-access-token&gt;\n</code></pre> </li> <li> <p>Define service type slack in data section of <code>argo-rollouts-notification-configmap</code> configmap:</p> <pre><code>  apiVersion: v1\n  kind: ConfigMap\n  metadata:\n    name: argo-rollouts-notification-configmap\n  data:\n    service.slack: |\n      token: $slack-token\n</code></pre> </li> <li> <p>Add annotation in application yaml file to enable notifications for specific argocd app.  The following example uses the on-sync-succeeded trigger:</p> <pre><code>  apiVersion: argoproj.io/v1alpha1\n  kind: Application\n  metadata:\n    annotations:\n      notifications.argoproj.io/subscribe.on-sync-succeeded.slack: my_channel\n</code></pre> </li> <li> <p>Annotation with more than one trigger, with multiple destinations and recipients</p> <pre><code>  apiVersion: argoproj.io/v1alpha1\n  kind: Application\n  metadata:\n    annotations:\n      notifications.argoproj.io/subscriptions: |\n        - trigger: [on-scaling-replica-set, on-rollout-updated, on-rollout-step-completed]\n          destinations:\n            - service: slack\n              recipients: [my-channel-1, my-channel-2]\n            - service: email\n              recipients: [recipient-1, recipient-2, recipient-3 ]\n        - trigger: [on-rollout-aborted, on-analysis-run-failed, on-analysis-run-error]\n          destinations:\n            - service: slack\n              recipients: [my-channel-21, my-channel-22]\n</code></pre> </li> </ol>"},{"location":"generated/notification-services/slack/#templates","title":"Templates","text":"<p>Notification templates can be customized to leverage slack message blocks and attachments feature.</p> <p></p> <p>The message blocks and attachments can be specified in <code>blocks</code> and <code>attachments</code> string fields under <code>slack</code> field:</p> <pre><code>template.app-sync-status: |\n  message: |\n    Application {{.app.metadata.name}} sync is {{.app.status.sync.status}}.\n    Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.\n  slack:\n    attachments: |\n      [{\n        \"title\": \"{{.app.metadata.name}}\",\n        \"title_link\": \"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}\",\n        \"color\": \"#18be52\",\n        \"fields\": [{\n          \"title\": \"Sync Status\",\n          \"value\": \"{{.app.status.sync.status}}\",\n          \"short\": true\n        }, {\n          \"title\": \"Repository\",\n          \"value\": \"{{.app.spec.source.repoURL}}\",\n          \"short\": true\n        }]\n      }]\n</code></pre> <p>The messages can be aggregated to the slack threads by grouping key which can be specified in a <code>groupingKey</code> string field under <code>slack</code> field. <code>groupingKey</code> is used across each template and works independently on each slack channel. When multiple applications will be updated at the same time or frequently, the messages in slack channel can be easily read by aggregating with git commit hash, application name, etc. Furthermore, the messages can be broadcast to the channel at the specific template by <code>notifyBroadcast</code> field.</p> <pre><code>template.app-sync-status: |\n  message: |\n    Application {{.app.metadata.name}} sync is {{.app.status.sync.status}}.\n    Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.\n  slack:\n    attachments: |\n      [{\n        \"title\": \"{{.app.metadata.name}}\",\n        \"title_link\": \"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}\",\n        \"color\": \"#18be52\",\n        \"fields\": [{\n          \"title\": \"Sync Status\",\n          \"value\": \"{{.app.status.sync.status}}\",\n          \"short\": true\n        }, {\n          \"title\": \"Repository\",\n          \"value\": \"{{.app.spec.source.repoURL}}\",\n          \"short\": true\n        }]\n      }]\n    # Aggregate the messages to the thread by git commit hash\n    groupingKey: \"{{.app.status.sync.revision}}\"\n    notifyBroadcast: false\ntemplate.app-sync-failed: |\n  message: |\n    Application {{.app.metadata.name}} sync is {{.app.status.sync.status}}.\n    Application details: {{.context.argocdUrl}}/applications/{{.app.metadata.name}}.\n  slack:\n    attachments: |\n      [{\n        \"title\": \"{{.app.metadata.name}}\",\n        \"title_link\": \"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}\",\n        \"color\": \"#ff0000\",\n        \"fields\": [{\n          \"title\": \"Sync Status\",\n          \"value\": \"{{.app.status.sync.status}}\",\n          \"short\": true\n        }, {\n          \"title\": \"Repository\",\n          \"value\": \"{{.app.spec.source.repoURL}}\",\n          \"short\": true\n        }]\n      }]\n    # Aggregate the messages to the thread by git commit hash\n    groupingKey: \"{{.app.status.sync.revision}}\"\n    notifyBroadcast: true\n</code></pre> <p>The message is sent according to the <code>deliveryPolicy</code> string field under the <code>slack</code> field. The available modes are <code>Post</code> (default), <code>PostAndUpdate</code>, and <code>Update</code>. The <code>PostAndUpdate</code> and <code>Update</code> settings require <code>groupingKey</code> to be set.</p>"},{"location":"generated/notification-services/teams/","title":"Teams","text":""},{"location":"generated/notification-services/teams/#parameters","title":"Parameters","text":"<p>The Teams notification service send message notifications using Teams bot and requires specifying the following settings:</p> <ul> <li><code>recipientUrls</code> - the webhook url map, e.g. <code>channelName: https://example.com</code></li> </ul>"},{"location":"generated/notification-services/teams/#configuration","title":"Configuration","text":"<ol> <li>Open <code>Teams</code> and goto <code>Apps</code></li> <li>Find <code>Incoming Webhook</code> microsoft app and click on it</li> <li>Press <code>Add to a team</code> -&gt; select team and channel -&gt; press <code>Set up a connector</code></li> <li>Enter webhook name and upload image (optional)</li> <li>Press <code>Create</code> then copy webhook url and store it in <code>argo-rollouts-notification-secret</code> and define it in <code>argo-rollouts-notification-configmap</code></li> </ol> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.teams: |\n    recipientUrls:\n      channelName: $channel-teams-url\n</code></pre> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: &lt;secret-name&gt;\nstringData:\n  channel-teams-url: https://example.com\n</code></pre> <ol> <li>Create subscription for your Teams integration:</li> </ol> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-sync-succeeded.teams: channelName\n</code></pre>"},{"location":"generated/notification-services/teams/#templates","title":"Templates","text":"<p>Notification templates can be customized to leverage teams message sections, facts, themeColor, summary and potentialAction feature.</p> <pre><code>template.app-sync-succeeded: |\n  teams:\n    themeColor: \"#000080\"\n    sections: |\n      [{\n        \"facts\": [\n          {\n            \"name\": \"Sync Status\",\n            \"value\": \"{{.app.status.sync.status}}\"\n          },\n          {\n            \"name\": \"Repository\",\n            \"value\": \"{{.app.spec.source.repoURL}}\"\n          }\n        ]\n      }]\n    potentialAction: |-\n      [{\n        \"@type\":\"OpenUri\",\n        \"name\":\"Operation Details\",\n        \"targets\":[{\n          \"os\":\"default\",\n          \"uri\":\"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}?operation=true\"\n        }]\n      }]\n    title: Application {{.app.metadata.name}} has been successfully synced\n    text: Application {{.app.metadata.name}} has been successfully synced at {{.app.status.operationState.finishedAt}}.\n    summary: \"{{.app.metadata.name}} sync succeeded\"\n</code></pre>"},{"location":"generated/notification-services/teams/#facts-field","title":"facts field","text":"<p>You can use <code>facts</code> field instead of <code>sections</code> field.</p> <pre><code>template.app-sync-succeeded: |\n  teams:\n    facts: |\n      [{\n        \"name\": \"Sync Status\",\n        \"value\": \"{{.app.status.sync.status}}\"\n      },\n      {\n        \"name\": \"Repository\",\n        \"value\": \"{{.app.spec.source.repoURL}}\"\n      }]\n</code></pre>"},{"location":"generated/notification-services/teams/#theme-color-field","title":"theme color field","text":"<p>You can set theme color as hex string for the message.</p> <p></p> <pre><code>template.app-sync-succeeded: |\n  teams:\n    themeColor: \"#000080\"\n</code></pre>"},{"location":"generated/notification-services/teams/#summary-field","title":"summary field","text":"<p>You can set a summary of the message that will be shown on Notification &amp; Activity Feed </p> <p></p> <p></p> <pre><code>template.app-sync-succeeded: |\n  teams:\n    summary: \"Sync Succeeded\"\n</code></pre>"},{"location":"generated/notification-services/telegram/","title":"Telegram","text":"<ol> <li>Get an API token using @Botfather.</li> <li>Store token in <code>&lt;secret-name&gt;</code> Secret and configure telegram integration in <code>argo-rollouts-notification-configmap</code> ConfigMap:</li> </ol> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.telegram: |\n    token: $telegram-token\n</code></pre> <ol> <li>Create new Telegram channel.</li> <li>Add your bot as an administrator.</li> <li>Use this channel <code>username</code> (public channel) or <code>chatID</code> (private channel) in the subscription for your Telegram integration:</li> </ol> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-sync-succeeded.telegram: username\n</code></pre> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-sync-succeeded.telegram: -1000000000000\n</code></pre> <p>If your private chat contains threads, you can optionally specify a thread id by seperating it with a <code>|</code>: <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.on-sync-succeeded.telegram: -1000000000000|2\n</code></pre></p>"},{"location":"generated/notification-services/webex/","title":"Webex Teams","text":""},{"location":"generated/notification-services/webex/#parameters","title":"Parameters","text":"<p>The Webex Teams notification service configuration includes following settings:</p> <ul> <li><code>token</code> - the app token</li> </ul>"},{"location":"generated/notification-services/webex/#configuration","title":"Configuration","text":"<ol> <li>Create a Webex Bot</li> <li> <p>Copy the bot access token and store it in the <code>argo-rollouts-notification-secret</code> Secret and configure Webex Teams integration in <code>argo-rollouts-notification-configmap</code> ConfigMap</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\nname: &lt;secret-name&gt;\nstringData:\nwebex-token: &lt;bot access token&gt;\n</code></pre> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: argo-rollouts-notification-configmap\ndata:\nservice.webex: |\n    token: $webex-token\n</code></pre> </li> <li> <p>Create subscription for your Webex Teams integration</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\nannotations:\n    notifications.argoproj.io/subscribe.&lt;trigger-name&gt;.webex: &lt;personal email or room id&gt;\n</code></pre> </li> </ol>"},{"location":"generated/notification-services/webhook/","title":"Webhook","text":"<p>The webhook notification service allows sending a generic HTTP request using the templatized request body and URL. Using Webhook you might trigger a Jenkins job, update GitHub commit status.</p>"},{"location":"generated/notification-services/webhook/#parameters","title":"Parameters","text":"<p>The Webhook notification service configuration includes following settings:</p> <ul> <li><code>url</code> - the url to send the webhook to</li> <li><code>headers</code> - optional, the headers to pass along with the webhook</li> <li><code>basicAuth</code> - optional, the basic authentication to pass along with the webhook</li> <li><code>insecureSkipVerify</code> - optional bool, true or false</li> <li><code>retryWaitMin</code> - Optional, the minimum wait time between retries. Default value: 1s.</li> <li><code>retryWaitMax</code> - Optional, the maximum wait time between retries. Default value: 5s.</li> <li><code>retryMax</code> - Optional, the maximum number of retries. Default value: 3.</li> </ul>"},{"location":"generated/notification-services/webhook/#retry-behavior","title":"Retry Behavior","text":"<p>The webhook service will automatically retry the request if it fails due to network errors or if the server returns a 5xx status code. The number of retries and the wait time between retries can be configured using the <code>retryMax</code>, <code>retryWaitMin</code>, and <code>retryWaitMax</code> parameters.</p> <p>The wait time between retries is between <code>retryWaitMin</code> and <code>retryWaitMax</code>. If all retries fail, the <code>Send</code> method will return an error.</p>"},{"location":"generated/notification-services/webhook/#configuration","title":"Configuration","text":"<p>Use the following steps to configure webhook:</p> <p>1 Register webhook in <code>argo-rollouts-notification-configmap</code> ConfigMap:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.webhook.&lt;webhook-name&gt;: |\n    url: https://&lt;hostname&gt;/&lt;optional-path&gt;\n    headers: #optional headers\n    - name: &lt;header-name&gt;\n      value: &lt;header-value&gt;\n    basicAuth: #optional username password\n      username: &lt;username&gt;\n      password: &lt;api-key&gt;\n    insecureSkipVerify: true #optional bool\n</code></pre> <p>2 Define template that customizes webhook request method, path and body:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  template.github-commit-status: |\n    webhook:\n      &lt;webhook-name&gt;:\n        method: POST # one of: GET, POST, PUT, PATCH. Default value: GET \n        path: &lt;optional-path-template&gt;\n        body: |\n          &lt;optional-body-template&gt;\n  trigger.&lt;trigger-name&gt;: |\n    - when: app.status.operationState.phase in ['Succeeded']\n      send: [github-commit-status]\n</code></pre> <p>3 Create subscription for webhook integration:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  annotations:\n    notifications.argoproj.io/subscribe.&lt;trigger-name&gt;.&lt;webhook-name&gt;: \"\"\n</code></pre>"},{"location":"generated/notification-services/webhook/#examples","title":"Examples","text":""},{"location":"generated/notification-services/webhook/#set-github-commit-status","title":"Set GitHub commit status","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.webhook.github: |\n    url: https://api.github.com\n    headers: #optional headers\n    - name: Authorization\n      value: token $github-token\n</code></pre> <p>2 Define template that customizes webhook request method, path and body:</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.webhook.github: |\n    url: https://api.github.com\n    headers: #optional headers\n    - name: Authorization\n      value: token $github-token\n\n  template.github-commit-status: |\n    webhook:\n      github:\n        method: POST\n        path: /repos/{{call .repo.FullNameByRepoURL .app.spec.source.repoURL}}/statuses/{{.app.status.operationState.operation.sync.revision}}\n        body: |\n          {\n            {{if eq .app.status.operationState.phase \"Running\"}} \"state\": \"pending\"{{end}}\n            {{if eq .app.status.operationState.phase \"Succeeded\"}} \"state\": \"success\"{{end}}\n            {{if eq .app.status.operationState.phase \"Error\"}} \"state\": \"error\"{{end}}\n            {{if eq .app.status.operationState.phase \"Failed\"}} \"state\": \"error\"{{end}},\n            \"description\": \"ArgoCD\",\n            \"target_url\": \"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}\",\n            \"context\": \"continuous-delivery/{{.app.metadata.name}}\"\n          }\n</code></pre>"},{"location":"generated/notification-services/webhook/#start-jenkins-job","title":"Start Jenkins Job","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.webhook.jenkins: |\n    url: http://&lt;jenkins-host&gt;/job/&lt;job-name&gt;/build?token=&lt;job-secret&gt;\n    basicAuth:\n      username: &lt;username&gt;\n      password: &lt;api-key&gt;\n\ntype: Opaque\n</code></pre>"},{"location":"generated/notification-services/webhook/#send-form-data","title":"Send form-data","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.webhook.form: |\n    url: https://form.example.com\n    headers:\n    - name: Content-Type\n      value: application/x-www-form-urlencoded\n\n  template.form-data: |\n    webhook:\n      form:\n        method: POST\n        body: key1=value1&amp;key2=value2\n</code></pre>"},{"location":"generated/notification-services/webhook/#send-slack","title":"Send Slack","text":"<pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argo-rollouts-notification-configmap\ndata:\n  service.webhook.slack_webhook: |\n    url: https://hooks.slack.com/services/xxxxx\n    headers:\n    - name: Content-Type\n      value: application/json\n\n  template.send-slack: |\n    webhook:\n      slack_webhook:\n        method: POST\n        body: |\n          {\n            \"attachments\": [{\n              \"title\": \"{{.app.metadata.name}}\",\n              \"title_link\": \"{{.context.argocdUrl}}/applications/{{.app.metadata.name}}\",\n              \"color\": \"#18be52\",\n              \"fields\": [{\n                \"title\": \"Sync Status\",\n                \"value\": \"{{.app.status.sync.status}}\",\n                \"short\": true\n              }, {\n                \"title\": \"Repository\",\n                \"value\": \"{{.app.spec.source.repoURL}}\",\n                \"short\": true\n              }]\n            }]\n          }\n</code></pre>"},{"location":"getting-started/alb/","title":"Getting Started - AWS Load Balancer Controller","text":"<p>This guide covers how Argo Rollouts integrates with the AWS Load Balancer Controller for traffic shaping. This guide builds upon the concepts of the basic getting started guide.</p>"},{"location":"getting-started/alb/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes cluster with AWS ALB Ingress Controller installed</li> </ul> <p>Tip</p> <p>See the Load Balancer Controller Installation instructions on how to install the AWS Load Balancer Controller</p>"},{"location":"getting-started/alb/#1-deploy-the-rollout-services-and-ingress","title":"1. Deploy the Rollout, Services, and Ingress","text":"<p>When an AWS ALB Ingress is used as the traffic router, the Rollout canary strategy must define the following fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollouts-demo\nspec:\n  strategy:\n    canary:\n      # canaryService and stableService are references to Services which the Rollout will modify\n      # to target the canary ReplicaSet and stable ReplicaSet respectively (required).\n      canaryService: rollouts-demo-canary\n      stableService: rollouts-demo-stable\n      trafficRouting:\n        alb:\n          # The referenced ingress will be injected with a custom action annotation, directing\n          # the AWS Load Balancer Controller to split traffic between the canary and stable\n          # Service, according to the desired traffic weight (required).\n          ingress: rollouts-demo-ingress\n          # Reference to a Service that the Ingress must target in one of the rules (optional).\n          # If omitted, uses canary.stableService.\n          rootService: rollouts-demo-root\n          # Service port is the port which the Service listens on (required).\n          servicePort: 443\n...\n</code></pre> <p>The Ingress referenced by the Rollout must have a rule which matches one of Rollout services. This should be <code>canary.trafficRouting.alb.rootService</code> (if specified), otherwise the rollout will use <code>canary.stableService</code>.</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: rollouts-demo-ingress\n  annotations:\n    kubernetes.io/ingress.class: alb\nspec:\n  rules:\n  - http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            # serviceName must match either: canary.trafficRouting.alb.rootService (if specified),\n            # or canary.stableService (if rootService is omitted)\n            name: rollouts-demo-root\n            # servicePort must be the value: use-annotation\n            # This instructs AWS Load Balancer Controller to look to annotations on how to direct traffic\n            port:\n              name: use-annotation\n</code></pre> <p>During an update, the Ingress will be injected with a custom action annotation, which directs the ALB to splits traffic between the stable and canary Services referenced by the Rollout. In this example, those Services are named: <code>rollouts-demo-stable</code> and <code>rollouts-demo-canary</code> respectively.</p> <p>Run the following commands to deploy:</p> <ul> <li>A Rollout</li> <li>Three Services (root, stable, canary)</li> <li>An Ingress</li> </ul> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/alb/rollout.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/alb/services.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/alb/ingress.yaml\n</code></pre> <p>After applying the manifests you should see the following rollout, services, and ingress resources in the cluster:</p> <pre><code>$ kubectl get ro\nNAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE\nrollouts-demo   1         1         1            1\n\n$ kubectl get svc\nNAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE\nrollouts-demo-root     NodePort    10.100.16.123    &lt;none&gt;        80:30225/TCP   2m43s\nrollouts-demo-canary   NodePort    10.100.16.64     &lt;none&gt;        80:30224/TCP   2m43s\nrollouts-demo-stable   NodePort    10.100.146.232   &lt;none&gt;        80:31135/TCP   2m43s\n\n$ kubectl get ingress\nNAME                    HOSTS   ADDRESS                                                                       PORTS   AGE\nrollouts-demo-ingress   *       b0548428-default-rolloutsd-6951-1972570952.ap-northeast-1.elb.amazonaws.com   80      6m36s\n</code></pre> <pre><code>kubectl argo rollouts get rollout rollouts-demo\n</code></pre> <p></p>"},{"location":"getting-started/alb/#2-perform-an-update","title":"2. Perform an update","text":"<p>Update the rollout by changing the image, and wait for it to reach the paused state.</p> <pre><code>kubectl argo rollouts set image rollouts-demo rollouts-demo=argoproj/rollouts-demo:yellow\nkubectl argo rollouts get rollout rollouts-demo\n</code></pre> <p></p> <p>At this point, both the canary and stable version of the Rollout are running, with 5% of the traffic directed to the canary. To understand how this works, inspect the listener rules for the ALB. When looking at the listener rules, we see that the forward action weights have been modified by the controller to reflect the current weight of the canary.</p> <p></p> <p>The controller has added <code>rollouts-pod-template-hash</code> selector to the Services and attached the same label to the Pods. Therefore, you can split the traffic by simply forwarding the requests to the Services according to the weights.</p> <p>As the Rollout progresses through steps, the forward action weights will be adjusted to match the current setWeight of the steps.</p>"},{"location":"getting-started/ambassador/","title":"Argo Rollouts and Ambassador Quick Start","text":"<p>This tutorial will walk you through the process of configuring Argo Rollouts to work with Ambassador to facilitate canary releases. All files used in this guide are available in the examples directory of this repository.</p>"},{"location":"getting-started/ambassador/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes cluster</li> <li>Argo-Rollouts installed in the cluster</li> </ul> <p>Note If using Ambassador Edge Stack or Emissary-ingress 2.0+, you will need to install Argo-Rollouts version v1.1+, and you will need to supply <code>--ambassador-api-version getambassador.io/v3alpha1</code> to your <code>argo-rollouts</code> deployment.</p>"},{"location":"getting-started/ambassador/#1-install-and-configure-ambassador-edge-stack","title":"1. Install and configure Ambassador Edge Stack","text":"<p>If you don't have Ambassador in your cluster you can install it following the Edge Stack documentation.</p> <p>By default, Edge Stack routes via Kubernetes services. For best performance with canaries, we recommend you use endpoint routing. Enable endpoint routing on your cluster by saving the following configuration in a file called <code>resolver.yaml</code>:</p> <pre><code>apiVersion: getambassador.io/v2\nkind: KubernetesEndpointResolver\nmetadata:\n  name: endpoint\n</code></pre> <p>Apply this configuration to your cluster: <code>kubectl apply -f resolver.yaml</code>.</p>"},{"location":"getting-started/ambassador/#2-create-the-kubernetes-services","title":"2. Create the Kubernetes Services","text":"<p>We'll create two Kubernetes services, named <code>echo-stable</code> and <code>echo-canary</code>. Save this configuration to the file <code>echo-service.yaml</code>.</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: echo\n  name: echo-stable\nspec:\n  type: ClusterIP\n  ports:\n  - name: http\n    port: 80\n    protocol: TCP\n    targetPort: 8080\n  selector:\n    app: echo\n---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: echo\n  name: echo-canary\nspec:\n  type: ClusterIP\n  ports:\n  - name: http\n    port: 80\n    protocol: TCP\n    targetPort: 8080\n  selector:\n    app: echo \n</code></pre> <p>We'll also create an Edge Stack route to the services. Save the following configuration to a file called <code>echo-mapping.yaml</code>.</p> <pre><code>apiVersion: getambassador.io/v2\nkind:  Mapping\nmetadata:\n  name:  echo\nspec:\n  prefix: /echo\n  rewrite: /echo\n  service: echo-stable:80\n  resolver: endpoint\n</code></pre> <p>Apply both of these configurations to the Kubernetes cluster:</p> <pre><code>kubectl apply -f echo-service.yaml\nkubectl apply -f echo-mapping.yaml\n</code></pre>"},{"location":"getting-started/ambassador/#3-deploy-the-echo-service","title":"3. Deploy the Echo Service","text":"<p>Create a Rollout resource and save it to a file called <code>rollout.yaml</code>. Note the <code>trafficRouting</code> attribute, which tells Argo to use Ambassador Edge Stack for routing.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: echo-rollout\nspec:\n  selector:\n    matchLabels:\n      app: echo\n  template:\n    metadata:\n      labels:\n        app: echo\n    spec:\n      containers:\n        - image: hashicorp/http-echo\n          args:\n            - \"-text=VERSION 1\"\n            - -listen=:8080\n          imagePullPolicy: Always\n          name: echo-v1\n          ports:\n            - containerPort: 8080\n  strategy:\n    canary:\n      stableService: echo-stable\n      canaryService: echo-canary\n      trafficRouting:\n        ambassador:\n          mappings:\n            - echo\n      steps:\n      - setWeight: 30\n      - pause: {duration: 30s}\n      - setWeight: 60\n      - pause: {duration: 30s}\n      - setWeight: 100\n      - pause: {duration: 10}\n</code></pre> <p>Apply the rollout to your cluster <code>kubectl apply -f rollout.yaml</code>. Note that no canary rollout will occur, as this is the first version of the service being deployed. </p>"},{"location":"getting-started/ambassador/#4-test-the-service","title":"4. Test the service","text":"<p>We'll now test that this rollout works as expected.  Open a new terminal window. We'll use it to send requests to the cluster. Get the external IP address for Edge Stack:</p> <pre><code>export AMBASSADOR_LB_ENDPOINT=$(kubectl -n ambassador get svc ambassador -o \"go-template={{range .status.loadBalancer.ingress}}{{or .ip .hostname}}{{end}}\")\n</code></pre> <p>Send a request to the <code>echo</code> service:  </p> <pre><code>curl -Lk \"https://$AMBASSADOR_LB_ENDPOINT/echo/\"\n</code></pre> <p>You should get a response of \"VERSION 1\".</p>"},{"location":"getting-started/ambassador/#5-rollout-a-new-version","title":"5. Rollout a new version","text":"<p>It's time to rollout a new version of the service. Update the echo container in the <code>rollout.yaml</code> to display \"VERSION 2\":</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: echo-rollout\nspec:\n  selector:\n    matchLabels:\n      app: echo\n  template:\n    metadata:\n      labels:\n        app: echo\n    spec:\n      containers:\n        - image: hashicorp/http-echo\n          args:\n            - \"-text=VERSION 2\"\n            - -listen=:8080\n          imagePullPolicy: Always\n          name: echo-v1\n          ports:\n            - containerPort: 8080\n  strategy:\n    canary:\n      stableService: echo-stable\n      canaryService: echo-canary\n      trafficRouting:\n        ambassador:\n          mappings:\n            - echo\n      steps:\n      - setWeight: 30\n      - pause: {duration: 30s}\n      - setWeight: 60\n      - pause: {duration: 30s}\n      - setWeight: 100\n      - pause: {duration: 10}\n</code></pre> <p>Apply the rollout to the cluster by typing <code>kubectl apply -f rollout.yaml</code>. This will rollout a version 2 of the service by routing 30% of traffic to the service for 30 seconds, followed by 60% of traffic for another 30 seconds.</p> <p>You can monitor the status of your rollout at the command line:</p> <pre><code>kubectl argo rollouts get rollout echo-rollout --watch\n</code></pre> <p>Will display an output similar to the following:</p> <pre><code>Name:            echo-rollout\nNamespace:       default\nStatus:          \u0965 Paused\nMessage:         CanaryPauseStep\nStrategy:        Canary\n  Step:          1/6\n  SetWeight:     30\n  ActualWeight:  30\nImages:          hashicorp/http-echo (canary, stable)\nReplicas:\n  Desired:       1\n  Current:       2\n  Updated:       1\n  Ready:         2\n  Available:     2\n\nNAME                                      KIND        STATUS        AGE    INFO\n\u27f3 echo-rollout                            Rollout     \u0965 Paused      2d21h\n\u251c\u2500\u2500# revision:3\n\u2502  \u2514\u2500\u2500\u29c9 echo-rollout-64fb847897           ReplicaSet  \u2714 Healthy     2s     canary\n\u2502     \u2514\u2500\u2500\u25a1 echo-rollout-64fb847897-49sg6  Pod         \u2714 Running     2s     ready:1/1\n\u251c\u2500\u2500# revision:2\n\u2502  \u2514\u2500\u2500\u29c9 echo-rollout-578bfdb4b8           ReplicaSet  \u2714 Healthy     3h5m   stable\n\u2502     \u2514\u2500\u2500\u25a1 echo-rollout-578bfdb4b8-86z6n  Pod         \u2714 Running     3h5m   ready:1/1\n\u2514\u2500\u2500# revision:1\n   \u2514\u2500\u2500\u29c9 echo-rollout-948d9c9f9            ReplicaSet  \u2022 ScaledDown  2d21h\n</code></pre> <p>In your other terminal window, you can verify that the canary is progressing appropriately by sending requests in a loop:</p> <pre><code>while true; do curl -k https://$AMBASSADOR_LB_ENDPOINT/echo/; sleep 0.2; done\n</code></pre> <p>This will display a running list of responses from the service that will gradually transition from VERSION 1 strings to VERSION 2 strings.</p> <p>For more details about the Ambassador and Argo-Rollouts integration, see the Ambassador Argo documentation.</p>"},{"location":"getting-started/appmesh/","title":"Getting Started - App Mesh","text":"<p>This guide covers how Argo Rollouts integrates with service-meshes managed by AWS App Mesh. This guide builds upon the concepts of the basic getting started guide.</p>"},{"location":"getting-started/appmesh/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes cluster with AWS App Mesh Controller for K8s installed</li> </ul> <p>Tip</p> <p>See the App Mesh Controler Installation instructions on how to get started using App Mesh with Kubernetes.</p>"},{"location":"getting-started/appmesh/#1-deploy-the-rollout-services-app-mesh-crd","title":"1. Deploy the Rollout, Services, App Mesh CRD","text":"<p>When App Mesh is used as the traffic router, the Rollout canary strategy must define the following mandatory fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: my-rollout\nspec:\n  strategy:\n    canary:\n      # canaryService and stableService are references to Services which the Rollout will modify\n      # to target the canary ReplicaSet and stable ReplicaSet respectively (required).\n      canaryService: my-svc-canary\n      stableService: my-svc-stable\n      trafficRouting:\n        appMesh:\n          # The referenced virtual-service will be used to determine the virtual-router that is\n          # manipulated to update canary weights.\n          virtualService:\n            # name of the virtual-service App Mesh CR\n            name: my-svc\n            # Optional set of routes to update. If empty, all routes associated with the virtual-service are updated.\n            routes:\n            - http-primary\n          # virtualNodeGroup is a structure to refer App Mesh virtual-node CR corresponding to Canary and Stable versions\n          virtualNodeGroup:\n            # canaryVirtualNodeRef refers to virtual-node corresponding to canary version. Rollouts controller will\n            # update the podSelector of this virtual-node to latest canary pod-hash generated by controller.\n            canaryVirtualNodeRef:\n              name: my-vn-canary\n            # stableVirtualNodeRef refers to virtual-node corresponding to stable version. Rollouts controller will\n            # update the podSelector of this virtual-node to latest stable pod-hash generated by controller.\n            stableVirtualNodeRef:\n              name: my-vn-stable\n      steps:\n      - setWeight: 25\n      - pause: {}\n      ...\n</code></pre> <p>In this guide, the two services are: <code>my-svc-canary</code> and <code>my-svc-stable</code> respectively. There are two virtual-node CRs corresponding to these services named <code>my-vn-canary</code> and <code>my-vn-stable</code> respectively. In addition, there is a virtual-service named <code>rollout-demo-vsvc</code> that is provided by a virtual-router CR named <code>rollout-demo-vrouter</code>. This virtual-router need have at least one route with action to forward traffic to the canary and stable virtual-nodes. Initially weight for canary is set to 0% while for stable it is 100%. During rollout, controller will modify the weights on route(s) based on the configuraiton defined in <code>steps[N].setWeight</code>.</p> <p>The canary and stable services are configured to be headless. This is necessary to allow App Mesh to properly handle conneciton pooling as pods are reassigned from canary to stable.</p> <p>To summarize, run the following commands to deploy a service:</p> <ul> <li>Two services (stable and canary)</li> <li>One service (for VIP and DNS lookup)</li> <li>Two App Mesh virtual-nodes (stable and canary)</li> <li>One App Mesh virtual-router with routes to virtual-nodes</li> <li>One App Mesh virtual-service corresponding to VIP service</li> <li>A rollout</li> </ul> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/examples/appmesh/canary-service.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/examples/appmesh/canary-rollout.yaml\n</code></pre>"},{"location":"getting-started/appmesh/#2-verify-service","title":"2. Verify service","text":"<p>First make sure that rollout is stable.</p> <pre><code>kubectl argo rollouts get rollout my-rollout -n argo-examples -w\n</code></pre> <p>Then make sure the service is functional.</p> <pre><code>kubectl -n argo-examples port-forward svc/my-svc 8181:80\n</code></pre>"},{"location":"getting-started/appmesh/#3-rollout-new-version","title":"3. Rollout new version","text":"<p>Now its time to deploy new version. Update the rollout with new image.</p> <pre><code>kubectl argo rollouts set image my-rollout demo=argoproj/rollouts-demo:green -n argo-examples\n</code></pre> <p>Rollout should deploy a new canary revision and update the weights under virtual-router.</p> <pre><code>kubectl get -n argo-examples virtualrouter my-vrouter -o json | jq \".spec.routes[0].httpRoute.action.weightedTargets\"\n[\n  {\n    \"virtualNodeRef\": {\n      \"name\": \"my-vn-canary\"\n    },\n    \"weight\": 25\n  },\n  {\n    \"virtualNodeRef\": {\n      \"name\": \"my-vn-stable\"\n    },\n    \"weight\": 75\n  }\n]\n</code></pre> <p>Now manually approve the rollout that is paused indefinitely, and continue watching the routes get updated</p> <pre><code>kubectl argo rollouts promote my-rollout -n argo-examples\n\nwatch -d 'kubectl get -n argo-examples virtualrouter my-vrouter -o json | jq \".spec.routes[0].httpRoute.action.weightedTargets\"'\n</code></pre>"},{"location":"getting-started/istio/","title":"Getting Started - Istio","text":"<p>This guide covers how Argo Rollouts integrates with the Istio Service Mesh for traffic shaping. This guide builds upon the concepts of the basic getting started guide.</p>"},{"location":"getting-started/istio/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes cluster with Istio installed</li> </ul> <p>Tip</p> <p>See the environment setup guide for Istio on how to setup a local minikube environment with Istio</p>"},{"location":"getting-started/istio/#1-deploy-the-rollout-services-istio-virtualservice-and-istio-gateway","title":"1. Deploy the Rollout, Services, Istio VirtualService, and Istio Gateway","text":"<p>When Istio is used as the traffic router, the Rollout canary strategy must define the following mandatory fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollouts-demo\nspec:\n  strategy:\n    canary:\n      # Reference to a Service which the controller updates to point to the canary ReplicaSet\n      canaryService: rollouts-demo-canary\n      # Reference to a Service which the controller updates to point to the stable ReplicaSet\n      stableService: rollouts-demo-stable\n      trafficRouting:\n        istio:\n          virtualServices:\n          # One or more virtualServices can be configured\n          # Reference to a VirtualService which the controller updates with canary weights\n          - name: rollouts-demo-vsvc1\n            # Optional if there is a single HTTP route in the VirtualService, otherwise required\n            routes:\n            - http-primary\n            # Optional if there is a single HTTPS/TLS route in the VirtualService, otherwise required\n            tlsRoutes:\n            # Below fields are optional but if defined, they should match exactly with at least one of the TLS route match rules in your VirtualService\n            - port: 443 # Only required if you want to match any rule in your VirtualService which contains this port\n              # Only required if you want to match any rule in your VirtualService which contain all these SNI hosts\n              sniHosts:\n              - reviews.bookinfo.com\n              - localhost\n          - name: rollouts-demo-vsvc2\n            # Optional if there is a single HTTP route in the VirtualService, otherwise required\n            routes:\n              - http-secondary\n            # Optional if there is a single HTTPS/TLS route in the VirtualService, otherwise required\n            tlsRoutes:\n              # Below fields are optional but if defined, they should match exactly with at least one of the TLS route match rules in your VirtualService\n              - port: 443 # Only required if you want to match any rule in your VirtualService which contains this port\n                # Only required if you want to match any rule in your VirtualService which contain all these SNI hosts\n                sniHosts:\n                  - reviews.bookinfo.com\n                  - localhost\n            tcpRoutes:\n              # Below fields are optional but if defined, they should match exactly with at least one of the TCP route match rules in your VirtualService\n              - port: 8020 # Only required if you want to match any rule in your VirtualService which contains this port\n</code></pre> <p>The VirtualService and route referenced in either <code>trafficRouting.istio.virtualService</code> or <code>trafficRouting.istio.virtualServices</code>. <code>trafficRouting.istio.virtualServices</code> helps in adding one or more virtualServices unlike <code>trafficRouting.istio.virtualService</code> where only single virtualService can be added. This is required to have either HTTP, TLS, TCP or a mixed route specs that splits between the stable and the canary services referenced in the rollout. If the route is HTTPS/TLS, we can match it based on the given port number and/or SNI hosts. Note that both of them are optional and only needed if you want to match any rule in your VirtualService which contains these.</p> <p>In this guide, the two services are: <code>rollouts-demo-stable</code> and <code>rollouts-demo-canary</code> respectively. The weights for these two services should initially be set to 100% on the stable service and 0% on the canary service. During an update, these values will get modified by the controller. If there are multiple VirtualService then weight values for stable and canary service of each VirtualService will be modified by the controller simultaneously.</p> <p>Note that since we have both the HTTP and HTTPS routes in our rollout spec and they match the VirtualService specs, weights will get modified for both these routes.</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: rollouts-demo-vsvc1\nspec:\n  gateways:\n  - rollouts-demo-gateway\n  hosts:\n  - rollouts-demo-vsvc1.local\n  http:\n  - name: http-primary  # Should match rollout.spec.strategy.canary.trafficRouting.istio.virtualServices.routes\n    route:\n    - destination:\n        host: rollouts-demo-stable  # Should match rollout.spec.strategy.canary.stableService\n        port:\n          number: 15372\n      weight: 100\n    - destination:\n        host: rollouts-demo-canary  # Should match rollout.spec.strategy.canary.canaryService\n        port:\n          number: 15372\n      weight: 0\n  tls:\n  - match:\n    - port: 443  # Should match the port number of the route defined in rollout.spec.strategy.canary.trafficRouting.istio.virtualServices.tlsRoutes\n      sniHosts: # Should match all the SNI hosts of the route defined in rollout.spec.strategy.canary.trafficRouting.istio.virtualServices.tlsRoutes\n      - reviews.bookinfo.com\n      - localhost\n    route:\n    - destination:\n        host: rollouts-demo-stable  # Should match rollout.spec.strategy.canary.stableService\n      weight: 100\n    - destination:\n        host: rollouts-demo-canary  # Should match rollout.spec.strategy.canary.canaryService\n      weight: 0\n  tcp:\n  - match:\n      - port: 8020 # Should match the port number of the route defined in rollout.spec.strategy.canary.trafficRouting.istio.virtualServices.tcpRoutes\n    route:\n    - destination:\n        host: rollouts-demo-stable # Should match rollout.spec.strategy.canary.stableService\n      weight: 100\n    - destination:\n        host: rollouts-demo-canary # Should match rollout.spec.strategy.canary.canaryService\n      weight: 0\n</code></pre> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: rollouts-demo-vsvc2\nspec:\n  gateways:\n  - rollouts-demo-gateway\n  hosts:\n  - rollouts-demo-vsvc2.local\n  http:\n  - name: http-secondary  # Should match rollout.spec.strategy.canary.trafficRouting.istio.virtualServices.routes\n    route:\n    - destination:\n        host: rollouts-demo-stable  # Should match rollout.spec.strategy.canary.stableService\n        port:\n          number: 15373\n      weight: 100\n    - destination:\n        host: rollouts-demo-canary  # Should match rollout.spec.strategy.canary.canaryService\n        port:\n          number: 15373\n      weight: 0\n  tls:\n  - match:\n    - port: 443  # Should match the port number of the route defined in rollout.spec.strategy.canary.trafficRouting.istio.virtualServices.tlsRoutes\n      sniHosts: # Should match all the SNI hosts of the route defined in rollout.spec.strategy.canary.trafficRouting.istio.virtualServices.tlsRoutes\n      - reviews.bookinfo.com\n    route:\n    - destination:\n        host: rollouts-demo-stable  # Should match rollout.spec.strategy.canary.stableService\n      weight: 100\n    - destination:\n        host: rollouts-demo-canary  # Should match rollout.spec.strategy.canary.canaryService\n      weight: 0\n  tcp:\n  - match:\n    - port: 8020  # Should match the port number of the route defined in rollout.spec.strategy.canary.trafficRouting.istio.virtualServices.tcpRoutes\n    route:\n    - destination:\n        host: rollouts-demo-stable  # Should match rollout.spec.strategy.canary.stableService\n      weight: 100\n    - destination:\n        host: rollouts-demo-canary  # Should match rollout.spec.strategy.canary.canaryService\n      weight: 0\n</code></pre> <p>Run the following commands to deploy:</p> <ul> <li>A Rollout</li> <li>Two Services (stable and canary)</li> <li>One or more Istio VirtualServices</li> <li>An Istio Gateway</li> </ul> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/istio/rollout.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/istio/services.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/istio/multipleVirtualsvc.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/istio/gateway.yaml\n</code></pre> <p>After applying the manifests you should see the following rollout, services, virtualservices, and gateway resources in the cluster:</p> <pre><code>$ kubectl get ro\nNAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE\nrollouts-demo   1         1         1            1\n\n$ kubectl get svc\nNAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE\nrollouts-demo-canary   ClusterIP   10.103.146.137   &lt;none&gt;        80/TCP    37s\nrollouts-demo-stable   ClusterIP   10.101.158.227   &lt;none&gt;        80/TCP    37s\n\n$ kubectl get virtualservice\nNAME                  GATEWAYS                  HOSTS                         AGE\nrollouts-demo-vsvc1   [rollouts-demo-gateway]   [rollouts-demo-vsvc1.local]   54s\nrollouts-demo-vsvc2   [rollouts-demo-gateway]   [rollouts-demo-vsvc2.local]   54s\n\n$ kubectl get gateway\nNAME                    AGE\nrollouts-demo-gateway   71s\n</code></pre> <pre><code>kubectl argo rollouts get rollout rollouts-demo\n</code></pre> <p></p>"},{"location":"getting-started/istio/#2-perform-an-update","title":"2. Perform an update","text":"<p>Update the rollout by changing the image, and wait for it to reached the paused state.</p> <pre><code>kubectl argo rollouts set image rollouts-demo rollouts-demo=argoproj/rollouts-demo:yellow\nkubectl argo rollouts get rollout rollouts-demo\n</code></pre> <p></p> <p>At this point, both the canary and stable version of the Rollout are running, with 5% of the traffic directed to the canary. To understand how this works, inspect the VirtualService which the Rollout was referencing. When looking at both the VirtualService, we see that the route destination weights have been modified by the controller to reflect the current weight of the canary.</p> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: rollouts-demo-vsvc1\n  namespace: default\nspec:\n  gateways:\n  - rollouts-demo-gateway\n  hosts:\n  - rollouts-demo-vsvc1.local\n  http:\n  - name: http-primary\n    route:\n    - destination:\n        host: rollouts-demo-stable\n        port:\n          number: 15372\n      weight: 95\n    - destination:\n        host: rollouts-demo-canary\n        port:\n          number: 15372\n      weight: 5\n  tls:\n  - match:\n    - port: 443\n      sniHosts:\n      - reviews.bookinfo.com\n      - localhost\n    route:\n    - destination:\n        host: rollouts-demo-stable\n      weight: 95\n    - destination:\n        host: rollouts-demo-canary\n      weight: 5\n  tcp:\n  - match:\n    - port: 8020\n    route:\n    - destination:\n        host: rollouts-demo-stable\n      weight: 95\n    - destination:\n        host: rollouts-demo-canary\n      weight: 5\n</code></pre> <pre><code>apiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: rollouts-demo-vsvc2\n  namespace: default\nspec:\n  gateways:\n  - rollouts-demo-gateway\n  hosts:\n  - rollouts-demo-vsvc2.local\n  http:\n  - name: http-primary\n    route:\n    - destination:\n        host: rollouts-demo-stable\n        port:\n          number: 15373\n      weight: 95\n    - destination:\n        host: rollouts-demo-canary\n        port:\n          number: 15373\n      weight: 5\n  tls:\n  - match:\n    - port: 443\n      sniHosts:\n      - reviews.bookinfo.com\n    route:\n    - destination:\n        host: rollouts-demo-stable\n      weight: 95\n    - destination:\n        host: rollouts-demo-canary\n      weight: 5\n  tcp:\n  - match:\n    - port: 8020\n    route:\n    - destination:\n        host: rollouts-demo-stable\n      weight: 95\n    - destination:\n        host: rollouts-demo-canary\n      weight: 5\n</code></pre> <p>As the Rollout progresses through steps, the HTTP, TLS, and/or TCP route(s) destination weights will be adjusted to match the current <code>setWeight</code> of the steps.</p>"},{"location":"getting-started/mixed/","title":"Getting Started - Multiple Providers (Service Mesh Interface and NGiNX Ingress)","text":"<p>Important</p> <p>Available since v1.2</p> <p>This guide covers how Argo Rollouts integrates with multiple TrafficRoutings, using Linkerd and NGINX Ingress Controller for traffic shaping, but you should be able to produce any other combination between the existing trafficRouting options.</p> <p>This guide builds upon the concepts of the basic getting started guide, NGINX Guide, and SMI Guide.</p>"},{"location":"getting-started/mixed/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes cluster with Linkerd installed</li> <li>Kubernetes cluster with NGINX ingress controller installed and part of the mesh</li> </ul> <p>Tip</p> <p>See the environment setup guide for linkerd on how to setup a local minikube environment with linkerd and nginx.</p>"},{"location":"getting-started/mixed/#1-deploy-the-rollout-services-and-ingress","title":"1. Deploy the Rollout, Services, and Ingress","text":"<p>When SMI is used as one the traffic routers, the Rollout canary strategy must define the following mandatory fields:</p> <p><pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollouts-demo\nspec:\n  strategy:\n    canary:\n      # Reference to a Service which the controller will update to point to the canary ReplicaSet\n      canaryService: rollouts-demo-canary\n      # Reference to a Service which the controller will update to point to the stable ReplicaSet\n      stableService: rollouts-demo-stable\n      trafficRouting:\n        smi: {}\n</code></pre> When NGINX Ingress is used as the traffic router, the Rollout canary strategy must define the following mandatory fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollouts-demo\nspec:\n  strategy:\n    canary:\n      # Reference to a Service which the controller will update to point to the canary ReplicaSet\n      canaryService: rollouts-demo-canary\n      # Reference to a Service which the controller will update to point to the stable ReplicaSet\n      stableService: rollouts-demo-stable\n      trafficRouting:\n        nginx:\n          # Reference to an Ingress which has a rule pointing to the stable service (e.g. rollouts-demo-stable)\n          # This ingress will be cloned with a new name, in order to achieve NGINX traffic splitting.\n          stableIngress: rollouts-demo-stable\n...\n</code></pre> <p>A combination of both should have comply with each TrafficRouting requirements, in this case:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollouts-demo\nspec:\n  strategy:\n    canary:\n      # Reference to a Service which the controller will update to point to the canary ReplicaSet\n      canaryService: rollouts-demo-canary\n      # Reference to a Service which the controller will update to point to the stable ReplicaSet\n      stableService: rollouts-demo-stable\n      trafficRouting:\n        nginx:\n          # Reference to an Ingress which has a rule pointing to the stable service (e.g. rollouts-demo-stable)\n          # This ingress will be cloned with a new name, in order to achieve NGINX traffic splitting.\n          stableIngress: rollouts-demo-stable\n        smi: {}\n</code></pre> <p>The Ingress referenced in <code>canary.trafficRouting.nginx.stableIngress</code> is required to have a host rule which has a backend targeting the Service referenced under <code>canary.stableService</code>. In our example, that stable Service is named: <code>rollouts-demo-stable</code>:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: rollouts-demo-stable\n  annotations:\n    kubernetes.io/ingress.class: nginx\nspec:\n  rules:\n  - host: rollouts-demo.local\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            # Reference to a Service name, also specified in the Rollout spec.strategy.canary.stableService field\n            name: rollouts-demo-stable\n            port:\n              number: 80\n</code></pre> <p>Run the following commands to deploy:</p> <ul> <li>A Rollout with the Linkerd <code>linkerd.io/inject: enabled</code> annotation</li> <li>Two Services (stable and canary)</li> <li>An Ingress</li> </ul> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/mixed/rollout.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/mixed/services.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/mixed/ingress.yaml\n</code></pre> <p>After applying the manifests you should see the following rollout, services, and ingress resources in the cluster:</p> <pre><code>$ kubectl get ro\nNAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE\nrollouts-demo   1         2         1            2\n\n$ kubectl get svc\nNAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE\nrollouts-demo-canary   ClusterIP   10.111.69.188    &lt;none&gt;        80/TCP    23m\nrollouts-demo-stable   ClusterIP   10.109.175.248   &lt;none&gt;        80/TCP    23m\n\n$ kubectl get ing\nNAME                   CLASS    HOSTS                 ADDRESS        PORTS   AGE\nrollouts-demo-stable   &lt;none&gt;   rollouts-demo.local   192.168.64.2   80      23m\n</code></pre> <p>You should also see a TrafficSplit resource which is created automatically and owned by the rollout:</p> <pre><code>$ kubectl get trafficsplit\nNAME            SERVICE\nrollouts-demo   rollouts-demo-stable\n</code></pre> <p>When inspecting the generated TrafficSplit resource, the weights are automatically configured to send 100% traffic to the <code>rollouts-demo-stable</code> service, and 0% traffic to the <code>rollouts-demo-canary</code>. These values will be updated during an update.</p> <pre><code>apiVersion: split.smi-spec.io/v1alpha1\nkind: TrafficSplit\nmetadata:\n  name: rollouts-demo\n  namespace: default\nspec:\n  backends:\n  - service: rollouts-demo-canary\n    weight: \"0\"\n  - service: rollouts-demo-stable\n    weight: \"100\"\n  service: rollouts-demo-stable\n</code></pre> <p>You should also notice a second ingress created by the rollouts controller, <code>rollouts-demo-rollouts-demo-stable-canary</code>. This ingress is the \"canary ingress\", which is a clone of the user-managed Ingress referenced under <code>nginx.stableIngress</code>. It is used by nginx ingress controller to achieve canary traffic splitting. The name of the generated ingress is formulated using <code>&lt;ROLLOUT-NAME&gt;-&lt;INGRESS-NAME&gt;-canary</code>. More details on the second Ingress are discussed in the following section.</p>"},{"location":"getting-started/mixed/#2-perform-an-update","title":"2. Perform an update","text":"<p>Now perform an update the rollout by changing the image, and wait for it to reached the paused state.</p> <pre><code>kubectl argo rollouts set image rollouts-demo rollouts-demo=argoproj/rollouts-demo:yellow\nkubectl argo rollouts get rollout rollouts-demo\n</code></pre> <p></p> <p>At this point, both the canary and stable version of the Rollout are running, with 5% of the traffic directed to the canary and 95% to the stable. When inspecting the TrafficSplit generated by the controller, we see that the weight has been updated to reflect the current <code>setWeight: 5</code> step of the canary deploy.</p> <p><pre><code>apiVersion: split.smi-spec.io/v1alpha1\nkind: TrafficSplit\nmetadata:\n  name: rollouts-demo\n  namespace: default\nspec:\n  backends:\n  - service: rollouts-demo-canary\n    weight: \"5\"\n  - service: rollouts-demo-stable\n    weight: \"95\"\n  service: rollouts-demo-stable\n</code></pre> When inspecting the rollout controller generated Ingress copy, we see that it has the following changes over the original ingress:</p> <ol> <li>Two additional NGINX specific canary annotations are added to the annotations.</li> <li>The Ingress rules will have an rule which points the backend to the canary service.</li> </ol> <pre><code>apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: rollouts-demo-rollouts-demo-stable-canary\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/canary: \"true\"\n    nginx.ingress.kubernetes.io/canary-weight: \"5\"\nspec:\n  rules:\n  - host: rollouts-demo.local\n    http:\n      paths:\n      - backend:\n          serviceName: rollouts-demo-canary\n          servicePort: 80\n</code></pre> <p>As the Rollout progresses through steps, the weights in the TrafficSplit and Ingress resource will be adjusted to match the current setWeight of the steps.</p>"},{"location":"getting-started/nginx/","title":"Getting Started - NGINX Ingress","text":"<p>This guide covers how Argo Rollouts integrates with the NGINX Ingress Controller for traffic shaping. This guide builds upon the concepts of the basic getting started guide.</p>"},{"location":"getting-started/nginx/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes cluster with NGINX ingress controller installed</li> </ul> <p>Tip</p> <p>See the environment setup guide for NGINX on how to setup a local minikube environment with nginx.</p>"},{"location":"getting-started/nginx/#1-deploy-the-rollout-services-and-ingress","title":"1. Deploy the Rollout, Services, and Ingress","text":"<p>When NGINX Ingress is used as the traffic router, the Rollout canary strategy must define the following mandatory fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollouts-demo\nspec:\n  strategy:\n    canary:\n      # Reference to a Service which the controller will update to point to the canary ReplicaSet\n      canaryService: rollouts-demo-canary\n      # Reference to a Service which the controller will update to point to the stable ReplicaSet\n      stableService: rollouts-demo-stable\n      trafficRouting:\n        nginx:\n          # Reference to an Ingress which has a rule pointing to the stable service (e.g. rollouts-demo-stable)\n          # This ingress will be cloned with a new name, in order to achieve NGINX traffic splitting.\n          stableIngress: rollouts-demo-stable\n...\n</code></pre> <p>The Ingress referenced in <code>canary.trafficRouting.nginx.stableIngress</code> is required to have a host rule which has a backend targeting the Service referenced under <code>canary.stableService</code>. In our example, that stable Service is named: <code>rollouts-demo-stable</code>:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: rollouts-demo-stable\n  annotations:\n    kubernetes.io/ingress.class: nginx\nspec:\n  rules:\n  - host: rollouts-demo.local\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            # Reference to a Service name, also specified in the Rollout spec.strategy.canary.stableService field\n            name: rollouts-demo-stable\n            port:\n              number: 80\n</code></pre> <p>Run the following commands to deploy:</p> <ul> <li>A Rollout</li> <li>Two Services (stable and canary)</li> <li>An Ingress</li> </ul> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/nginx/rollout.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/nginx/services.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/nginx/ingress.yaml\n</code></pre> <p>After applying the manifests you should see the following rollout, services, and ingress resources in the cluster:</p> <pre><code>$ kubectl get ro\nNAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE\nrollouts-demo   1         1         1            1\n\n$ kubectl get svc\nNAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE\nrollouts-demo-canary   ClusterIP   10.96.6.241     &lt;none&gt;        80/TCP    33s\nrollouts-demo-stable   ClusterIP   10.102.229.83   &lt;none&gt;        80/TCP    33s\n\n$ kubectl get ing\nNAME                                        CLASS    HOSTS                 ADDRESS        PORTS   AGE\nrollouts-demo-stable                        &lt;none&gt;   rollouts-demo.local   192.168.64.2   80      36s\nrollouts-demo-rollouts-demo-stable-canary   &lt;none&gt;   rollouts-demo.local   192.168.64.2   80      35s\n</code></pre> <p>You should also notice a second ingress created by the rollouts controller, <code>rollouts-demo-rollouts-demo-stable-canary</code>. This ingress is the \"canary ingress\", which is a clone of the user-managed Ingress referenced under <code>nginx.stableIngress</code>. It is used by nginx ingress controller to achieve canary traffic splitting. The name of the generated ingress is formulated using <code>&lt;ROLLOUT-NAME&gt;-&lt;INGRESS-NAME&gt;-canary</code>. More details on the second Ingress are discussed in the following section.</p> <pre><code>kubectl argo rollouts get rollout rollouts-demo\n</code></pre> <p></p>"},{"location":"getting-started/nginx/#2-perform-an-update","title":"2. Perform an update","text":"<p>Update the rollout by changing the image, and wait for it to reached the paused state.</p> <pre><code>kubectl argo rollouts set image rollouts-demo rollouts-demo=argoproj/rollouts-demo:yellow\nkubectl argo rollouts get rollout rollouts-demo\n</code></pre> <p></p> <p>At this point, both the canary and stable version of the Rollout are running, with 5% of the traffic directed to the canary. One thing to note, is that the rollout is able to achieve a 5% canary weight despite only running two pods. This is able to be achieved since the traffic split happens at the ingress controller (as opposed to weighted replica counts and kube-proxy in the basic guide).</p> <p>When inspecting the rollout controller generated Ingress copy, we see that it has the following changes over the original ingress:</p> <ol> <li>Two additional NGINX specific canary annotations are added to the annotations.</li> <li>The Ingress rules will have an rule which points the backend to the canary service.</li> </ol> <pre><code>apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: rollouts-demo-rollouts-demo-stable-canary\n  annotations:\n    kubernetes.io/ingress.class: nginx\n    nginx.ingress.kubernetes.io/canary: \"true\"\n    nginx.ingress.kubernetes.io/canary-weight: \"5\"\nspec:\n  rules:\n  - host: rollouts-demo.local\n    http:\n      paths:\n      - backend:\n          serviceName: rollouts-demo-canary\n          servicePort: 80\n</code></pre> <p>As the Rollout progresses through steps, the <code>canary-weight</code> annotation will be adjusted to match the current setWeight of the steps. The NGINX ingress controller examines the original Ingress, the canary Ingress, and the canary-weight annotation to determine what percentage of traffic to split between the two Ingresses.</p>"},{"location":"getting-started/setup/","title":"Environment Set Up","text":"<p>This guide shows how to set up a local environment for development, testing, learning, or demoing purposes.</p>"},{"location":"getting-started/setup/#helm","title":"Helm","text":"<p>Some dependencies are installable via the Helm stable repository:</p> <pre><code>helm repo add stable https://charts.helm.sh/stable\nhelm repo add grafana https://grafana.github.io/helm-charts\nhelm repo add prometheus-community https://prometheus-community.github.io/helm-charts\nhelm repo update\n</code></pre>"},{"location":"getting-started/setup/#minikube","title":"Minikube","text":""},{"location":"getting-started/setup/#nginx-ingress-controller-setup","title":"NGINX Ingress Controller Setup","text":"<p>The following instructions describe how to configure NGINX Ingress Controller on minikube. For basic ingress support, only the \"ingress\" addon needs to be enabled:</p> <pre><code>minikube addons enable ingress\n</code></pre> <p>Optionally, Prometheus and Grafana can be installed to utilize progressive delivery functionality:</p> <pre><code># Install Prometheus\nkubectl create ns monitoring\nhelm install prometheus prometheus-community/prometheus -n monitoring -f docs/getting-started/setup/values-prometheus.yaml\n\n# Patch the ingress-nginx-controller pod so that it has the required\n# prometheus annotations. This allows the pod to be scraped by the\n# prometheus server.\nkubectl patch deploy ingress-nginx-controller -n ingress-nginx -p \"$(cat docs/getting-started/setup/ingress-nginx-controller-metrics-scrape.yaml)\"\n</code></pre> <p>Note</p> <p>For Minikube version 1.18.1 or earlier,  change the <code>-n</code> parameter value (namespace) to <code>kube-system</code>.</p> <pre><code># Install grafana along with nginx ingress dashboards\nhelm install grafana grafana/grafana -n monitoring -f docs/getting-started/setup/values-grafana-nginx.yaml\n\n# Grafana UI can be accessed by running:\nminikube service grafana -n monitoring\n</code></pre>"},{"location":"getting-started/setup/#istio-setup","title":"Istio Setup","text":"<p>The following instructions describe how to configure Istio on minikube.</p> <pre><code># Istio on Minikube requires additional memory and CPU\nminikube start --memory=8192mb --cpus=4\n\n# Install istio\nminikube addons enable istio-provisioner\nminikube addons enable istio\n\n# Label the default namespace to enable istio sidecar injection for the namespace\nkubectl label namespace default istio-injection=enabled\n</code></pre> <p>Istio already comes with a Prometheus database ready to use. To visualize metrics about istio services, Grafana and Istio dashboards can be installed via Helm to leverage progressive delivery functionality:</p> <pre><code># Install Grafana and Istio dashboards\nhelm install grafana grafana/grafana -n istio-system -f docs/getting-started/setup/values-grafana-istio.yaml\n\n# Grafana UI can be accessed by running\nminikube service grafana -n istio-system\n</code></pre> <p>In order for traffic to enter the Istio mesh, the request needs to go through an Istio ingress gateway, which is simply a normal Kubernetes Deployment and Service. One convenient way to reach the gateway using minikube, is using the <code>minikube tunnel</code> command, which assigns Services a  LoadBalancer. This command should be run in the background, usually in a separate terminal window:</p> <pre><code>minikube tunnel\n</code></pre> <p>While running <code>minikube tunnel</code>, the <code>istio-ingressgateway</code> Service will now have an external IP which can be retrieved via <code>kubectl</code>:</p> <pre><code>$ kubectl get svc -n istio-system istio-ingressgateway\nNAME                   TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)                            AGE\nistio-ingressgateway   LoadBalancer   10.100.136.45   10.100.136.45   15020:31711/TCP,80:31298/TCP....   7d22h\n</code></pre> <p>The LoadBalancer external IP (10.100.136.45 in this example) is now reachable to access services in the Istio mesh. Istio routes requests to the correct pod based on the Host HTTP header. Follow the guide on supplying host headers to learn how to configure your client environment to supply the proper request to reach the pod.</p>"},{"location":"getting-started/setup/#linkerd-setup","title":"Linkerd Setup","text":"<p>Linkerd can be installed using the linkerd CLI.</p> <pre><code>brew install linkerd\nlinkerd install | kubectl apply -f -\n</code></pre> <p>Linkerd does not provide its own ingress controller, choosing instead to work alongside your ingress controller of choice. On minikube, we can use the built-in NGINX ingress addon and reconfigure it to be part of the linkerd mesh.</p> <pre><code># Install the NGINX ingress controller addon\nminikube addons enable ingress\n\n# Patch the nginx-ingress-controller deployment to allow injection of the linkerd proxy to the\n# pod, so that it will be part of the mesh.\nkubectl patch deploy ingress-nginx-controller -n kube-system \\\n  -p '{\"spec\":{\"template\":{\"metadata\":{\"annotations\":{\"linkerd.io/inject\":\"enabled\"}}}}}'\n</code></pre>"},{"location":"getting-started/setup/#supplying-host-headers","title":"Supplying Host Headers","text":"<p>Most ingress controllers and service mesh implementations rely on the  Host HTTP request header being supplied in the request in order to determine how to route the request to the correct pod.</p>"},{"location":"getting-started/setup/#determining-the-hostname-to-ip-mapping","title":"Determining the hostname to IP mapping","text":"<p>For the Host header to be set in the request, the hostname of the service should resolve to the public IP address of the ingress or service mesh. Depending on if you are using an ingress controller or a service mesh, use one of the following techniques to determine the correct hostname to IP mapping:</p>"},{"location":"getting-started/setup/#ingresses","title":"Ingresses","text":"<p>For traffic which is reaching the cluster network via a normal Kubernetes Ingress, the hostname should map to the IP of the ingress. We can retrieve the external IP of the ingress from the Ingress object itself, using <code>kubectl</code>:</p> <pre><code>$ kubectl get ing rollouts-demo-stable\nNAME                   CLASS    HOSTS                 ADDRESS        PORTS   AGE\nrollouts-demo-stable   &lt;none&gt;   rollouts-demo.local   192.168.64.2   80      80m\n</code></pre> <p>In the example above, the hostname <code>rollouts-demo.local</code> should be configured to resolve to the IP <code>192.168.64.2</code>. The next section describes various ways to configure your local system to resolve the hostname to the desired IP.</p>"},{"location":"getting-started/setup/#istio","title":"Istio","text":"<p>In the case of Istio, traffic enters the mesh through an Ingress Gateway, which simply is a load balancer sitting at the edge of mesh.</p> <p>To determine the correct hostname to IP mapping, it largely depends on what was configured in the  <code>VirtualService</code> and <code>Gateway</code>. If you are following the Istio getting started guide, the examples use the \"default\" istio  ingress gateway, which we can obtain from kubectl:</p> <pre><code>$ kubectl get svc -n istio-system istio-ingressgateway\nNAME                   TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)                            AGE\nistio-ingressgateway   LoadBalancer   10.100.136.45   10.100.136.45   15020:31711/TCP,80:31298/TCP....   7d22h\n</code></pre> <p>In the above example, the hostname <code>rollouts-demo.local</code> should be configured to resolve to the IP <code>10.100.136.45</code>. The next section describes various ways to configure your local system to resolve the hostname to the desired IP.</p>"},{"location":"getting-started/setup/#configuring-local-hostname-resolution","title":"Configuring local hostname resolution","text":"<p>Now that you have determined the correct hostname to IP mapping, the next step involves configuring the system so that will resolve properly. There are different techniques to do this:</p>"},{"location":"getting-started/setup/#dns-entry","title":"DNS Entry","text":"<p>In real, production environments, the Host header is typically achieved by adding a DNS entry for the hostname in the DNS server. However, for local development, this is typically not an easily accessible option.</p>"},{"location":"getting-started/setup/#etchosts-entry","title":"/etc/hosts Entry","text":"<p>On local workstations, a local entry to <code>/etc/hosts</code> can be added to map the hostname and IP address of the ingress. For example, the following is an example of an <code>/etc/hosts</code> file which maps <code>rollouts-demo.local</code> to IP <code>10.100.136.45</code>.</p> <pre><code>##\n# Host Database\n#\n# localhost is used to configure the loopback interface\n# when the system is booting.  Do not change this entry.\n##\n127.0.0.1       localhost\n255.255.255.255 broadcasthost\n::1             localhost\n\n10.100.136.45  rollouts-demo.local\n</code></pre> <p>The advantages of using a host entry, are that it works for all clients (CLIs, browsers). On the other hand, it is harder to maintain if the IP address changes frequently.</p>"},{"location":"getting-started/setup/#supply-header-in-curl","title":"Supply Header in Curl","text":"<p>Clients such as curl, have the ability to explicitly set a header (the <code>-H</code> flag in curl). For example:</p> <pre><code>$ curl -I -H 'Host: rollouts-demo.local' http://10.100.136.45/color\nHTTP/1.1 200 OK\ncontent-type: text/plain; charset=utf-8\nx-content-type-options: nosniff\ndate: Wed, 24 Jun 2020 08:44:59 GMT\ncontent-length: 6\nx-envoy-upstream-service-time: 1\nserver: istio-envoy\n</code></pre> <p>Notice that the same request made without the header, fails with a <code>404 Not Found</code> error.</p> <pre><code>$ curl -I http://10.100.136.45/color\nHTTP/1.1 404 Not Found\ndate: Wed, 24 Jun 2020 08:46:07 GMT\nserver: istio-envoy\ntransfer-encoding: chunked\n</code></pre>"},{"location":"getting-started/setup/#browser-extension","title":"Browser Extension","text":"<p>Similar to curl's ability to explicitly set a header, browsers can also achieve this via browser extensions. One example of a browser extension which can do this, is ModHeader.</p>"},{"location":"getting-started/smi/","title":"Getting Started - SMI (Service Mesh Interface)","text":"<p>Important</p> <p>Available since v0.9</p> <p>This guide covers how Argo Rollouts integrates with the Service Mesh Interface (SMI), using Linkerd and  NGINX Ingress Controller for traffic shaping.  Since the SMI TrafficSplit resource is supported by multiple service mesh providers, the concepts taught here are applicable to other service mesh providers that support the interface. See  the SMI Ecosystem for other projects that support SMI. This guide builds upon the concepts of the basic getting started guide.</p>"},{"location":"getting-started/smi/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes cluster with Linkerd installed</li> <li>Kubernetes cluster with NGINX ingress controller installed and part of the mesh</li> </ul> <p>Tip</p> <p>See the environment setup guide for linkerd on how to setup a local minikube environment with linkerd and nginx.</p>"},{"location":"getting-started/smi/#1-deploy-the-rollout-services-and-ingress","title":"1. Deploy the Rollout, Services, and Ingress","text":"<p>When SMI is used as the traffic router, the Rollout canary strategy must define the following mandatory fields:</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: rollouts-demo\nspec:\n  strategy:\n    canary:\n      # Reference to a Service which the controller will update to point to the canary ReplicaSet\n      canaryService: rollouts-demo-canary\n      # Reference to a Service which the controller will update to point to the stable ReplicaSet\n      stableService: rollouts-demo-stable\n      trafficRouting:\n        smi: {}\n</code></pre> <p>Run the following commands to deploy:</p> <ul> <li>A Rollout with the Linkerd <code>linkerd.io/inject: enabled</code> annotation</li> <li>Two Services (stable and canary)</li> <li>An Ingress</li> </ul> <pre><code>kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/smi/rollout.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/smi/services.yaml\nkubectl apply -f https://raw.githubusercontent.com/argoproj/argo-rollouts/master/docs/getting-started/smi/ingress.yaml\n</code></pre> <p>After applying the manifests you should see the following rollout, services, and ingress resources in the cluster:</p> <pre><code>$ kubectl get ro\nNAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE\nrollouts-demo   1         2         1            2\n\n$ kubectl get svc\nNAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE\nrollouts-demo-canary   ClusterIP   10.111.69.188    &lt;none&gt;        80/TCP    23m\nrollouts-demo-stable   ClusterIP   10.109.175.248   &lt;none&gt;        80/TCP    23m\n\n$ kubectl get ing\nNAME                   CLASS    HOSTS                 ADDRESS        PORTS   AGE\nrollouts-demo-stable   &lt;none&gt;   rollouts-demo.local   192.168.64.2   80      23m\n</code></pre> <p>You should also see a TrafficSplit resource which is created automatically and owned by the rollout:</p> <pre><code>$ kubectl get trafficsplit\nNAME            SERVICE\nrollouts-demo   rollouts-demo-stable\n</code></pre> <p>When inspecting the generated TrafficSplit resource, the weights are automatically configured to send 100% traffic to the <code>rollouts-demo-stable</code> service, and 0% traffic to the <code>rollouts-demo-canary</code>. These values will be updated during an update.</p> <pre><code>apiVersion: split.smi-spec.io/v1alpha1\nkind: TrafficSplit\nmetadata:\n  name: rollouts-demo\n  namespace: default\nspec:\n  backends:\n  - service: rollouts-demo-canary\n    weight: \"0\"\n  - service: rollouts-demo-stable\n    weight: \"100\"\n  service: rollouts-demo-stable\n</code></pre>"},{"location":"getting-started/smi/#2-perform-an-update","title":"2. Perform an update","text":"<p>Now perform an update the rollout by changing the image, and wait for it to reached the paused state.</p> <pre><code>kubectl argo rollouts set image rollouts-demo rollouts-demo=argoproj/rollouts-demo:yellow\nkubectl argo rollouts get rollout rollouts-demo\n</code></pre> <p></p> <p>At this point, both the canary and stable version of the Rollout are running, with 5% of the traffic directed to the canary. When inspecting the TrafficSplit generated by the controller, we see that the weight has been updated to reflect the current <code>setWeight: 5</code> step of the canary deploy.</p> <pre><code>apiVersion: split.smi-spec.io/v1alpha1\nkind: TrafficSplit\nmetadata:\n  name: rollouts-demo\n  namespace: default\nspec:\n  backends:\n  - service: rollouts-demo-canary\n    weight: \"5\"\n  - service: rollouts-demo-stable\n    weight: \"95\"\n  service: rollouts-demo-stable\n</code></pre> <p>As the Rollout progresses through steps, the weights in the TrafficSplit resource will be adjusted to match the current setWeight of the steps.</p>"},{"location":"proposals/step-plugin/","title":"Step Plugin","text":"<p>Step plugins can be used to call code built outside of argo-rollout's codebase to execute actions during a canary rollout.</p> <p>This document provides technical implementation proposals to avoid implementing rollout steps in Argo Rollout\u2019s codebase.</p>"},{"location":"proposals/step-plugin/#summary","title":"Summary","text":"<p>Rollout steps need to be implemented natively in Argo Rollout source code. It makes it difficult for the community to add new rollout steps because their implementation is coupled with Rollout release cycle. The Rollout maintainers also have to acquire knowledge on the different technologies used in the steps and validate them on each release.</p>"},{"location":"proposals/step-plugin/#motivation","title":"Motivation","text":"<p>This section is for explicitly listing the motivation, goals and non-goals of this proposal. Describe why the change is important and the benefits to users.</p>"},{"location":"proposals/step-plugin/#goals","title":"Goals","text":"<p>The goals of this proposal are:</p> <ul> <li>Update steps outside Rollout\u2019s release cycle</li> <li>Allow the community experts to maintain their steps</li> <li>Allow for a faster step development iteration</li> <li>Allow for more features without increasing complexity on the controller</li> <li>Allow users to use proprietary steps with Argo Rollouts</li> </ul>"},{"location":"proposals/step-plugin/#non-goals","title":"Non-Goals","text":"<p>Implement plugins.</p>"},{"location":"proposals/step-plugin/#proposal","title":"Proposal","text":"<p>Rollout already has a plugin mechanism for metric providers and traffic routers as documented in https://argoproj.github.io/argo-rollouts/plugins/. The implementation is based on hashicorp/go-plugin. This mechanism can be extended to support the steps plugin.</p> <ul> <li>Consistent with existing behavior.</li> <li>Add a <code>stepPluginStatuses</code> array to the <code>.status.canary</code> field.</li> <li>Users can consult the Rollout object after the execution to get details on their status.</li> </ul>"},{"location":"proposals/step-plugin/#use-cases","title":"Use cases","text":"<p>More details in https://github.com/argoproj/argo-rollouts/issues/2685</p>"},{"location":"proposals/step-plugin/#implementation-detailsnotesconstraints","title":"Implementation Details/Notes/Constraints","text":""},{"location":"proposals/step-plugin/#configuration","title":"Configuration","text":"<p>The plugin will be configured alongside existing plugins.</p> <pre><code>kind: ConfigMap\nmetadata:\n  name: argo-rollouts-config\ndata:\n  metricProviderPlugins: |-\n    - name: \"argoproj-labs/metrics\"\n      location: \"file:///tmp/argo-rollouts/metric-plugin\"\n      args:\n        - \"--log-level\"\n        - \"debug\"\n  stepPlugins: |-\n    - name: \"argoproj-labs/curl/v2\"\n      disabled: false\n      location: \"file:///tmp/argo-rollouts/step-plugin\"\n      sha256: \"08f588b1c799a37bbe8d0fc74cc1b1492dd70abc\"\n      args:\n        - \"--log-level\"\n        - \"debug\"\n</code></pre>"},{"location":"proposals/step-plugin/#interface","title":"Interface","text":"<p>The interface implementation details related to go-plugin and rpc calls have been omitted for clarity.</p> <pre><code>type Phase string\n\nconst (\n    PhaseRunning      Phase = \"Running\"\n    PhaseSuccessful   Phase = \"Successful\"\n    PhaseFailed       Phase = \"Failed\"\n    PhaseError        Phase = \"Error\"\n)\n\ntype StepContext struct {\n    PluginName   string\n    Config       map[string]interface{}\n    Status       map[string]interface{}\n}\n\ntype StepStatus struct {\n    Index         int\n    Name          string\n    Phase         Phase\n    Message       string\n    StartedAt     Time\n    FinishedAt    Time\n    Status        map[string]interface{}\n}\n\ntype StepResult struct {\n    Phase         Phase\n    Message       string\n  RequeueAfter  Duration\n    Status        map[string]interface{}\n}\n\ntype StepPlugin interface {\n    Init() error\n    Run(Rollout, StepContext) (StepResult, error)\n    Terminate(Rollout, StepContext) (StepResult, error)\n    Abort(Rollout, StepContext) (StepResult, error)\n}\n</code></pre>"},{"location":"proposals/step-plugin/#rollout-object-plugin-input","title":"Rollout object (plugin input)","text":"<p>The step will provide rollout specific configuration defined by the users as a map of key value pairs allowing the user to pass any declarative configs to the plugin.</p> <pre><code>apiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: example-rollout\nspec:\n  strategy:\n    canary:\n      ...\n      steps:\n        - setWeight: 20\n        - plugin:\n            name: argoproj/curl\n            abortOnFailure: false    # &lt;--- example\n            progressDeadline: 30s    # &lt;--- example\n            config:\n              url: https://example.com/\n              some_key: some_value\n        - pause: {}\n        - setWeight: 40\n</code></pre>"},{"location":"proposals/step-plugin/#rollout-status-plugin-output","title":"Rollout Status (plugin output)","text":"<p>The controller will write a new object to the status. This object will be used to persist the plugin state after the step execution and to allow other steps to use it.</p> <pre><code>status:\n  canary:\n    stepPluginStatuses:\n      - index: 2\n        name: argoproj/curl\n        message: Call completed with status code 302\n        phase: Successful\n        startedAt: '2024-02-15T20:05:40Z'\n        finishedAt: '2024-02-15T20:21:40Z'\n        status: {}\n      - index: 4\n        name: argoproj/async-task\n        message: Waiting for result\n        phase: Running\n        startedAt: '2024-02-15T20:05:40Z'\n        finishedAt: null\n        status:\n          id: 12\n          path: /an/example/property\n          validated: false\n</code></pre>"},{"location":"proposals/step-plugin/#detailed-execution-flow","title":"Detailed execution flow","text":"<ol> <li>At initialization</li> </ol> <p>The plugins are loaded based on configuration and started as processes with the provided arguments in the configuration.    The <code>Init()</code> method is called for plugins to perform one-time initialization such as creating clients and establishing connections.</p> <ol> <li>A rollout reach the plugin step for the first time</li> </ol> <p>During the rollout, the controller will use the <code>currentStepIndex</code> to find the step to run.    If the step is a plugin, the controller will create a StepContext object based    on the configuration on the Rollout\u2019s step object.</p> <p>The controller will try to retrieve the value of the current <code>stepPluginStatuses</code>,    and if it matches the current step index, it will add the persisted state to the context.</p> <p>It will create a StepStatus object otherwise, set the name and index to the current step,    set the startedAt value to the current time and the phase as Running.</p> <ol> <li>Running the step plugin</li> </ol> <p>The plugin <code>Run()</code> method is called with the StepContext.    The plugin implementation will use the StepContext to perform the necessary logic.</p> <ol> <li>Status is updated</li> </ol> <p>Based on the return of the Run command, the StepStatus object is updated.    Then, the StepStatus is assigned to the stepPluginStatuses property.</p> <p>The status is persisted in the object.</p> <ol> <li>Validate step completed</li> </ol> <p>If the controller current step is of type plugin, the controller will check if the phase is successful,    and if so, go to the next step.</p> <p>If the step is still running, the controller will requeue a reconcile operation based on the value of <code>RequeueAfter</code>.</p> <p>If the phase is failed, it will update the status and conditions, aborting the rollout.</p>"},{"location":"proposals/step-plugin/#scenarios","title":"Scenarios","text":""},{"location":"proposals/step-plugin/#step-plugin-completes-successfully","title":"Step plugin completes successfully","text":"<p>The <code>stepPluginStatuses</code> will not contain any object for the current step index, the plugin will perform the desired action successfully and return a successful state.</p> <p>The state will be persisted and the controller wil execute the next step.</p>"},{"location":"proposals/step-plugin/#step-plugin-completes-with-failed-phase","title":"Step plugin completes with failed phase","text":"<p>If the step plugin returns a failed phase, the controller will set the rollout to aborted and persist the state.</p> <p>The user will receive the feedback based on the Progressing condition status. This behavior is consistent with existing mechanisms aborting a rollout.</p>"},{"location":"proposals/step-plugin/#step-plugin-completes-with-running-phase","title":"Step plugin completes with running phase","text":"<p>If the step plugin returns a running phase, the controller will persist the state, but will not increment the current step index.</p> <p>The controller will requeue a reconcile operation based on the value of <code>RequeueAfter</code> and terminate the current reconciliation.</p> <p>On the next reconciliation, the persisted state will be passed to the plugin <code>Run()</code> method.</p>"},{"location":"proposals/step-plugin/#step-plugin-is-called-multiple-times","title":"Step plugin is called multiple times","text":"<p>If an external error happens causing the controller to crash after it called the <code>Run()</code> method and before it could persist the status, the controller will replay the current plugin step, with a new context, like if it was the first time it is called.</p> <p>A step plugin can be called multiple times and operations should be idempotent.</p>"},{"location":"proposals/step-plugin/#rollout-is-fully-promoted-during-a-step-plugin","title":"Rollout is fully promoted during a step plugin","text":"<p>If a Rollout is forcefully considered fully promoted while the current step is in a Running phase, the plugin will call the <code>Terminate()</code> method with the current context on the next reconciliation and update the status based on the result.</p>"},{"location":"proposals/step-plugin/#rollout-aborted-during-a-step-plugin","title":"Rollout aborted during a step plugin","text":"<p>If a Rollout is aborted while the current step is in a Running phase, the plugin will call the <code>Abort()</code> method with the current context on the next reconciliation. The controller will call the <code>Abort()</code> operation for each step that were executed in the reverse order. The steps may or may not perform any action during the Abort. The result of the abort will be saved in the status, overriding the state persisted during the <code>Run()</code>. If the Abort operation has an error, the error is propagated to the controller. The controller has the responsibility to retry the Abort operation, and eventually proceed with the next step if it never succeeds.</p>"},{"location":"proposals/step-plugin/#the-step-plugin-reports-an-error","title":"The step plugin reports an error","text":"<p>Before returning the error, the status is persisted with the error phase and message. Other properties of the current status remain unmodified so the step can be re-executed with the last known valid status.</p> <p>For an expected retryable error, the plugin should return a Running phase with a RequeueAfter value to retry the execution. For an expected un-retryable error, the plugin should return a Failed status. After the state is persisted, the error is propagated to the controller and the controller error-handling logic will handle the error.</p>"},{"location":"proposals/step-plugin/#the-step-plugin-uses-rollout-information","title":"The step plugin uses Rollout information","text":"<p>The step plugin may need to have access to the current state of the Rollout. The step plugin will receive a deep copy of the rollout object in parameter.</p>"},{"location":"proposals/step-plugin/#i-can-investigate-my-step-plugin-execution","title":"I can investigate my step plugin execution","text":"<p>A user wants to know what happened during their custom step plugin after the execution. They can use the status in the Rollout object.</p>"},{"location":"proposals/step-plugin/#state-is-shared-between-plugins","title":"State is shared between plugins","text":"<p>A user wants to use an API to publish information about the rollout. The plugin first calls the API that returns a conversation ID. Other steps need to use the conversationID during their execution. The plugin step receives in parameters the full rollout object and the pluginName. This information can be used to retrieve the status of other plugin execution.</p> <p>An utility function such as <code>PluginHelper.GetStatuses(rollout, pluginName)</code> can be implemented and made available to the plugins.</p>"},{"location":"proposals/step-plugin/#i-want-my-rollout-to-continue-event-if-my-plugin-failed","title":"I want my rollout to continue event if my plugin failed","text":"<p>A parameter such as <code>abortOnFailure</code> can be added to the Rollout plugin step configuration object. When specified, the controller can use the value to modify the default logic.</p>"},{"location":"proposals/step-plugin/#i-dont-want-my-plugin-execution-time-to-count-towards-the-progress-deadline","title":"I dont want my plugin execution time to count towards the progress deadline","text":"<p>A parameter such as <code>ignoreProgressDeadline</code> can be added to the Rollout plugin step configuration object. When specified, the controller can use the value to modify the default logic.</p>"},{"location":"proposals/step-plugin/#security-considerations","title":"Security Considerations","text":"<ul> <li>Plugins binary can be validated with the configured <code>sha256</code>.</li> </ul>"},{"location":"proposals/step-plugin/#risks-and-mitigations","title":"Risks and Mitigations","text":"<ul> <li>Rollout status size can grow more than expected based on plugins hygiene.</li> <li>Object size can be validated with <code>unsafe.Sizeof(struct)</code> and a size limit can be imposed.</li> <li>Plugins that are failing or causing problems cannot be removed without updating all the Rollouts.</li> <li>A <code>disabled</code> config can be added globally and ignore the plugin execution if true.</li> </ul>"},{"location":"proposals/step-plugin/#upgrade-downgrade-strategy","title":"Upgrade / Downgrade Strategy","text":"<p>It is expected that plugins will be compiled with different versions than the running argo-rollout controller. The plugins version could be either newer or older than the controller.</p> <p>The hashicorp/go-plugin uses gob encoding with rpc.</p> <p>\u201cThe source and destination values/types need not correspond exactly. For structs, fields (identified by name) that are in the source but absent from the receiving variable will be ignored. Fields that are in the receiving variable but missing from the transmitted type or value will be ignored in the destination. If a field with the same name is present in both, their types must be compatible. Both the receiver and transmitter will do all necessary indirection and dereferencing to convert between gobs and actual Go values.\u201d - package encoding/gob</p> <p>Plugins should validate the objects they receive in parameters such as the <code>Rollout</code> and user confiuguration. If they expect a property to be set and it is not, it is highly probably that the controller's object version does not have that property.</p> <p>For breaking changes, hashicorp/go-plugin has a <code>ProtocolVersion</code> property that can be used in the future.</p> <p>Plugins can also be added with different names, which would require update to the Rollout CR objects as well.</p>"},{"location":"proposals/step-plugin/#drawbacks","title":"Drawbacks","text":"<ul> <li>Gives a lot of power to the plugin and bad plugins could destabilize the rollouts</li> <li>If plugins need more permission, the access needs to be given using the Rollout service account.</li> </ul>"},{"location":"proposals/step-plugin/#alternatives","title":"Alternatives","text":"<ul> <li>Only implement vetted code in the argo-rollout codebase.</li> <li>Create a plugin that calls other containers</li> </ul>"},{"location":"security/security/","title":"Security Policy for Argo Rollouts","text":""},{"location":"security/security/#reporting-a-vulnerability","title":"Reporting a Vulnerability","text":"<p>If you find a security related bug in Argo Rollouts, we kindly ask you for responsible disclosure and for giving us appropriate time to react, analyze and develop a fix to mitigate the found security vulnerability.</p> <p>Please report vulnerabilities by e-mail to the following address: </p> <ul> <li>cncf-argo-security@lists.cncf.io</li> </ul> <p>All vulnerabilites and associated information will be treated with full confidentiality. </p>"},{"location":"security/security/#public-disclosure","title":"Public Disclosure","text":"<p>We will publish security advisiories using the GitHub Security Advisories feature to keep our community well informed, and will credit you for your findings (unless you prefer to stay anonymous, of course).</p>"},{"location":"security/security/#internet-bug-bounty-collaboration","title":"Internet Bug Bounty collaboration","text":"<p>We're happy to announce that the Argo project is collaborating with the great folks over at Hacker One and their Internet Bug Bounty program to reward the awesome people who find security vulnerabilities in the four main Argo projects (CD, Events, Rollouts and Workflows) and then work with us to fix and disclose them in a responsible manner.</p> <p>If you report a vulnerability to us as outlined in this security policy, we will work together with you to find out whether your finding is eligible for claiming a bounty, and also on how to claim it.</p>"},{"location":"security/signed-release-assets/","title":"Verification of Argo Rollouts Artifacts","text":""},{"location":"security/signed-release-assets/#prerequisites","title":"Prerequisites","text":"<ul> <li>cosign <code>v2.0.0</code> or higher installation instructions</li> <li>slsa-verifier installation instructions</li> </ul>"},{"location":"security/signed-release-assets/#release-assets","title":"Release Assets","text":"Asset Description argo-rollouts-checksums.txt Checksums of binaries argo-rollouts-cli.intoto.jsonl Attestation of CLI binaries &amp; manifiest dashboard-install.yaml Dashboard install install.yaml Standard installation method kubectl-argo-rollouts-darwin-amd64 CLI Binary kubectl-argo-rollouts-darwin-arm64 CLI Binary kubectl-argo-rollouts-linux-amd64 CLI Binary kubectl-argo-rollouts-linux-arm64 CLI Binary kubectl-argo-rollouts-windows-amd64 CLI Binary namespace-install.yaml Namespace installation notifications-install.yaml Notification installation rollout_cr_schema.json Schema sbom.tar.gz Sbom sbom.tar.gz.pem Certificate used to sign sbom sbom.tar.gz.sig Signature of sbom"},{"location":"security/signed-release-assets/#verification-of-container-images","title":"Verification of container images","text":"<p>Argo Rollouts container images are signed by cosign using identity-based (\"keyless\") signing and transparency. Executing the following command can be used to verify the signature of a container image:</p> <p><pre><code>cosign verify \\\n--certificate-identity-regexp https://github.com/argoproj/argo-rollouts/.github/workflows/image-reuse.yaml@refs/tags/v \\\n--certificate-oidc-issuer https://token.actions.githubusercontent.com \\\nquay.io/argoproj/argo-rollouts:v1.5.0 | jq\n</code></pre> The command should output the following if the container image was correctly verified: <pre><code>The following checks were performed on each of these signatures:\n  - The cosign claims were validated\n  - Existence of the claims in the transparency log was verified offline\n  - The code-signing certificate was verified using trusted certificate authority certificates\n[\n  {\n    \"critical\": {\n      \"identity\": {\n        \"docker-reference\": \"quay.io/argoproj/argo-rollouts\"\n      },\n      \"image\": {\n        \"docker-manifest-digest\": \"sha256:519522f8c66c7b4c468f360ebe6c8ba07b8d64f5f948e71ae52c01b9953e1eb9\"\n      },\n      \"type\": \"cosign container image signature\"\n    },\n    \"optional\": {\n      \"1.3.6.1.4.1.57264.1.1\": \"https://token.actions.githubusercontent.com\",\n      \"1.3.6.1.4.1.57264.1.2\": \"push\",\n      \"1.3.6.1.4.1.57264.1.3\": \"aa1afcb418fcebcc68b063377c48225f5a9d1511\",\n      \"1.3.6.1.4.1.57264.1.4\": \"Release\",\n      \"1.3.6.1.4.1.57264.1.5\": \"argoproj/argo-rollouts\",\n      \"1.3.6.1.4.1.57264.1.6\": \"refs/tags/v1.5.0\",\n      ...\n</code></pre></p>"},{"location":"security/signed-release-assets/#verification-of-container-image-attestations","title":"Verification of container image attestations","text":"<p>A SLSA Level 3 provenance is generated using slsa-github-generator.</p> <p>The following command will verify the signature of an attestation and how it was issued. It will contain the payloadType, payload, and signature. <pre><code>cosign verify-attestation --type slsaprovenance \\\n--certificate-identity-regexp https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v \\\n--certificate-oidc-issuer https://token.actions.githubusercontent.com \\\nquay.io/argoproj/argo-rollouts:v1.5.0 | jq\n</code></pre> The payload is a non-falsifiable provenance which is base64 encoded and can be viewed by using the command below: <pre><code>cosign verify-attestation --type slsaprovenance \\\n--certificate-identity-regexp https://github.com/slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@refs/tags/v \\\n--certificate-oidc-issuer https://token.actions.githubusercontent.com \\\nquay.io/argoproj/argo-rollouts:v1.5.0 | jq -r .payload | base64 -d | jq\n</code></pre></p> <p>Tip</p> <p><code>cosign</code> or <code>slsa-verifier</code> can both be used to verify image attestations. Check the documentation of each binary for detailed instructions.</p>"},{"location":"security/signed-release-assets/#verification-of-cli-artifacts-with-attestations","title":"Verification of CLI artifacts with attestations","text":"<p>A single attestation (<code>argo-rollouts.intoto.jsonl</code>) from each release is provided. This can be used with slsa-verifier to verify that a CLI binary or manifest was generated using Argo Rollouts workflows on GitHub and ensures it was cryptographically signed. <pre><code>slsa-verifier verify-artifact kubectl-argo-rollouts-linux-amd64 --provenance-path kubectl-argo-rollouts.intoto.jsonl  --source-uri github.com/argoproj/argo-rollouts\n</code></pre></p>"},{"location":"security/signed-release-assets/#verifying-an-artifact-and-output-the-provenance","title":"Verifying an artifact and output the provenance","text":"<pre><code>slsa-verifier verify-artifact kubectl-argo-rollouts-linux-amd64 --provenance-path kubectl-argo-rollouts.intoto.jsonl  --source-uri github.com/argoproj/argo-rollouts --print-provenance | jq\n</code></pre>"},{"location":"security/signed-release-assets/#verification-of-sbom","title":"Verification of Sbom","text":"<pre><code>cosign verify-blob --signature sbom.tar.gz.sig --certificate sbom.tar.gz.pem \\\n--certificate-identity-regexp ^https://github.com/argoproj/argo-rollouts/.github/workflows/release.yaml@refs/tags/v \\\n--certificate-oidc-issuer https://token.actions.githubusercontent.com  \\\n ~/Downloads/sbom.tar.gz | jq\n</code></pre>"},{"location":"security/signed-release-assets/#verification-on-kubernetes","title":"Verification on Kubernetes","text":""},{"location":"security/signed-release-assets/#policy-controllers","title":"Policy controllers","text":"<p>Note</p> <p>We encourage all users to verify signatures and provenances with your admission/policy controller of choice. Doing so will verify that an image was built by us before it's deployed on your Kubernetes cluster.</p> <p>Cosign signatures and SLSA provenances are compatible with several types of admission controllers. Please see the cosign documentation and slsa-github-generator for supported controllers.</p>"}]}