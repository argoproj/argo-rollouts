/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = "proto2";

package github.com.argoproj.argo_rollouts.pkg.apis.rollouts.v1alpha1;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "k8s.io/api/batch/v1/generated.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/schema/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

// Package-wide variables from generator "generated".
option (gogoproto.marshaler_all) = true;
option (gogoproto.stable_marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.goproto_stringer_all) = false;
option (gogoproto.stringer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_unrecognized_all) = false;
option (gogoproto.goproto_enum_prefix_all) = false;
option (gogoproto.goproto_getters_all) = false;
option go_package = "github.com/argoproj/argo-rollouts/pkg/apis/rollouts/v1alpha1";

message ALBStatus {
  optional AwsResourceRef loadBalancer = 1 [(gogoproto.customname) = "LoadBalancer", (gogoproto.nullable) = false];

  optional AwsResourceRef canaryTargetGroup = 2 [(gogoproto.customname) = "CanaryTargetGroup", (gogoproto.nullable) = false];

  optional AwsResourceRef stableTargetGroup = 3 [(gogoproto.customname) = "StableTargetGroup", (gogoproto.nullable) = false];

  optional string ingress = 4 [(gogoproto.customname) = "Ingress", (gogoproto.nullable) = false];
}

// ALBTrafficRouting configuration for ALB ingress controller to control traffic routing
message ALBTrafficRouting {
  // Ingress refers to the name of an `Ingress` resource in the same namespace as the `Rollout`
  optional string ingress = 1 [(gogoproto.customname) = "Ingress", (gogoproto.nullable) = false];

  // ServicePort refers to the port that the Ingress action should route traffic to
  optional int32 servicePort = 2 [(gogoproto.customname) = "ServicePort", (gogoproto.nullable) = false];

  // RootService references the service in the ingress to the controller should add the action to
  optional string rootService = 3 [(gogoproto.customname) = "RootService", (gogoproto.nullable) = false];

  // AnnotationPrefix has to match the configured annotation prefix on the alb ingress controller
  // +optional
  optional string annotationPrefix = 4 [(gogoproto.customname) = "AnnotationPrefix", (gogoproto.nullable) = false];

  // StickinessConfig refers to the duration-based stickiness of the target groups associated with an `Ingress`
  // +optional
  optional StickinessConfig stickinessConfig = 5 [(gogoproto.customname) = "StickinessConfig"];

  // Ingresses refers to the name of an `Ingress` resource in the same namespace as the `Rollout` in a multi ingress scenario
  // +optional
  repeated string ingresses = 6 [(gogoproto.customname) = "Ingresses"];
}

// AmbassadorTrafficRouting defines the configuration required to use Ambassador as traffic
// router
message AmbassadorTrafficRouting {
  // Mappings refer to the name of the Ambassador Mappings used to route traffic to the
  // service
  repeated string mappings = 1 [(gogoproto.customname) = "Mappings"];
}

// AnalysisRun is an instantiation of an AnalysisTemplate
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:path=analysisruns, shortName=ar
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase",description="AnalysisRun status"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp",description="Time since resource was created"
message AnalysisRun {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  optional AnalysisRunSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];

  optional AnalysisRunStatus status = 3 [(gogoproto.customname) = "Status", (gogoproto.nullable) = false];
}

// AnalysisRunArgument argument to add to analysisRun
message AnalysisRunArgument {
  // Name argument name
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Value a hardcoded value for the argument. This field is a one of field with valueFrom
  optional string value = 2 [(gogoproto.customname) = "Value", (gogoproto.nullable) = false];

  // ValueFrom A reference to where the value is stored. This field is a one of field with valueFrom
  optional ArgumentValueFrom valueFrom = 3 [(gogoproto.customname) = "ValueFrom"];
}

// AnalysisRunList is a list of AnalysisTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message AnalysisRunList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1 [(gogoproto.customname) = "ListMeta", (gogoproto.nullable) = false];

  repeated AnalysisRun items = 2 [(gogoproto.customname) = "Items", (gogoproto.nullable) = false];
}

// AnalysisRunMetadata extra labels to add to the AnalysisRun
message AnalysisRunMetadata {
  // Labels Additional labels to add to the AnalysisRun
  // +optional
  map<string, string> labels = 1 [(gogoproto.customname) = "Labels", (gogoproto.nullable) = false];

  // Annotations additional annotations to add to the AnalysisRun
  // +optional
  map<string, string> annotations = 2 [(gogoproto.customname) = "Annotations", (gogoproto.nullable) = false];
}

// AnalysisRunSpec is the spec for a AnalysisRun resource
message AnalysisRunSpec {
  // Metrics contains the list of metrics to query as part of an analysis run
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated Metric metrics = 1 [(gogoproto.customname) = "Metrics", (gogoproto.nullable) = false];

  // Args are the list of arguments used in this run
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated Argument args = 2 [(gogoproto.customname) = "Args", (gogoproto.nullable) = false];

  // Terminate is used to prematurely stop the run (e.g. rollout completed and analysis is no longer desired)
  optional bool terminate = 3 [(gogoproto.customname) = "Terminate", (gogoproto.nullable) = false];

  // DryRun object contains the settings for running the analysis in Dry-Run mode
  // +patchMergeKey=metricName
  // +patchStrategy=merge
  // +optional
  repeated DryRun dryRun = 4 [(gogoproto.customname) = "DryRun", (gogoproto.nullable) = false];

  // MeasurementRetention object contains the settings for retaining the number of measurements during the analysis
  // +patchMergeKey=metricName
  // +patchStrategy=merge
  // +optional
  repeated MeasurementRetention measurementRetention = 5 [(gogoproto.customname) = "MeasurementRetention", (gogoproto.nullable) = false];

  // TTLStrategy object contains the strategy for the time to live depending on if the analysis succeeded or failed
  // +optional
  optional TTLStrategy ttlStrategy = 6 [(gogoproto.customname) = "TTLStrategy"];
}

// AnalysisRunStatus is the status for a AnalysisRun resource
message AnalysisRunStatus {
  // Phase is the status of the analysis run
  optional string phase = 1 [(gogoproto.casttype) = "AnalysisPhase", (gogoproto.customname) = "Phase", (gogoproto.nullable) = false];

  // Message is a message explaining current status
  optional string message = 2 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];

  // MetricResults contains the metrics collected during the run
  repeated MetricResult metricResults = 3 [(gogoproto.customname) = "MetricResults", (gogoproto.nullable) = false];

  // StartedAt indicates when the analysisRun first started
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 4 [(gogoproto.customname) = "StartedAt"];

  // RunSummary contains the final results from the metric executions
  optional RunSummary runSummary = 5 [(gogoproto.customname) = "RunSummary", (gogoproto.nullable) = false];

  // DryRunSummary contains the final results from the metric executions in the dry-run mode
  optional RunSummary dryRunSummary = 6 [(gogoproto.customname) = "DryRunSummary"];

  // CompletedAt indicates when the analysisRun completed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time completedAt = 7 [(gogoproto.customname) = "CompletedAt"];
}

// AnalysisRunStrategy configuration for the analysis runs and experiments to retain
message AnalysisRunStrategy {
  // SuccessfulRunHistoryLimit limits the number of old successful analysis runs and experiments to be retained in a history
  optional int32 successfulRunHistoryLimit = 1 [(gogoproto.customname) = "SuccessfulRunHistoryLimit"];

  // UnsuccessfulRunHistoryLimit limits the number of old unsuccessful analysis runs and experiments to be retained in a history.
  // Stages for unsuccessful: "Error", "Failed", "Inconclusive"
  optional int32 unsuccessfulRunHistoryLimit = 2 [(gogoproto.customname) = "UnsuccessfulRunHistoryLimit"];
}

// AnalysisTemplate holds the template for performing canary analysis
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:path=analysistemplates,shortName=at
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp",description="Time since resource was created"
message AnalysisTemplate {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  optional AnalysisTemplateSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];
}

// AnalysisTemplateList is a list of AnalysisTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message AnalysisTemplateList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1 [(gogoproto.customname) = "ListMeta", (gogoproto.nullable) = false];

  repeated AnalysisTemplate items = 2 [(gogoproto.customname) = "Items", (gogoproto.nullable) = false];
}

message AnalysisTemplateRef {
  // TemplateName name of template to use in AnalysisRun
  // +optional
  optional string templateName = 1 [(gogoproto.customname) = "TemplateName", (gogoproto.nullable) = false];

  // Whether to look for the templateName at cluster scope or namespace scope
  // +optional
  optional bool clusterScope = 2 [(gogoproto.customname) = "ClusterScope", (gogoproto.nullable) = false];
}

// AnalysisTemplateSpec is the specification for a AnalysisTemplate resource
message AnalysisTemplateSpec {
  // Metrics contains the list of metrics to query as part of an analysis run
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated Metric metrics = 1 [(gogoproto.customname) = "Metrics", (gogoproto.nullable) = false];

  // Args are the list of arguments to the template
  // +patchMergeKey=name
  // +patchStrategy=merge
  // +optional
  repeated Argument args = 2 [(gogoproto.customname) = "Args", (gogoproto.nullable) = false];

  // DryRun object contains the settings for running the analysis in Dry-Run mode
  // +patchMergeKey=metricName
  // +patchStrategy=merge
  // +optional
  repeated DryRun dryRun = 3 [(gogoproto.customname) = "DryRun", (gogoproto.nullable) = false];

  // MeasurementRetention object contains the settings for retaining the number of measurements during the analysis
  // +patchMergeKey=metricName
  // +patchStrategy=merge
  // +optional
  repeated MeasurementRetention measurementRetention = 4 [(gogoproto.customname) = "MeasurementRetention", (gogoproto.nullable) = false];

  // Templates reference to a list of analysis templates to combine with the rest of the metrics for an AnalysisRun
  // +patchMergeKey=templateName
  // +patchStrategy=merge
  repeated AnalysisTemplateRef templates = 5 [(gogoproto.customname) = "Templates", (gogoproto.nullable) = false];
}

// AntiAffinity defines which inter-pod scheduling rule to use for anti-affinity injection
message AntiAffinity {
  // +optional
  optional PreferredDuringSchedulingIgnoredDuringExecution preferredDuringSchedulingIgnoredDuringExecution = 1 [(gogoproto.customname) = "PreferredDuringSchedulingIgnoredDuringExecution"];

  // +optional
  optional RequiredDuringSchedulingIgnoredDuringExecution requiredDuringSchedulingIgnoredDuringExecution = 2 [(gogoproto.customname) = "RequiredDuringSchedulingIgnoredDuringExecution"];
}

// ApisixRoute holds information on the APISIX Route the rollout needs to modify
message ApisixRoute {
  // Name refer to the name of the APISIX Route used to route traffic to the service
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // RuleRef a list of the APISIX Route HTTP Rules used to route traffic to the service
  repeated string rules = 2 [(gogoproto.customname) = "Rules"];
}

// ApisixTrafficRouting defines the configuration required to use APISIX as traffic router
message ApisixTrafficRouting {
  // Route references an Apisix Route to modify to shape traffic
  optional ApisixRoute route = 1 [(gogoproto.customname) = "Route"];
}

// AppMeshTrafficRouting configuration for AWS AppMesh service mesh to enable fine grain configuration
message AppMeshTrafficRouting {
  // VirtualService references an AppMesh VirtualService and VirtualRouter to modify to shape traffic
  optional AppMeshVirtualService virtualService = 1 [(gogoproto.customname) = "VirtualService"];

  // VirtualNodeGroup references an AppMesh Route targets that are formed by a set of VirtualNodes that are used to shape traffic
  optional AppMeshVirtualNodeGroup virtualNodeGroup = 2 [(gogoproto.customname) = "VirtualNodeGroup"];
}

// AppMeshVirtualNodeGroup holds information about targets used for routing traffic to a virtual service
message AppMeshVirtualNodeGroup {
  // CanaryVirtualNodeRef is the virtual node ref to modify labels with canary ReplicaSet pod template hash value
  optional AppMeshVirtualNodeReference canaryVirtualNodeRef = 1 [(gogoproto.customname) = "CanaryVirtualNodeRef"];

  // StableVirtualNodeRef is the virtual node name to modify labels with stable ReplicaSet pod template hash value
  optional AppMeshVirtualNodeReference stableVirtualNodeRef = 2 [(gogoproto.customname) = "StableVirtualNodeRef"];
}

// AppMeshVirtualNodeReference holds a reference to VirtualNode.appmesh.k8s.aws
message AppMeshVirtualNodeReference {
  // Name is the name of VirtualNode CR
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];
}

// AppMeshVirtualService holds information on the virtual service the rollout needs to modify
message AppMeshVirtualService {
  // Name is the name of virtual service
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Routes is list of HTTP routes within virtual router associated with virtual service to edit. If omitted, virtual service must have a single route of this type.
  repeated string routes = 2 [(gogoproto.customname) = "Routes"];
}

// Argument is an argument to an AnalysisRun
message Argument {
  // Name is the name of the argument
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Value is the value of the argument
  // +optional
  optional string value = 2 [(gogoproto.customname) = "Value"];

  // ValueFrom is a reference to where a secret is stored. This field is one of the fields with valueFrom
  // +optional
  optional ValueFrom valueFrom = 3 [(gogoproto.customname) = "ValueFrom"];
}

// ArgumentValueFrom defines references to fields within resources to grab for the value (i.e. Pod Template Hash)
message ArgumentValueFrom {
  // PodTemplateHashValue gets the value from one of the children ReplicaSet's Pod Template Hash
  optional string podTemplateHashValue = 1 [(gogoproto.casttype) = "ValueFromPodTemplateHash", (gogoproto.customname) = "PodTemplateHashValue"];

  // FieldRef
  optional FieldRef fieldRef = 2 [(gogoproto.customname) = "FieldRef"];
}

// Authentication method
message Authentication {
  // Sigv4 Config is the aws SigV4 configuration to use for SigV4 signing if using Amazon Managed Prometheus
  // +optional
  optional Sigv4Config sigv4 = 1 [(gogoproto.customname) = "Sigv4", (gogoproto.nullable) = false];

  // OAuth2 config
  // +optional
  optional OAuth2Config oauth2 = 2 [(gogoproto.customname) = "OAuth2", (gogoproto.nullable) = false];
}

message AwsResourceRef {
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  optional string arn = 2 [(gogoproto.customname) = "ARN", (gogoproto.nullable) = false];

  // FullName is the full name of the resource
  // +optional
  optional string fullName = 3 [(gogoproto.customname) = "FullName", (gogoproto.nullable) = false];
}

// BlueGreenStatus status fields that only pertain to the blueGreen rollout
message BlueGreenStatus {
  // PreviewSelector indicates which replicas set the preview service is serving traffic to
  // +optional
  optional string previewSelector = 1 [(gogoproto.customname) = "PreviewSelector", (gogoproto.nullable) = false];

  // ActiveSelector indicates which replicas set the active service is serving traffic to
  // +optional
  optional string activeSelector = 2 [(gogoproto.customname) = "ActiveSelector", (gogoproto.nullable) = false];

  // ScaleUpPreviewCheckPoint indicates that the Replicaset receiving traffic from the preview service is ready to be scaled up after the rollout is unpaused
  // +optional
  optional bool scaleUpPreviewCheckPoint = 3 [(gogoproto.customname) = "ScaleUpPreviewCheckPoint", (gogoproto.nullable) = false];

  // PrePromotionAnalysisRunStatus indicates the status of the current prepromotion analysis run
  optional RolloutAnalysisRunStatus prePromotionAnalysisRunStatus = 4 [(gogoproto.customname) = "PrePromotionAnalysisRunStatus"];

  // PostPromotionAnalysisRunStatus indicates the status of the current post promotion analysis run
  optional RolloutAnalysisRunStatus postPromotionAnalysisRunStatus = 5 [(gogoproto.customname) = "PostPromotionAnalysisRunStatus"];
}

// BlueGreenStrategy defines parameters for Blue Green deployment
message BlueGreenStrategy {
  // Name of the service that the rollout modifies as the active service.
  optional string activeService = 1 [(gogoproto.customname) = "ActiveService", (gogoproto.nullable) = false];

  // Name of the service that the rollout modifies as the preview service.
  // +optional
  optional string previewService = 2 [(gogoproto.customname) = "PreviewService", (gogoproto.nullable) = false];

  // PreviewReplicaCount is the number of replicas to run for the preview stack before the
  // switchover. Once the rollout is resumed the desired replicaset will be full scaled up before the switch occurs
  // +optional
  optional int32 previewReplicaCount = 3 [(gogoproto.customname) = "PreviewReplicaCount"];

  // AutoPromotionEnabled indicates if the rollout should automatically promote the new ReplicaSet
  // to the active service or enter a paused state. If not specified, the default value is true.
  // +optional
  optional bool autoPromotionEnabled = 4 [(gogoproto.customname) = "AutoPromotionEnabled"];

  // AutoPromotionSeconds is a duration in seconds in which to delay auto-promotion (default: 0).
  // The countdown begins after the preview ReplicaSet have reached full availability.
  // This option is ignored if autoPromotionEnabled is set to false.
  // +optional
  optional int32 autoPromotionSeconds = 5 [(gogoproto.customname) = "AutoPromotionSeconds", (gogoproto.nullable) = false];

  // MaxUnavailable The maximum number of pods that can be unavailable during a restart operation.
  // Defaults to 25% of total replicas.
  // +optional
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 6 [(gogoproto.customname) = "MaxUnavailable"];

  // ScaleDownDelaySeconds adds a delay before scaling down the previous replicaset.
  // If omitted, the Rollout waits 30 seconds before scaling down the previous ReplicaSet.
  // A minimum of 30 seconds is recommended to ensure IP table propagation across the nodes in
  // a cluster. See https://github.com/argoproj/argo-rollouts/issues/19#issuecomment-476329960 for
  // more information
  // +optional
  optional int32 scaleDownDelaySeconds = 7 [(gogoproto.customname) = "ScaleDownDelaySeconds"];

  // ScaleDownDelayRevisionLimit limits the number of old RS that can run at one time before getting scaled down
  // +optional
  optional int32 scaleDownDelayRevisionLimit = 8 [(gogoproto.customname) = "ScaleDownDelayRevisionLimit"];

  // PrePromotionAnalysis configuration to run analysis before a selector switch
  optional RolloutAnalysis prePromotionAnalysis = 9 [(gogoproto.customname) = "PrePromotionAnalysis"];

  // AntiAffinity enables anti-affinity rules for Blue Green deployment
  // +optional
  optional AntiAffinity antiAffinity = 10 [(gogoproto.customname) = "AntiAffinity"];

  // PostPromotionAnalysis configuration to run analysis after a selector switch
  optional RolloutAnalysis postPromotionAnalysis = 11 [(gogoproto.customname) = "PostPromotionAnalysis"];

  // PreviewMetadata specify labels and annotations which will be attached to the preview pods for
  // the duration which they act as a preview pod, and will be removed after
  optional PodTemplateMetadata previewMetadata = 12 [(gogoproto.customname) = "PreviewMetadata"];

  // ActiveMetadata specify labels and annotations which will be attached to the active pods for
  // the duration which they act as a active pod, and will be removed after
  optional PodTemplateMetadata activeMetadata = 13 [(gogoproto.customname) = "ActiveMetadata"];

  // AbortScaleDownDelaySeconds adds a delay in second before scaling down the preview replicaset
  // if update is aborted. 0 means not to scale down.
  // Default is 30 second
  // +optional
  optional int32 abortScaleDownDelaySeconds = 14 [(gogoproto.customname) = "AbortScaleDownDelaySeconds"];
}

// CanaryStatus status fields that only pertain to the canary rollout
message CanaryStatus {
  // CurrentStepAnalysisRunStatus indicates the status of the current step analysis run
  optional RolloutAnalysisRunStatus currentStepAnalysisRunStatus = 1 [(gogoproto.customname) = "CurrentStepAnalysisRunStatus"];

  // CurrentBackgroundAnalysisRunStatus indicates the status of the current background analysis run
  optional RolloutAnalysisRunStatus currentBackgroundAnalysisRunStatus = 2 [(gogoproto.customname) = "CurrentBackgroundAnalysisRunStatus"];

  // CurrentExperiment indicates the running experiment
  optional string currentExperiment = 3 [(gogoproto.customname) = "CurrentExperiment", (gogoproto.nullable) = false];

  // Weights records the weights which have been set on traffic provider. Only valid when using traffic routing
  optional TrafficWeights weights = 4 [(gogoproto.customname) = "Weights"];

  // StablePingPong For the ping-pong feature holds the current stable service, ping or pong
  optional string stablePingPong = 5 [(gogoproto.casttype) = "PingPongType", (gogoproto.customname) = "StablePingPong", (gogoproto.nullable) = false];

  // StepPluginStatuses holds the status of the step plugins executed
  repeated StepPluginStatus stepPluginStatuses = 6 [(gogoproto.customname) = "StepPluginStatuses", (gogoproto.nullable) = false];
}

// CanaryStep defines a step of a canary deployment.
message CanaryStep {
  // SetWeight sets what percentage of the newRS should receive
  optional int32 setWeight = 1 [(gogoproto.customname) = "SetWeight"];

  // Pause freezes the rollout by setting spec.Paused to true.
  // A Rollout will resume when spec.Paused is reset to false.
  // +optional
  optional RolloutPause pause = 2 [(gogoproto.customname) = "Pause"];

  // Experiment defines the experiment object that should be created
  optional RolloutExperimentStep experiment = 3 [(gogoproto.customname) = "Experiment"];

  // Analysis defines the AnalysisRun that will run for a step
  optional RolloutAnalysis analysis = 4 [(gogoproto.customname) = "Analysis"];

  // SetCanaryScale defines how to scale the newRS without changing traffic weight
  // +optional
  optional SetCanaryScale setCanaryScale = 5 [(gogoproto.customname) = "SetCanaryScale"];

  // SetHeaderRoute defines the route with specified header name to send 100% of traffic to the canary service
  // +optional
  optional SetHeaderRoute setHeaderRoute = 6 [(gogoproto.customname) = "SetHeaderRoute"];

  // SetMirrorRoutes Mirrors traffic that matches rules to a particular destination
  // +optional
  optional SetMirrorRoute setMirrorRoute = 8 [(gogoproto.customname) = "SetMirrorRoute"];

  // Plugin defines a plugin to execute for a step
  optional PluginStep plugin = 9 [(gogoproto.customname) = "Plugin"];
}

// CanaryStrategy defines parameters for a Replica Based Canary
message CanaryStrategy {
  // CanaryService holds the name of a service which selects pods with canary version and don't select any pods with stable version.
  // +optional
  optional string canaryService = 1 [(gogoproto.customname) = "CanaryService", (gogoproto.nullable) = false];

  // StableService holds the name of a service which selects pods with stable version and don't select any pods with canary version.
  // +optional
  optional string stableService = 2 [(gogoproto.customname) = "StableService", (gogoproto.nullable) = false];

  // Steps define the order of phases to execute the canary deployment
  // +optional
  repeated CanaryStep steps = 3 [(gogoproto.customname) = "Steps", (gogoproto.nullable) = false];

  // TrafficRouting hosts all the supported service meshes supported to enable more fine-grained traffic routing
  optional RolloutTrafficRouting trafficRouting = 4 [(gogoproto.customname) = "TrafficRouting"];

  // MaxUnavailable The maximum number of pods that can be unavailable during the update.
  // Value can be an absolute number (ex: 5) or a percentage of total pods at the start of update (ex: 10%).
  // Absolute number is calculated from percentage by rounding down.
  // This can not be 0 if MaxSurge is 0.
  // By default, a fixed value of 25% is used.
  // Example: when this is set to 30%, the old RC can be scaled down by 30%
  // immediately when the rolling update starts. Once new pods are ready, old RC
  // can be scaled down further, followed by scaling up the new RC, ensuring
  // that at least 70% of original number of pods are available at all times
  // during the update.
  // +optional
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 5 [(gogoproto.customname) = "MaxUnavailable"];

  // MaxSurge The maximum number of pods that can be scheduled above the original number of
  // pods.
  // Value can be an absolute number (ex: 5) or a percentage of total pods at
  // the start of the update (ex: 10%). This can not be 0 if MaxUnavailable is 0.
  // Absolute number is calculated from percentage by rounding up.
  // By default, a value of 25% is used.
  // Example: when this is set to 30%, the new RC can be scaled up by 30%
  // immediately when the rolling update starts. Once old pods have been killed,
  // new RC can be scaled up further, ensuring that total number of pods running
  // at any time during the update is at most 130% of original pods.
  // +optional
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString maxSurge = 6 [(gogoproto.customname) = "MaxSurge"];

  // Analysis runs a separate analysisRun while all the steps execute. This is intended to be a continuous validation of the new ReplicaSet
  optional RolloutAnalysisBackground analysis = 7 [(gogoproto.customname) = "Analysis"];

  // AntiAffinity enables anti-affinity rules for Canary deployment
  // +optional
  optional AntiAffinity antiAffinity = 8 [(gogoproto.customname) = "AntiAffinity"];

  // CanaryMetadata specify labels and annotations which will be attached to the canary pods for
  // the duration which they act as a canary, and will be removed after
  optional PodTemplateMetadata canaryMetadata = 9 [(gogoproto.customname) = "CanaryMetadata"];

  // StableMetadata specify labels and annotations which will be attached to the stable pods for
  // the duration which they act as a canary, and will be removed after
  optional PodTemplateMetadata stableMetadata = 10 [(gogoproto.customname) = "StableMetadata"];

  // ScaleDownDelaySeconds adds a delay before scaling down the previous ReplicaSet when the
  // canary strategy is used with traffic routing (default 30 seconds). A delay in scaling down
  // the previous ReplicaSet is needed after switching the stable service selector to point to
  // the new ReplicaSet, in order to give time for traffic providers to re-target the new pods.
  // This value is ignored with basic, replica-weighted canary without traffic routing.
  // +optional
  optional int32 scaleDownDelaySeconds = 11 [(gogoproto.customname) = "ScaleDownDelaySeconds"];

  // ScaleDownDelayRevisionLimit limits the number of old RS that can run at one time before getting scaled down
  // +optional
  optional int32 scaleDownDelayRevisionLimit = 12 [(gogoproto.customname) = "ScaleDownDelayRevisionLimit"];

  // AbortScaleDownDelaySeconds adds a delay in second before scaling down the canary pods when update
  // is aborted for canary strategy with traffic routing (not applicable for basic canary).
  // 0 means canary pods are not scaled down.
  // Default is 30 seconds.
  // +optional
  optional int32 abortScaleDownDelaySeconds = 13 [(gogoproto.customname) = "AbortScaleDownDelaySeconds"];

  // DynamicStableScale is a traffic routing feature which dynamically scales the stable
  // ReplicaSet to minimize total pods which are running during an update. This is calculated by
  // scaling down the stable as traffic is increased to canary. When disabled (the default behavior)
  // the stable ReplicaSet remains fully scaled to support instantaneous aborts.
  optional bool dynamicStableScale = 14 [(gogoproto.customname) = "DynamicStableScale", (gogoproto.nullable) = false];

  // PingPongSpec holds the ping and pong services
  optional PingPongSpec pingPong = 15 [(gogoproto.customname) = "PingPong"];

  // Assuming the desired number of pods in a stable or canary ReplicaSet is not zero, then make sure it is at least
  // MinPodsPerReplicaSet for High Availability. Only applicable for TrafficRoutedCanary
  optional int32 minPodsPerReplicaSet = 16 [(gogoproto.customname) = "MinPodsPerReplicaSet"];

  // ReplicaProgressThreshold is the threhold number or percentage of pods that need to be available before a rollout promotion.
  // Defaults to 100% of total replicas.
  // +optional
  optional ReplicaProgressThreshold replicaProgressThreshold = 17 [(gogoproto.customname) = "ReplicaProgressThreshold"];
}

// CloudWatchMetric defines the cloudwatch query to perform canary analysis
message CloudWatchMetric {
  optional string interval = 1 [(gogoproto.casttype) = "DurationString", (gogoproto.customname) = "Interval", (gogoproto.nullable) = false];

  repeated CloudWatchMetricDataQuery metricDataQueries = 2 [(gogoproto.customname) = "MetricDataQueries", (gogoproto.nullable) = false];
}

// CloudWatchMetricDataQuery defines the cloudwatch query
message CloudWatchMetricDataQuery {
  optional string id = 1 [(gogoproto.customname) = "Id", (gogoproto.nullable) = false];

  optional string expression = 2 [(gogoproto.customname) = "Expression"];

  optional string label = 3 [(gogoproto.customname) = "Label"];

  optional CloudWatchMetricStat metricStat = 4 [(gogoproto.customname) = "MetricStat"];

  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString period = 5 [(gogoproto.customname) = "Period"];

  optional bool returnData = 6 [(gogoproto.customname) = "ReturnData"];
}

message CloudWatchMetricStat {
  optional CloudWatchMetricStatMetric metric = 1 [(gogoproto.customname) = "Metric", (gogoproto.nullable) = false];

  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString period = 2 [(gogoproto.customname) = "Period", (gogoproto.nullable) = false];

  optional string stat = 3 [(gogoproto.customname) = "Stat", (gogoproto.nullable) = false];

  optional string unit = 4 [(gogoproto.customname) = "Unit", (gogoproto.nullable) = false];
}

message CloudWatchMetricStatMetric {
  repeated CloudWatchMetricStatMetricDimension dimensions = 1 [(gogoproto.customname) = "Dimensions", (gogoproto.nullable) = false];

  optional string metricName = 2 [(gogoproto.customname) = "MetricName", (gogoproto.nullable) = false];

  optional string namespace = 3 [(gogoproto.customname) = "Namespace"];
}

message CloudWatchMetricStatMetricDimension {
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  optional string value = 2 [(gogoproto.customname) = "Value", (gogoproto.nullable) = false];
}

// ClusterAnalysisTemplate holds the template for performing canary analysis
// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:path=clusteranalysistemplates,shortName=cat,scope=Cluster
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp",description="Time since resource was created"
message ClusterAnalysisTemplate {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  optional AnalysisTemplateSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];
}

// AnalysisTemplateList is a list of AnalysisTemplate resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message ClusterAnalysisTemplateList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1 [(gogoproto.customname) = "ListMeta", (gogoproto.nullable) = false];

  repeated ClusterAnalysisTemplate items = 2 [(gogoproto.customname) = "Items", (gogoproto.nullable) = false];
}

message DatadogMetric {
  // +kubebuilder:default="5m"
  // Interval refers to the Interval time window in Datadog (default: 5m). Not to be confused with the polling rate for the metric.
  optional string interval = 1 [(gogoproto.casttype) = "DurationString", (gogoproto.customname) = "Interval", (gogoproto.nullable) = false];

  optional string query = 2 [(gogoproto.customname) = "Query", (gogoproto.nullable) = false];

  // Queries is a map of query_name_as_key: query. You can then use query_name_as_key inside Formula.Used for v2
  // +kubebuilder:validation:Type=object
  map<string, string> queries = 3 [(gogoproto.customname) = "Queries", (gogoproto.nullable) = false];

  // Formula refers to the Formula made up of the queries. Only useful with Queries. Used for v2
  optional string formula = 4 [(gogoproto.customname) = "Formula", (gogoproto.nullable) = false];

  // ApiVersion refers to the Datadog API version being used (default: v1). v1 will eventually be deprecated.
  // +kubebuilder:validation:Enum=v1;v2
  // +kubebuilder:default=v1
  optional string apiVersion = 5 [(gogoproto.customname) = "ApiVersion", (gogoproto.nullable) = false];

  // +kubebuilder:validation:Enum=avg;min;max;sum;last;percentile;mean;l2norm;area
  // Aggregator is a type of aggregator to use for metrics-based queries (default: ""). Used for v2
  optional string aggregator = 6 [(gogoproto.customname) = "Aggregator", (gogoproto.nullable) = false];

  // Secret refers to the name of the secret that should be used for an analysis and should exists in the namespace where the controller is.
  // +optional
  optional SecretRef secretRef = 7 [(gogoproto.customname) = "SecretRef", (gogoproto.nullable) = false];
}

// DryRun defines the settings for running the analysis in Dry-Run mode.
message DryRun {
  // Name of the metric which needs to be evaluated in the Dry-Run mode. Wildcard '*' is supported and denotes all
  // the available metrics.
  optional string metricName = 1 [(gogoproto.customname) = "MetricName", (gogoproto.nullable) = false];
}

// Experiment is a specification for an Experiment resource
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:path=experiments,shortName=exp
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase",description="Experiment status"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp",description="Time since resource was created"
message Experiment {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  optional ExperimentSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];

  optional ExperimentStatus status = 3 [(gogoproto.customname) = "Status", (gogoproto.nullable) = false];
}

message ExperimentAnalysisRunStatus {
  // Name is the name of the analysis
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // AnalysisRun is the name of the AnalysisRun
  optional string analysisRun = 2 [(gogoproto.customname) = "AnalysisRun", (gogoproto.nullable) = false];

  // Phase is the status of the AnalysisRun
  optional string phase = 3 [(gogoproto.casttype) = "AnalysisPhase", (gogoproto.customname) = "Phase", (gogoproto.nullable) = false];

  // Message is a message explaining the current status
  optional string message = 4 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];
}

message ExperimentAnalysisTemplateRef {
  // Name is the name of the analysis
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // TemplateName reference of the AnalysisTemplate name used by the Experiment to create the run
  optional string templateName = 2 [(gogoproto.customname) = "TemplateName", (gogoproto.nullable) = false];

  // Whether to look for the templateName at cluster scope or namespace scope
  // +optional
  optional bool clusterScope = 3 [(gogoproto.customname) = "ClusterScope", (gogoproto.nullable) = false];

  // Args are the arguments that will be added to the AnalysisRuns
  // +optional
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated Argument args = 4 [(gogoproto.customname) = "Args", (gogoproto.nullable) = false];

  // RequiredForCompletion blocks the Experiment from completing until the analysis has completed
  optional bool requiredForCompletion = 5 [(gogoproto.customname) = "RequiredForCompletion", (gogoproto.nullable) = false];
}

// ExperimentCondition describes the state of a experiment at a certain point.
message ExperimentCondition {
  // Type of deployment condition.
  optional string type = 1 [(gogoproto.casttype) = "ExperimentConditionType", (gogoproto.customname) = "Type", (gogoproto.nullable) = false];

  // Phase of the condition, one of True, False, Unknown.
  optional string status = 2 [(gogoproto.casttype) = "k8s.io/api/core/v1.ConditionStatus", (gogoproto.customname) = "Status", (gogoproto.nullable) = false];

  // The last time this condition was updated.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 3 [(gogoproto.customname) = "LastUpdateTime", (gogoproto.nullable) = false];

  // Last time the condition transitioned from one status to another.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4 [(gogoproto.customname) = "LastTransitionTime", (gogoproto.nullable) = false];

  // The reason for the condition's last transition.
  optional string reason = 5 [(gogoproto.customname) = "Reason", (gogoproto.nullable) = false];

  // A human readable message indicating details about the transition.
  optional string message = 6 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];
}

// ExperimentList is a list of Experiment resources
message ExperimentList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1 [(gogoproto.customname) = "ListMeta", (gogoproto.nullable) = false];

  repeated Experiment items = 2 [(gogoproto.customname) = "Items", (gogoproto.nullable) = false];
}

// ExperimentSpec is the spec for a Experiment resource
message ExperimentSpec {
  // Templates are a list of PodSpecs that define the ReplicaSets that should be run during an experiment.
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated TemplateSpec templates = 1 [(gogoproto.customname) = "Templates", (gogoproto.nullable) = false];

  // Duration the amount of time for the experiment to run as a duration string (e.g. 30s, 5m, 1h).
  // If omitted, the experiment will run indefinitely, stopped either via termination, or a failed analysis run.
  // +optional
  optional string duration = 2 [(gogoproto.casttype) = "DurationString", (gogoproto.customname) = "Duration", (gogoproto.nullable) = false];

  // ProgressDeadlineSeconds The maximum time in seconds for a experiment to
  // make progress before it is considered to be failed. Argo Rollouts will
  // continue to process failed experiments and a condition with a
  // ProgressDeadlineExceeded reason will be surfaced in the experiment status.
  // Defaults to 600s.
  // +optional
  optional int32 progressDeadlineSeconds = 3 [(gogoproto.customname) = "ProgressDeadlineSeconds"];

  // Terminate is used to prematurely stop the experiment
  optional bool terminate = 4 [(gogoproto.customname) = "Terminate", (gogoproto.nullable) = false];

  // Analyses references AnalysisTemplates to run during the experiment
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated ExperimentAnalysisTemplateRef analyses = 5 [(gogoproto.customname) = "Analyses", (gogoproto.nullable) = false];

  // ScaleDownDelaySeconds adds a delay before scaling down the Experiment.
  // If omitted, the Experiment waits 30 seconds before scaling down.
  // A minimum of 30 seconds is recommended to ensure IP table propagation across the nodes in
  // a cluster. See https://github.com/argoproj/argo-rollouts/issues/19#issuecomment-476329960 for
  // more information
  // +optional
  optional int32 scaleDownDelaySeconds = 6 [(gogoproto.customname) = "ScaleDownDelaySeconds"];

  // DryRun object contains the settings for running the analysis in Dry-Run mode
  // +patchMergeKey=metricName
  // +patchStrategy=merge
  // +optional
  repeated DryRun dryRun = 7 [(gogoproto.customname) = "DryRun", (gogoproto.nullable) = false];

  // MeasurementRetention object contains the settings for retaining the number of measurements during the analysis
  // +patchMergeKey=metricName
  // +patchStrategy=merge
  // +optional
  repeated MeasurementRetention measurementRetention = 8 [(gogoproto.customname) = "MeasurementRetention", (gogoproto.nullable) = false];

  // AnalysisRunMetadata labels and annotations that will be added to the AnalysisRuns
  // +optional
  optional AnalysisRunMetadata analysisRunMetadata = 9 [(gogoproto.customname) = "AnalysisRunMetadata", (gogoproto.nullable) = false];
}

// ExperimentStatus is the status for a Experiment resource
message ExperimentStatus {
  // Phase is the status of the experiment. Takes into consideration ReplicaSet degradations and
  // AnalysisRun statuses
  optional string phase = 1 [(gogoproto.casttype) = "AnalysisPhase", (gogoproto.customname) = "Phase", (gogoproto.nullable) = false];

  // Message is an explanation for the current status
  // +optional
  optional string message = 2 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];

  // TemplateStatuses holds the ReplicaSet related statuses for individual templates
  // +optional
  repeated TemplateStatus templateStatuses = 3 [(gogoproto.customname) = "TemplateStatuses", (gogoproto.nullable) = false];

  // AvailableAt the time when all the templates become healthy and the experiment should start tracking the time to
  // run for the duration of specificed in the spec.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time availableAt = 4 [(gogoproto.customname) = "AvailableAt"];

  // Conditions a list of conditions a experiment can have.
  // +optional
  repeated ExperimentCondition conditions = 5 [(gogoproto.customname) = "Conditions", (gogoproto.nullable) = false];

  // AnalysisRuns tracks the status of AnalysisRuns associated with this Experiment
  // +optional
  repeated ExperimentAnalysisRunStatus analysisRuns = 6 [(gogoproto.customname) = "AnalysisRuns", (gogoproto.nullable) = false];
}

message FieldRef {
  // Required: Path of the field to select in the specified API version
  optional string fieldPath = 1 [(gogoproto.customname) = "FieldPath", (gogoproto.nullable) = false];
}

// GraphiteMetric defines the Graphite query to perform canary analysis
message GraphiteMetric {
  // Address is the HTTP address and port of the Graphite server
  optional string address = 1 [(gogoproto.customname) = "Address", (gogoproto.nullable) = false];

  // Query is a raw Graphite query to perform
  optional string query = 2 [(gogoproto.customname) = "Query", (gogoproto.nullable) = false];
}

message HeaderRoutingMatch {
  // HeaderName the name of the request header
  optional string headerName = 1 [(gogoproto.customname) = "HeaderName", (gogoproto.nullable) = false];

  // HeaderValue the value of the header
  optional StringMatch headerValue = 2 [(gogoproto.customname) = "HeaderValue"];
}

// InfluxdbMetric defines the InfluxDB Flux query to perform canary analysis
message InfluxdbMetric {
  // Profile is the name of the secret holding InfluxDB account configuration
  optional string profile = 1 [(gogoproto.customname) = "Profile", (gogoproto.nullable) = false];

  // Query is a raw InfluxDB flux query to perform
  optional string query = 2 [(gogoproto.customname) = "Query", (gogoproto.nullable) = false];
}

// IstioDestinationRule is a reference to an Istio DestinationRule to modify and shape traffic
message IstioDestinationRule {
  // Name holds the name of the DestinationRule
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // CanarySubsetName is the subset name to modify labels with canary ReplicaSet pod template hash value
  optional string canarySubsetName = 2 [(gogoproto.customname) = "CanarySubsetName", (gogoproto.nullable) = false];

  // StableSubsetName is the subset name to modify labels with stable ReplicaSet pod template hash value
  optional string stableSubsetName = 3 [(gogoproto.customname) = "StableSubsetName", (gogoproto.nullable) = false];
}

// IstioTrafficRouting configuration for Istio service mesh to enable fine grain configuration
message IstioTrafficRouting {
  // VirtualService references an Istio VirtualService to modify to shape traffic
  optional IstioVirtualService virtualService = 1 [(gogoproto.customname) = "VirtualService"];

  // DestinationRule references an Istio DestinationRule to modify to shape traffic
  optional IstioDestinationRule destinationRule = 2 [(gogoproto.customname) = "DestinationRule"];

  // VirtualServices references a list of Istio VirtualService to modify to shape traffic
  repeated IstioVirtualService virtualServices = 3 [(gogoproto.customname) = "VirtualServices", (gogoproto.nullable) = false];
}

// IstioVirtualService holds information on the virtual service the rollout needs to modify
message IstioVirtualService {
  // Name holds the name of the VirtualService
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // A list of HTTP routes within VirtualService to edit. If omitted, VirtualService must have a single route of this type.
  repeated string routes = 2 [(gogoproto.customname) = "Routes"];

  // A list of TLS/HTTPS routes within VirtualService to edit. If omitted, VirtualService must have a single route of this type.
  repeated TLSRoute tlsRoutes = 3 [(gogoproto.customname) = "TLSRoutes", (gogoproto.nullable) = false];

  // A list of TCP routes within VirtualService to edit. If omitted, VirtualService must have a single route of this type.
  repeated TCPRoute tcpRoutes = 4 [(gogoproto.customname) = "TCPRoutes", (gogoproto.nullable) = false];
}

// JobMetric defines a job to run which acts as a metric
message JobMetric {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "Metadata", (gogoproto.nullable) = false];

  optional k8s.io.api.batch.v1.JobSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];
}

message KayentaMetric {
  optional string address = 1 [(gogoproto.customname) = "Address", (gogoproto.nullable) = false];

  optional string application = 2 [(gogoproto.customname) = "Application", (gogoproto.nullable) = false];

  optional string canaryConfigName = 3 [(gogoproto.customname) = "CanaryConfigName", (gogoproto.nullable) = false];

  optional string metricsAccountName = 4 [(gogoproto.customname) = "MetricsAccountName", (gogoproto.nullable) = false];

  optional string configurationAccountName = 5 [(gogoproto.customname) = "ConfigurationAccountName", (gogoproto.nullable) = false];

  optional string storageAccountName = 6 [(gogoproto.customname) = "StorageAccountName", (gogoproto.nullable) = false];

  optional KayentaThreshold threshold = 7 [(gogoproto.customname) = "Threshold", (gogoproto.nullable) = false];

  repeated KayentaScope scopes = 8 [(gogoproto.customname) = "Scopes", (gogoproto.nullable) = false];
}

message KayentaScope {
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  optional ScopeDetail controlScope = 2 [(gogoproto.customname) = "ControlScope", (gogoproto.nullable) = false];

  optional ScopeDetail experimentScope = 3 [(gogoproto.customname) = "ExperimentScope", (gogoproto.nullable) = false];
}

message KayentaThreshold {
  optional int64 pass = 1 [(gogoproto.customname) = "Pass", (gogoproto.nullable) = false];

  optional int64 marginal = 2 [(gogoproto.customname) = "Marginal", (gogoproto.nullable) = false];
}

message MangedRoutes {
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];
}

// Measurement is a point in time result value of a single metric, and the time it was measured
message Measurement {
  // Phase is the status of this single measurement
  optional string phase = 1 [(gogoproto.casttype) = "AnalysisPhase", (gogoproto.customname) = "Phase", (gogoproto.nullable) = false];

  // Message contains a message describing current condition (e.g. error messages)
  optional string message = 2 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];

  // StartedAt is the timestamp in which this measurement started to be measured
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 3 [(gogoproto.customname) = "StartedAt"];

  // FinishedAt is the timestamp in which this measurement completed and value was collected
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 4 [(gogoproto.customname) = "FinishedAt"];

  // Value is the measured value of the metric
  optional string value = 5 [(gogoproto.customname) = "Value", (gogoproto.nullable) = false];

  // Metadata stores additional metadata about this metric result, used by the different providers
  // (e.g. kayenta run ID, job name)
  map<string, string> metadata = 6 [(gogoproto.customname) = "Metadata", (gogoproto.nullable) = false];

  // ResumeAt is the  timestamp when the analysisRun should try to resume the measurement
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time resumeAt = 7 [(gogoproto.customname) = "ResumeAt"];
}

// MeasurementRetention defines the settings for retaining the number of measurements during the analysis.
message MeasurementRetention {
  // MetricName is the name of the metric on which this retention policy should be applied.
  optional string metricName = 1 [(gogoproto.customname) = "MetricName", (gogoproto.nullable) = false];

  // Limit is the maximum number of measurements to be retained for this given metric.
  optional int32 limit = 2 [(gogoproto.customname) = "Limit", (gogoproto.nullable) = false];
}

// Metric defines a metric in which to perform analysis
message Metric {
  // Name is the name of the metric
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Interval defines an interval string (e.g. 30s, 5m, 1h) between each measurement.
  // If omitted, will perform a single measurement
  optional string interval = 2 [(gogoproto.casttype) = "DurationString", (gogoproto.customname) = "Interval", (gogoproto.nullable) = false];

  // InitialDelay how long the AnalysisRun should wait before starting this metric
  optional string initialDelay = 3 [(gogoproto.casttype) = "DurationString", (gogoproto.customname) = "InitialDelay", (gogoproto.nullable) = false];

  // Count is the number of times to run the measurement. If both interval and count are omitted,
  // the effective count is 1. If only interval is specified, metric runs indefinitely.
  // If count > 1, interval must be specified.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString count = 4 [(gogoproto.customname) = "Count"];

  // SuccessCondition is an expression which determines if a measurement is considered successful
  // Expression is a goevaluate expression. The keyword `result` is a variable reference to the
  // value of measurement. Results can be both structured data or primitive.
  // Examples:
  //   result > 10
  //   (result.requests_made * result.requests_succeeded / 100) >= 90
  optional string successCondition = 5 [(gogoproto.customname) = "SuccessCondition", (gogoproto.nullable) = false];

  // FailureCondition is an expression which determines if a measurement is considered failed
  // If both success and failure conditions are specified, and the measurement does not fall into
  // either condition, the measurement is considered Inconclusive
  optional string failureCondition = 6 [(gogoproto.customname) = "FailureCondition", (gogoproto.nullable) = false];

  // FailureLimit is the maximum number of times the measurement is allowed to fail, before the
  // entire metric is considered Failed (default: 0)
  // -1 for making it disabled (when opting to use ConsecutiveSuccessLimit solely)
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString failureLimit = 7 [(gogoproto.customname) = "FailureLimit"];

  // InconclusiveLimit is the maximum number of times the measurement is allowed to measure
  // Inconclusive, before the entire metric is considered Inconclusive (default: 0)
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString inconclusiveLimit = 8 [(gogoproto.customname) = "InconclusiveLimit"];

  // ConsecutiveErrorLimit is the maximum number of times the measurement is allowed to error in
  // succession, before the metric is considered error (default: 4)
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString consecutiveErrorLimit = 9 [(gogoproto.customname) = "ConsecutiveErrorLimit"];

  // Provider configuration to the external system to use to verify the analysis
  optional MetricProvider provider = 10 [(gogoproto.customname) = "Provider", (gogoproto.nullable) = false];

  // ConsecutiveSuccessLimit is the number of consecutive times the measurement must succeed for the
  // entire metric to be considered Successful (default: 0, which means it's disabled)
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString consecutiveSuccessLimit = 11 [(gogoproto.customname) = "ConsecutiveSuccessLimit"];
}

// MetricProvider which external system to use to verify the analysis
// Only one of the fields in this struct should be non-nil
message MetricProvider {
  // Prometheus specifies the prometheus metric to query
  optional PrometheusMetric prometheus = 1 [(gogoproto.customname) = "Prometheus"];

  // Kayenta specifies a Kayenta metric
  optional KayentaMetric kayenta = 2 [(gogoproto.customname) = "Kayenta"];

  // Web specifies a generic HTTP web metric
  optional WebMetric web = 3 [(gogoproto.customname) = "Web"];

  // Datadog specifies a datadog metric to query
  optional DatadogMetric datadog = 4 [(gogoproto.customname) = "Datadog"];

  // Wavefront specifies the wavefront metric to query
  optional WavefrontMetric wavefront = 5 [(gogoproto.customname) = "Wavefront"];

  // NewRelic specifies the newrelic metric to query
  optional NewRelicMetric newRelic = 6 [(gogoproto.customname) = "NewRelic"];

  // Job specifies the job metric run
  optional JobMetric job = 7 [(gogoproto.customname) = "Job"];

  // CloudWatch specifies the cloudWatch metric to query
  optional CloudWatchMetric cloudWatch = 8 [(gogoproto.customname) = "CloudWatch"];

  // Graphite specifies the Graphite metric to query
  optional GraphiteMetric graphite = 9 [(gogoproto.customname) = "Graphite"];

  // Influxdb specifies the influxdb metric to query
  optional InfluxdbMetric influxdb = 10 [(gogoproto.customname) = "Influxdb"];

  // SkyWalking specifies the skywalking metric to query
  optional SkyWalkingMetric skywalking = 11 [(gogoproto.customname) = "SkyWalking"];

  // +kubebuilder:validation:Schemaless
  // +kubebuilder:pruning:PreserveUnknownFields
  // +kubebuilder:validation:Type=object
  // Plugin specifies the hashicorp go-plugin metric to query
  map<string, bytes> plugin = 12 [(gogoproto.castvalue) = "encoding/json.RawMessage", (gogoproto.customname) = "Plugin", (gogoproto.nullable) = false];
}

// MetricResult contain a list of the most recent measurements for a single metric along with
// counters on how often the measurement
message MetricResult {
  // Name is the name of the metric
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Phase is the overall aggregate status of the metric
  optional string phase = 2 [(gogoproto.casttype) = "AnalysisPhase", (gogoproto.customname) = "Phase", (gogoproto.nullable) = false];

  // Measurements holds the most recent measurements collected for the metric
  repeated Measurement measurements = 3 [(gogoproto.customname) = "Measurements", (gogoproto.nullable) = false];

  // Message contains a message describing current condition (e.g. error messages)
  optional string message = 4 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];

  // Count is the number of times the metric was measured without Error
  // This is equal to the sum of Successful, Failed, Inconclusive
  optional int32 count = 5 [(gogoproto.customname) = "Count", (gogoproto.nullable) = false];

  // Successful is the number of times the metric was measured Successful
  optional int32 successful = 6 [(gogoproto.customname) = "Successful", (gogoproto.nullable) = false];

  // Failed is the number of times the metric was measured Failed
  optional int32 failed = 7 [(gogoproto.customname) = "Failed", (gogoproto.nullable) = false];

  // Inconclusive is the number of times the metric was measured Inconclusive
  optional int32 inconclusive = 8 [(gogoproto.customname) = "Inconclusive", (gogoproto.nullable) = false];

  // Error is the number of times an error was encountered during measurement
  optional int32 error = 9 [(gogoproto.customname) = "Error", (gogoproto.nullable) = false];

  // ConsecutiveError is the number of times an error was encountered during measurement in succession
  // Resets to zero when non-errors are encountered
  optional int32 consecutiveError = 10 [(gogoproto.customname) = "ConsecutiveError", (gogoproto.nullable) = false];

  // DryRun indicates whether this metric is running in a dry-run mode or not
  optional bool dryRun = 11 [(gogoproto.customname) = "DryRun", (gogoproto.nullable) = false];

  // Metadata stores additional metadata about this metric. It is used by different providers to store
  // the final state which gets used while taking measurements. For example, Prometheus uses this field
  // to store the final resolved query after substituting the template arguments.
  map<string, string> metadata = 12 [(gogoproto.customname) = "Metadata", (gogoproto.nullable) = false];

  // ConsecutiveSuccess is the number of times a measurement was successful in succession
  // Resets to zero when failures, inconclusive measurements, or errors are encountered
  optional int32 consecutiveSuccess = 13 [(gogoproto.customname) = "ConsecutiveSuccess", (gogoproto.nullable) = false];
}

// NewRelicMetric defines the newrelic query to perform canary analysis
message NewRelicMetric {
  // Profile is the name of the secret holding NR account configuration
  optional string profile = 1 [(gogoproto.customname) = "Profile", (gogoproto.nullable) = false];

  // Query is a raw newrelic NRQL query to perform
  optional string query = 2 [(gogoproto.customname) = "Query", (gogoproto.nullable) = false];

  // Timeout represents the duration limit in seconds that will apply to the NRQL query
  // +optional
  optional int64 timeout = 3 [(gogoproto.customname) = "Timeout"];
}

// NginxTrafficRouting configuration for Nginx ingress controller to control traffic routing
message NginxTrafficRouting {
  // AnnotationPrefix has to match the configured annotation prefix on the nginx ingress controller
  // +optional
  optional string annotationPrefix = 1 [(gogoproto.customname) = "AnnotationPrefix", (gogoproto.nullable) = false];

  // StableIngress refers to the name of an `Ingress` resource in the same namespace as the `Rollout`
  optional string stableIngress = 2 [(gogoproto.customname) = "StableIngress", (gogoproto.nullable) = false];

  // +optional
  map<string, string> additionalIngressAnnotations = 3 [(gogoproto.customname) = "AdditionalIngressAnnotations", (gogoproto.nullable) = false];

  // StableIngresses refers to the names of `Ingress` resources in the same namespace as the `Rollout` in a multi ingress scenario
  // +optional
  repeated string stableIngresses = 4 [(gogoproto.customname) = "StableIngresses"];

  // +optional
  map<string, string> canaryIngressAnnotations = 5 [(gogoproto.customname) = "CanaryIngressAnnotations", (gogoproto.nullable) = false];
}

message OAuth2Config {
  // OAuth2 provider token URL
  optional string tokenUrl = 1 [(gogoproto.customname) = "TokenURL", (gogoproto.nullable) = false];

  // OAuth2 client ID
  optional string clientId = 2 [(gogoproto.customname) = "ClientID", (gogoproto.nullable) = false];

  // OAuth2 client secret
  optional string clientSecret = 3 [(gogoproto.customname) = "ClientSecret", (gogoproto.nullable) = false];

  // OAuth2 scopes
  // +optional
  repeated string scopes = 4 [(gogoproto.customname) = "Scopes"];
}

// ObjectRef holds a references to the Kubernetes object
message ObjectRef {
  // API Version of the referent
  optional string apiVersion = 1 [(gogoproto.customname) = "APIVersion", (gogoproto.nullable) = false];

  // Kind of the referent
  optional string kind = 2 [(gogoproto.customname) = "Kind", (gogoproto.nullable) = false];

  // Name of the referent
  optional string name = 3 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Automatically scale down deployment
  optional string scaleDown = 4 [(gogoproto.customname) = "ScaleDown", (gogoproto.nullable) = false];
}

// PauseCondition the reason for a pause and when it started
message PauseCondition {
  optional string reason = 1 [(gogoproto.casttype) = "PauseReason", (gogoproto.customname) = "Reason", (gogoproto.nullable) = false];

  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 2 [(gogoproto.customname) = "StartTime", (gogoproto.nullable) = false];
}

// PingPongSpec holds the ping and pong service name.
message PingPongSpec {
  // name of the ping service
  optional string pingService = 1 [(gogoproto.customname) = "PingService", (gogoproto.nullable) = false];

  // name of the pong service
  optional string pongService = 2 [(gogoproto.customname) = "PongService", (gogoproto.nullable) = false];
}

message PluginStep {
  // Name of the hashicorp go-plugin step to query
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // +kubebuilder:validation:Schemaless
  // +kubebuilder:pruning:PreserveUnknownFields
  // +kubebuilder:validation:Type=object
  // Config is the configuration object for the specified plugin
  optional bytes config = 2 [(gogoproto.casttype) = "encoding/json.RawMessage", (gogoproto.customname) = "Config"];
}

// PodTemplateMetadata extra labels to add to the template
message PodTemplateMetadata {
  // Labels Additional labels to add to the experiment
  // +optional
  map<string, string> labels = 1 [(gogoproto.customname) = "Labels", (gogoproto.nullable) = false];

  // Annotations additional annotations to add to the experiment
  // +optional
  map<string, string> annotations = 2 [(gogoproto.customname) = "Annotations", (gogoproto.nullable) = false];
}

// PreferredDuringSchedulingIgnoredDuringExecution defines the weight of the anti-affinity injection
message PreferredDuringSchedulingIgnoredDuringExecution {
  // Weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
  optional int32 weight = 1 [(gogoproto.customname) = "Weight", (gogoproto.nullable) = false];
}

// PrometheusMetric defines the prometheus query to perform canary analysis
message PrometheusMetric {
  // Address is the HTTP address and port of the prometheus server
  optional string address = 1 [(gogoproto.customname) = "Address", (gogoproto.nullable) = false];

  // Query is a raw prometheus query to perform
  optional string query = 2 [(gogoproto.customname) = "Query", (gogoproto.nullable) = false];

  // Authentication details
  // +optional
  optional Authentication authentication = 3 [(gogoproto.customname) = "Authentication", (gogoproto.nullable) = false];

  // Timeout represents the duration within which a prometheus query should complete. It is expressed in seconds.
  // +optional
  optional int64 timeout = 4 [(gogoproto.customname) = "Timeout"];

  // Insecure skips host TLS verification
  optional bool insecure = 5 [(gogoproto.customname) = "Insecure", (gogoproto.nullable) = false];

  // Headers are optional HTTP headers to use in the request
  // +optional
  // +patchMergeKey=key
  // +patchStrategy=merge
  repeated WebMetricHeader headers = 6 [(gogoproto.customname) = "Headers", (gogoproto.nullable) = false];

  // Arguments for prometheus
  // +optional
  optional PrometheusRangeQueryArgs rangeQuery = 7 [(gogoproto.customname) = "RangeQuery"];
}

// Arguments to perform a prometheus range query
message PrometheusRangeQueryArgs {
  // The start time to query in expr format e.g. now(), now() - duration("1h"), now() - duration("{{args.lookback_duration}}")
  optional string start = 1 [(gogoproto.customname) = "Start", (gogoproto.nullable) = false];

  // The end time to query in expr format e.g. now(), now() - duration("1h"), now() - duration("{{args.lookback_duration}}")
  optional string end = 2 [(gogoproto.customname) = "End", (gogoproto.nullable) = false];

  // The maximum time between two slices from the start to end (e.g. 30s, 5m, 1h).
  optional string step = 3 [(gogoproto.casttype) = "DurationString", (gogoproto.customname) = "Step", (gogoproto.nullable) = false];
}

message ReplicaProgressThreshold {
  // Type is used to specify whether the replica progress threshold is a percentage or a number. Required if replicaProgressThreshold is specified.
  optional string type = 1 [(gogoproto.casttype) = "ProgressType", (gogoproto.customname) = "Type", (gogoproto.nullable) = false];

  // Value contains the user-specified value for when a Argo Rollouts can promote a canary to the next step.
  // If not satisfied, this value will be assumed to be 100% of the total desired replicas for the given next step.
  // Value must also be greater than 0. Required.
  optional int32 value = 2 [(gogoproto.customname) = "Value", (gogoproto.nullable) = false];
}

// RequiredDuringSchedulingIgnoredDuringExecution defines inter-pod scheduling rule to be RequiredDuringSchedulingIgnoredDuringExecution
message RequiredDuringSchedulingIgnoredDuringExecution {
}

message RollbackWindowSpec {
  optional int32 revisions = 1 [(gogoproto.customname) = "Revisions", (gogoproto.nullable) = false];
}

// Rollout is a specification for a Rollout resource
message Rollout {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  optional RolloutSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];

  optional RolloutStatus status = 3 [(gogoproto.customname) = "Status", (gogoproto.nullable) = false];
}

// RolloutAnalysis defines a template that is used to create a analysisRun
message RolloutAnalysis {
  // Templates reference to a list of analysis templates to combine for an AnalysisRun
  // +patchMergeKey=templateName
  // +patchStrategy=merge
  repeated AnalysisTemplateRef templates = 1 [(gogoproto.customname) = "Templates", (gogoproto.nullable) = false];

  // Args the arguments that will be added to the AnalysisRuns
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated AnalysisRunArgument args = 2 [(gogoproto.customname) = "Args", (gogoproto.nullable) = false];

  // DryRun object contains the settings for running the analysis in Dry-Run mode
  // +patchMergeKey=metricName
  // +patchStrategy=merge
  // +optional
  repeated DryRun dryRun = 3 [(gogoproto.customname) = "DryRun", (gogoproto.nullable) = false];

  // MeasurementRetention object contains the settings for retaining the number of measurements during the analysis
  // +patchMergeKey=metricName
  // +patchStrategy=merge
  // +optional
  repeated MeasurementRetention measurementRetention = 4 [(gogoproto.customname) = "MeasurementRetention", (gogoproto.nullable) = false];

  // AnalysisRunMetadata labels and annotations that will be added to the AnalysisRuns
  // +optional
  optional AnalysisRunMetadata analysisRunMetadata = 5 [(gogoproto.customname) = "AnalysisRunMetadata", (gogoproto.nullable) = false];
}

// RolloutAnalysisBackground defines a template that is used to create a background analysisRun
message RolloutAnalysisBackground {
  optional RolloutAnalysis rolloutAnalysis = 1 [(gogoproto.customname) = "RolloutAnalysis", (gogoproto.nullable) = false];

  // StartingStep indicates which step the background analysis should start on
  // If not listed, controller defaults to 0
  optional int32 startingStep = 2 [(gogoproto.customname) = "StartingStep"];
}

message RolloutAnalysisRunStatus {
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  optional string status = 2 [(gogoproto.casttype) = "AnalysisPhase", (gogoproto.customname) = "Status", (gogoproto.nullable) = false];

  optional string message = 3 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];
}

// RolloutCondition describes the state of a rollout at a certain point.
message RolloutCondition {
  // Type of deployment condition.
  optional string type = 1 [(gogoproto.casttype) = "RolloutConditionType", (gogoproto.customname) = "Type", (gogoproto.nullable) = false];

  // Phase of the condition, one of True, False, Unknown.
  optional string status = 2 [(gogoproto.casttype) = "k8s.io/api/core/v1.ConditionStatus", (gogoproto.customname) = "Status", (gogoproto.nullable) = false];

  // The last time this condition was updated.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdateTime = 3 [(gogoproto.customname) = "LastUpdateTime", (gogoproto.nullable) = false];

  // Last time the condition transitioned from one status to another.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4 [(gogoproto.customname) = "LastTransitionTime", (gogoproto.nullable) = false];

  // The reason for the condition's last transition.
  optional string reason = 5 [(gogoproto.customname) = "Reason", (gogoproto.nullable) = false];

  // A human readable message indicating details about the transition.
  optional string message = 6 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];
}

// RolloutExperimentStep defines a template that is used to create a experiment for a step
message RolloutExperimentStep {
  // Templates what templates that should be added to the experiment. Should be non-nil
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated RolloutExperimentTemplate templates = 1 [(gogoproto.customname) = "Templates", (gogoproto.nullable) = false];

  // Duration is a duration string (e.g. 30s, 5m, 1h) that the experiment should run for
  // +optional
  optional string duration = 2 [(gogoproto.casttype) = "DurationString", (gogoproto.customname) = "Duration", (gogoproto.nullable) = false];

  // Analyses reference which analysis templates to run with the experiment
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated RolloutExperimentStepAnalysisTemplateRef analyses = 3 [(gogoproto.customname) = "Analyses", (gogoproto.nullable) = false];

  // DryRun object contains the settings for running the analysis in Dry-Run mode
  // +patchMergeKey=metricName
  // +patchStrategy=merge
  // +optional
  repeated DryRun dryRun = 4 [(gogoproto.customname) = "DryRun", (gogoproto.nullable) = false];

  // AnalysisRunMetadata labels and annotations that will be added to the AnalysisRuns
  // +optional
  optional AnalysisRunMetadata analysisRunMetadata = 5 [(gogoproto.customname) = "AnalysisRunMetadata", (gogoproto.nullable) = false];

  // ScaleDownDelaySeconds is the number of seconds to wait before scaling down the old ReplicaSet
  // +optional
  optional int32 scaleDownDelaySeconds = 6 [(gogoproto.customname) = "ScaleDownDelaySeconds"];
}

message RolloutExperimentStepAnalysisTemplateRef {
  // Name is a name for this analysis template invocation
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // TemplateName reference of the AnalysisTemplate name used by the Experiment to create the run
  optional string templateName = 2 [(gogoproto.customname) = "TemplateName", (gogoproto.nullable) = false];

  // Whether to look for the templateName at cluster scope or namespace scope
  // +optional
  optional bool clusterScope = 3 [(gogoproto.customname) = "ClusterScope", (gogoproto.nullable) = false];

  // Args the arguments that will be added to the AnalysisRuns
  // +patchMergeKey=name
  // +patchStrategy=merge
  repeated AnalysisRunArgument args = 4 [(gogoproto.customname) = "Args", (gogoproto.nullable) = false];

  // RequiredForCompletion blocks the Experiment from completing until the analysis has completed
  optional bool requiredForCompletion = 5 [(gogoproto.customname) = "RequiredForCompletion", (gogoproto.nullable) = false];
}

// RolloutExperimentTemplate defines the template used to create experiments for the Rollout's experiment canary step
message RolloutExperimentTemplate {
  // Name description of template that passed to the template
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // SpecRef indicates where the rollout should get the RS template from
  optional string specRef = 2 [(gogoproto.casttype) = "ReplicaSetSpecRef", (gogoproto.customname) = "SpecRef", (gogoproto.nullable) = false];

  // Replicas replica count for the template
  // +optional
  optional int32 replicas = 3 [(gogoproto.customname) = "Replicas"];

  // Metadata sets labels and annotations to use for the RS created from the template
  // +optional
  optional PodTemplateMetadata metadata = 4 [(gogoproto.customname) = "Metadata", (gogoproto.nullable) = false];

  // Selector overrides the selector to be used for the template's ReplicaSet. If omitted, will
  // use the same selector as the Rollout
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 5 [(gogoproto.customname) = "Selector"];

  // Weight sets the percentage of traffic the template's replicas should receive
  optional int32 weight = 6 [(gogoproto.customname) = "Weight"];

  // Service controls the optionally generated service
  optional TemplateService service = 7 [(gogoproto.customname) = "Service"];
}

// RolloutList is a list of Rollout resources
message RolloutList {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1 [(gogoproto.customname) = "ListMeta", (gogoproto.nullable) = false];

  repeated Rollout items = 2 [(gogoproto.customname) = "Items", (gogoproto.nullable) = false];
}

// RolloutPause defines a pause stage for a rollout
message RolloutPause {
  // Duration the amount of time to wait before moving to the next step.
  // +optional
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString duration = 1 [(gogoproto.customname) = "Duration"];
}

// RolloutSpec is the spec for a Rollout resource
message RolloutSpec {
  // Number of desired pods. This is a pointer to distinguish between explicit
  // zero and not specified. Defaults to 1.
  // +optional
  optional int32 replicas = 1 [(gogoproto.customname) = "Replicas"];

  // Label selector for pods. Existing ReplicaSets whose pods are
  // selected by this will be the ones affected by this rollout.
  // It must match the pod template's labels.
  // +optional
  // +kubebuilder:validation:XValidation:rule="self == oldSelf",message=".spec.selector is immutable"
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2 [(gogoproto.customname) = "Selector"];

  // Template describes the pods that will be created.
  // +optional
  optional k8s.io.api.core.v1.PodTemplateSpec template = 3 [(gogoproto.customname) = "Template", (gogoproto.nullable) = false];

  // WorkloadRef holds a references to a workload that provides Pod template
  // +optional
  optional ObjectRef workloadRef = 10 [(gogoproto.customname) = "WorkloadRef"];

  // Minimum number of seconds for which a newly created pod should be ready
  // without any of its container crashing, for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  // +optional
  optional int32 minReadySeconds = 4 [(gogoproto.customname) = "MinReadySeconds", (gogoproto.nullable) = false];

  // The window in which a rollback will be fast tracked (fully promoted)
  // +optional
  optional RollbackWindowSpec rollbackWindow = 13 [(gogoproto.customname) = "RollbackWindow"];

  // The deployment strategy to use to replace existing pods with new ones.
  // +optional
  optional RolloutStrategy strategy = 5 [(gogoproto.customname) = "Strategy", (gogoproto.nullable) = false];

  // The number of old ReplicaSets to retain. If unspecified, will retain 10 old ReplicaSets
  optional int32 revisionHistoryLimit = 6 [(gogoproto.customname) = "RevisionHistoryLimit"];

  // Paused pauses the rollout at its current step.
  optional bool paused = 7 [(gogoproto.customname) = "Paused", (gogoproto.nullable) = false];

  // ProgressDeadlineSeconds The maximum time in seconds for a rollout to
  // make progress before it is considered to be failed. Argo Rollouts will
  // continue to process failed rollouts and a condition with a
  // ProgressDeadlineExceeded reason will be surfaced in the rollout status.
  // Note that progress will not be estimated during the time a rollout is paused.
  // Defaults to 600s.
  optional int32 progressDeadlineSeconds = 8 [(gogoproto.customname) = "ProgressDeadlineSeconds"];

  // ProgressDeadlineAbort is whether to abort the update when ProgressDeadlineSeconds
  // is exceeded.
  // +optional
  optional bool progressDeadlineAbort = 12 [(gogoproto.customname) = "ProgressDeadlineAbort", (gogoproto.nullable) = false];

  // RestartAt indicates when all the pods of a Rollout should be restarted
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time restartAt = 9 [(gogoproto.customname) = "RestartAt"];

  // Analysis configuration for the analysis runs to retain
  optional AnalysisRunStrategy analysis = 11 [(gogoproto.customname) = "Analysis"];
}

// RolloutStatus is the status for a Rollout resource
message RolloutStatus {
  // Abort cancel the current rollout progression
  optional bool abort = 1 [(gogoproto.customname) = "Abort", (gogoproto.nullable) = false];

  // PauseConditions is a list of reasons why rollout became automatically paused (e.g.
  // CanaryPauseStep, BlueGreenPause, InconclusiveAnalysis). The items in this list are populated
  // by the controller but are cleared by the user (e.g. plugin, argo-cd resume action) when they
  // wish to unpause. If pause conditions is empty, but controllerPause is true, it indicates
  // the user manually unpaused the Rollout
  repeated PauseCondition pauseConditions = 2 [(gogoproto.customname) = "PauseConditions", (gogoproto.nullable) = false];

  // ControllerPause indicates the controller has paused the rollout. It is set to true when
  // the controller adds a pause condition. This field helps to discern the scenario where a
  // rollout was resumed after being paused by the controller (e.g. via the plugin). In that
  // situation, the pauseConditions would have been cleared , but controllerPause would still be
  // set to true.
  optional bool controllerPause = 3 [(gogoproto.customname) = "ControllerPause", (gogoproto.nullable) = false];

  // AbortedAt indicates the controller reconciled an aborted rollout. The controller uses this to understand if
  // the controller needs to do some specific work when a Rollout is aborted. For example, the reconcileAbort is used
  // to indicate if the Rollout should enter an aborted state when the latest AnalysisRun is a failure, or the controller
  // has already put the Rollout into an aborted and should create a new AnalysisRun.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time abortedAt = 4 [(gogoproto.customname) = "AbortedAt"];

  // CurrentPodHash the hash of the current pod template
  // +optional
  optional string currentPodHash = 5 [(gogoproto.customname) = "CurrentPodHash", (gogoproto.nullable) = false];

  // CurrentStepHash the hash of the current list of steps for the current strategy. This is used to detect when the
  // list of current steps change
  // +optional
  optional string currentStepHash = 6 [(gogoproto.customname) = "CurrentStepHash", (gogoproto.nullable) = false];

  // Total number of non-terminated pods targeted by this rollout (their labels match the selector).
  // +optional
  optional int32 replicas = 7 [(gogoproto.customname) = "Replicas", (gogoproto.nullable) = false];

  // Total number of non-terminated pods targeted by this rollout that have the desired template spec.
  // +optional
  optional int32 updatedReplicas = 8 [(gogoproto.customname) = "UpdatedReplicas", (gogoproto.nullable) = false];

  // Total number of ready pods targeted by this rollout.
  // +optional
  optional int32 readyReplicas = 9 [(gogoproto.customname) = "ReadyReplicas", (gogoproto.nullable) = false];

  // Total number of available pods (ready for at least minReadySeconds) targeted by this rollout.
  // +optional
  optional int32 availableReplicas = 10 [(gogoproto.customname) = "AvailableReplicas", (gogoproto.nullable) = false];

  // CurrentStepIndex defines the current step of the rollout is on. If the current step index is null, the
  // controller will execute the rollout.
  // +optional
  optional int32 currentStepIndex = 11 [(gogoproto.customname) = "CurrentStepIndex"];

  // Count of hash collisions for the Rollout. The Rollout controller uses this
  // field as a collision avoidance mechanism when it needs to create the name for the
  // newest ReplicaSet.
  // +optional
  optional int32 collisionCount = 12 [(gogoproto.customname) = "CollisionCount"];

  // The generation observed by the rollout controller from metadata.generation
  // +optional
  optional string observedGeneration = 13 [(gogoproto.customname) = "ObservedGeneration", (gogoproto.nullable) = false];

  // Conditions a list of conditions a rollout can have.
  // +optional
  repeated RolloutCondition conditions = 14 [(gogoproto.customname) = "Conditions", (gogoproto.nullable) = false];

  // Canary describes the state of the canary rollout
  // +optional
  optional CanaryStatus canary = 15 [(gogoproto.customname) = "Canary", (gogoproto.nullable) = false];

  // BlueGreen describes the state of the bluegreen rollout
  // +optional
  optional BlueGreenStatus blueGreen = 16 [(gogoproto.customname) = "BlueGreen", (gogoproto.nullable) = false];

  // HPAReplicas the number of non-terminated replicas that are receiving active traffic
  // +optional
  optional int32 HPAReplicas = 17 [(gogoproto.nullable) = false];

  // Selector that identifies the pods that are receiving active traffic
  // +optional
  optional string selector = 18 [(gogoproto.customname) = "Selector", (gogoproto.nullable) = false];

  // StableRS indicates the replicaset that has successfully rolled out
  // +optional
  optional string stableRS = 19 [(gogoproto.customname) = "StableRS", (gogoproto.nullable) = false];

  // RestartedAt indicates last time a Rollout was restarted
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time restartedAt = 20 [(gogoproto.customname) = "RestartedAt"];

  // PromoteFull indicates if the rollout should perform a full promotion, skipping analysis and pauses.
  optional bool promoteFull = 21 [(gogoproto.customname) = "PromoteFull", (gogoproto.nullable) = false];

  // Phase is the rollout phase. Clients should only rely on the value if status.observedGeneration equals metadata.generation
  optional string phase = 22 [(gogoproto.casttype) = "RolloutPhase", (gogoproto.customname) = "Phase", (gogoproto.nullable) = false];

  // Message provides details on why the rollout is in its current phase
  optional string message = 23 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];

  // The generation of referenced workload observed by the rollout controller
  // +optional
  optional string workloadObservedGeneration = 24 [(gogoproto.customname) = "WorkloadObservedGeneration", (gogoproto.nullable) = false];

  // / ALB keeps information regarding the ALB and TargetGroups
  optional ALBStatus alb = 25 [(gogoproto.customname) = "ALB"];

  // / ALBs keeps information regarding multiple ALBs and TargetGroups in a multi ingress scenario
  repeated ALBStatus albs = 26 [(gogoproto.customname) = "ALBs", (gogoproto.nullable) = false];
}

// RolloutStrategy defines strategy to apply during next rollout
message RolloutStrategy {
  // +optional
  optional BlueGreenStrategy blueGreen = 1 [(gogoproto.customname) = "BlueGreen"];

  // +optional
  optional CanaryStrategy canary = 2 [(gogoproto.customname) = "Canary"];
}

// RolloutTrafficRouting hosts all the different configuration for supported service meshes to enable more fine-grained traffic routing
message RolloutTrafficRouting {
  // Istio holds Istio specific configuration to route traffic
  optional IstioTrafficRouting istio = 1 [(gogoproto.customname) = "Istio"];

  // Nginx holds Nginx Ingress specific configuration to route traffic
  optional NginxTrafficRouting nginx = 2 [(gogoproto.customname) = "Nginx"];

  // Nginx holds ALB Ingress specific configuration to route traffic
  optional ALBTrafficRouting alb = 3 [(gogoproto.customname) = "ALB"];

  // SMI holds TrafficSplit specific configuration to route traffic
  optional SMITrafficRouting smi = 4 [(gogoproto.customname) = "SMI"];

  // Ambassador holds specific configuration to use Ambassador to route traffic
  optional AmbassadorTrafficRouting ambassador = 5 [(gogoproto.customname) = "Ambassador"];

  // AppMesh holds specific configuration to use AppMesh to route traffic
  optional AppMeshTrafficRouting appMesh = 6 [(gogoproto.customname) = "AppMesh"];

  // Traefik holds specific configuration to use Traefik to route traffic
  optional TraefikTrafficRouting traefik = 7 [(gogoproto.customname) = "Traefik"];

  // ManagedRoutes A list of HTTP routes that Argo Rollouts manages, the order of this array also becomes the precedence in the upstream
  // traffic router.
  repeated MangedRoutes managedRoutes = 8 [(gogoproto.customname) = "ManagedRoutes", (gogoproto.nullable) = false];

  // Apisix holds specific configuration to use Apisix to route traffic
  optional ApisixTrafficRouting apisix = 9 [(gogoproto.customname) = "Apisix"];

  // +kubebuilder:validation:Schemaless
  // +kubebuilder:pruning:PreserveUnknownFields
  // +kubebuilder:validation:Type=object
  // Plugins holds specific configuration that traffic router plugins can use for routing traffic
  map<string, bytes> plugins = 10 [(gogoproto.castvalue) = "encoding/json.RawMessage", (gogoproto.customname) = "Plugins", (gogoproto.nullable) = false];

  // MaxTrafficWeight The total weight of traffic. If unspecified, it defaults to 100
  optional int32 maxTrafficWeight = 11 [(gogoproto.customname) = "MaxTrafficWeight"];
}

message RouteMatch {
  // Method What http methods should be mirrored
  // +optional
  optional StringMatch method = 1 [(gogoproto.customname) = "Method"];

  // Path What url paths should be mirrored
  // +optional
  optional StringMatch path = 2 [(gogoproto.customname) = "Path"];

  // Headers What request with matching headers should be mirrored
  // +optional
  map<string, StringMatch> headers = 3 [(gogoproto.customname) = "Headers", (gogoproto.nullable) = false];
}

// RunSummary contains the final results from the metric executions
message RunSummary {
  // This is equal to the sum of Successful, Failed, Inconclusive
  optional int32 count = 1 [(gogoproto.customname) = "Count", (gogoproto.nullable) = false];

  // Successful is the number of times the metric was measured Successful
  optional int32 successful = 2 [(gogoproto.customname) = "Successful", (gogoproto.nullable) = false];

  // Failed is the number of times the metric was measured Failed
  optional int32 failed = 3 [(gogoproto.customname) = "Failed", (gogoproto.nullable) = false];

  // Inconclusive is the number of times the metric was measured Inconclusive
  optional int32 inconclusive = 4 [(gogoproto.customname) = "Inconclusive", (gogoproto.nullable) = false];

  // Error is the number of times an error was encountered during measurement
  optional int32 error = 5 [(gogoproto.customname) = "Error", (gogoproto.nullable) = false];
}

// SMITrafficRouting configuration for TrafficSplit Custom Resource to control traffic routing
message SMITrafficRouting {
  // RootService holds the name of that clients use to communicate.
  // +optional
  optional string rootService = 1 [(gogoproto.customname) = "RootService", (gogoproto.nullable) = false];

  // TrafficSplitName holds the name of the TrafficSplit.
  // +optional
  optional string trafficSplitName = 2 [(gogoproto.customname) = "TrafficSplitName", (gogoproto.nullable) = false];
}

message ScopeDetail {
  optional string scope = 1 [(gogoproto.customname) = "Scope", (gogoproto.nullable) = false];

  optional string region = 2 [(gogoproto.customname) = "Region", (gogoproto.nullable) = false];

  optional int64 step = 3 [(gogoproto.customname) = "Step", (gogoproto.nullable) = false];

  optional string start = 4 [(gogoproto.customname) = "Start", (gogoproto.nullable) = false];

  optional string end = 5 [(gogoproto.customname) = "End", (gogoproto.nullable) = false];
}

message SecretKeyRef {
  // Name is the name of the secret
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Key is the key of the secret to select from.
  optional string key = 2 [(gogoproto.customname) = "Key", (gogoproto.nullable) = false];
}

message SecretRef {
  // Name refers to the name of the secret that should be used to integrate with Datadog.
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Namespaced indicates whether the secret is in the namespace where rollouts it installed or in the namespace where the metric was found
  optional bool namespaced = 2 [(gogoproto.customname) = "Namespaced", (gogoproto.nullable) = false];
}

// SetCanaryScale defines how to scale the newRS without changing traffic weight
message SetCanaryScale {
  // Weight sets the percentage of replicas the newRS should have
  // +optional
  optional int32 weight = 1 [(gogoproto.customname) = "Weight"];

  // Replicas sets the number of replicas the newRS should have
  // +optional
  optional int32 replicas = 2 [(gogoproto.customname) = "Replicas"];

  // MatchTrafficWeight cancels out previously set Replicas or Weight, effectively activating SetWeight
  // +optional
  optional bool matchTrafficWeight = 3 [(gogoproto.customname) = "MatchTrafficWeight", (gogoproto.nullable) = false];
}

// SetHeaderRoute defines the route with specified header name to send 100% of traffic to the canary service
message SetHeaderRoute {
  // Name this is the name of the route to use for the mirroring of traffic this also needs
  // to be included in the `spec.strategy.canary.trafficRouting.managedRoutes` field
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  repeated HeaderRoutingMatch match = 2 [(gogoproto.customname) = "Match", (gogoproto.nullable) = false];
}

message SetMirrorRoute {
  // Name this is the name of the route to use for the mirroring of traffic this also needs
  // to be included in the `spec.strategy.canary.trafficRouting.managedRoutes` field
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Match Contains a list of rules that if mated will mirror the traffic to the services
  // +optional
  repeated RouteMatch match = 2 [(gogoproto.customname) = "Match", (gogoproto.nullable) = false];

  // Services The list of services to mirror the traffic to if the method, path, headers match
  // Service string `json:"service" protobuf:"bytes,3,opt,name=service"`
  // Percentage What percent of the traffic that matched the rules should be mirrored
  optional int32 percentage = 4 [(gogoproto.customname) = "Percentage"];
}

message Sigv4Config {
  // Region is the AWS Region to sign the SigV4 Request
  optional string address = 1 [(gogoproto.customname) = "Region", (gogoproto.nullable) = false];

  // Profile is the Credential Profile used to sign the SigV4 Request
  optional string profile = 2 [(gogoproto.customname) = "Profile", (gogoproto.nullable) = false];

  // RoleARN is the IAM role used to sign the SIgV4 Request
  optional string roleArn = 3 [(gogoproto.customname) = "RoleARN", (gogoproto.nullable) = false];
}

message SkyWalkingMetric {
  optional string address = 1 [(gogoproto.customname) = "Address", (gogoproto.nullable) = false];

  optional string query = 2 [(gogoproto.customname) = "Query", (gogoproto.nullable) = false];

  optional string interval = 3 [(gogoproto.casttype) = "DurationString", (gogoproto.customname) = "Interval", (gogoproto.nullable) = false];
}

message StepPluginStatus {
  // Index is the matching step index of the executed plugin
  optional int32 index = 1 [(gogoproto.customname) = "Index", (gogoproto.nullable) = false];

  // Name is the matching step name of the executed plugin
  optional string name = 2 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Operation is the name of the operation that produced this status
  optional string operation = 3 [(gogoproto.casttype) = "StepPluginOperation", (gogoproto.customname) = "Operation", (gogoproto.nullable) = false];

  // Phase is the resulting phase of the operation
  optional string phase = 4 [(gogoproto.casttype) = "StepPluginPhase", (gogoproto.customname) = "Phase", (gogoproto.nullable) = false];

  // Message provides details on why the plugin is in its current phase
  optional string message = 5 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];

  // StartedAt indicates when the plugin was first called for the operation
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 6 [(gogoproto.customname) = "StartedAt"];

  // UpdatedAt indicates when the plugin was last called for the operation
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time updatedAt = 7 [(gogoproto.customname) = "UpdatedAt"];

  // FinishedAt indicates when the operation was completed
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 8 [(gogoproto.customname) = "FinishedAt"];

  // Backoff is a duration to wait before trying to execute the operation again if it was not completed
  optional string backoff = 9 [(gogoproto.casttype) = "DurationString", (gogoproto.customname) = "Backoff", (gogoproto.nullable) = false];

  // Executions is the number of time the operation was executed
  optional int32 executions = 10 [(gogoproto.customname) = "Executions", (gogoproto.nullable) = false];

  // Disabled indicates if the plugin is globally disabled
  optional bool disabled = 11 [(gogoproto.customname) = "Disabled", (gogoproto.nullable) = false];

  // +kubebuilder:validation:Schemaless
  // +kubebuilder:pruning:PreserveUnknownFields
  // +kubebuilder:validation:Type=object
  // Status holds the internal status of the plugin for this operation
  optional bytes status = 12 [(gogoproto.casttype) = "encoding/json.RawMessage", (gogoproto.customname) = "Status"];
}

message StickinessConfig {
  optional bool enabled = 1 [(gogoproto.customname) = "Enabled", (gogoproto.nullable) = false];

  optional int64 durationSeconds = 2 [(gogoproto.customname) = "DurationSeconds", (gogoproto.nullable) = false];
}

// StringMatch Used to define what type of matching we will use exact, prefix, or regular expression
message StringMatch {
  // Exact The string must match exactly
  optional string exact = 1 [(gogoproto.customname) = "Exact", (gogoproto.nullable) = false];

  // Prefix The string will be prefixed matched
  optional string prefix = 2 [(gogoproto.customname) = "Prefix", (gogoproto.nullable) = false];

  // Regex The string will be regular expression matched
  optional string regex = 3 [(gogoproto.customname) = "Regex", (gogoproto.nullable) = false];
}

// TCPRoute holds the information on the virtual service's TCP routes that are desired to be matched for changing weights.
message TCPRoute {
  // Port number of the TCP Route desired to be matched in the given Istio VirtualService.
  optional int64 port = 1 [(gogoproto.customname) = "Port", (gogoproto.nullable) = false];
}

// TLSRoute holds the information on the virtual service's TLS/HTTPS routes that are desired to be matched for changing weights.
message TLSRoute {
  // Port number of the TLS Route desired to be matched in the given Istio VirtualService.
  optional int64 port = 1 [(gogoproto.customname) = "Port", (gogoproto.nullable) = false];

  // A list of all the SNI Hosts of the TLS Route desired to be matched in the given Istio VirtualService.
  repeated string sniHosts = 2 [(gogoproto.customname) = "SNIHosts"];
}

// TTLStrategy defines the strategy for the time to live depending on if the analysis succeeded or failed
message TTLStrategy {
  // SecondsAfterCompletion is the number of seconds to live after completion.
  optional int32 secondsAfterCompletion = 1 [(gogoproto.customname) = "SecondsAfterCompletion"];

  // SecondsAfterFailure is the number of seconds to live after failure.
  optional int32 secondsAfterFailure = 2 [(gogoproto.customname) = "SecondsAfterFailure"];

  // SecondsAfterSuccess is the number of seconds to live after success.
  optional int32 secondsAfterSuccess = 3 [(gogoproto.customname) = "SecondsAfterSuccess"];
}

message TemplateService {
  // Name of the service generated by the experiment
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];
}

message TemplateSpec {
  // Name of the template used to identity replicaset running for this experiment
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Number of desired pods. This is a pointer to distinguish between explicit
  // zero and not specified. Defaults to 1.
  // +optional
  optional int32 replicas = 2 [(gogoproto.customname) = "Replicas"];

  // Minimum number of seconds for which a newly created pod should be ready
  // without any of its container crashing, for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  // +optional
  optional int32 minReadySeconds = 3 [(gogoproto.customname) = "MinReadySeconds", (gogoproto.nullable) = false];

  // Label selector for pods. Existing ReplicaSets whose pods are
  // selected by this will be the ones affected by this experiment.
  // It must match the pod template's labels. Each selector must be unique to the other selectors in the other templates
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4 [(gogoproto.customname) = "Selector"];

  // Template describes the pods that will be created.
  optional k8s.io.api.core.v1.PodTemplateSpec template = 5 [(gogoproto.customname) = "Template", (gogoproto.nullable) = false];

  // TemplateService describes how a service should be generated for template
  optional TemplateService service = 6 [(gogoproto.customname) = "Service"];
}

// TemplateStatus is the status of a specific template of an Experiment
message TemplateStatus {
  // Name of the template used to identity which hash to compare to the hash
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Total number of non-terminated pods targeted by this experiment (their labels match the selector).
  optional int32 replicas = 2 [(gogoproto.customname) = "Replicas", (gogoproto.nullable) = false];

  // Total number of non-terminated pods targeted by this experiment that have the desired template spec.
  optional int32 updatedReplicas = 3 [(gogoproto.customname) = "UpdatedReplicas", (gogoproto.nullable) = false];

  // Total number of ready pods targeted by this experiment.
  optional int32 readyReplicas = 4 [(gogoproto.customname) = "ReadyReplicas", (gogoproto.nullable) = false];

  // Total number of available pods (ready for at least minReadySeconds) targeted by this experiment.
  optional int32 availableReplicas = 5 [(gogoproto.customname) = "AvailableReplicas", (gogoproto.nullable) = false];

  // CollisionCount count of hash collisions for the Experiment. The Experiment controller uses this
  // field as a collision avoidance mechanism when it needs to create the name for the
  // newest ReplicaSet.
  // +optional
  optional int32 collisionCount = 6 [(gogoproto.customname) = "CollisionCount"];

  // Phase is the status of the ReplicaSet associated with the template
  optional string status = 7 [(gogoproto.casttype) = "TemplateStatusCode", (gogoproto.customname) = "Status", (gogoproto.nullable) = false];

  // Message is a message explaining the current status
  optional string message = 8 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];

  // LastTransitionTime is the last time the replicaset transitioned, which resets the countdown
  // on the ProgressDeadlineSeconds check.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 9 [(gogoproto.customname) = "LastTransitionTime"];

  // ServiceName is the name of the service which corresponds to this experiment
  optional string serviceName = 10 [(gogoproto.customname) = "ServiceName", (gogoproto.nullable) = false];

  // PodTemplateHash is the value of the Replicas' PodTemplateHash
  optional string podTemplateHash = 11 [(gogoproto.customname) = "PodTemplateHash", (gogoproto.nullable) = false];
}

// TraefikTrafficRouting defines the configuration required to use Traefik as traffic router
message TraefikTrafficRouting {
  // TraefikServiceName refer to the name of the Traefik service used to route traffic to the service
  optional string weightedTraefikServiceName = 1 [(gogoproto.customname) = "WeightedTraefikServiceName", (gogoproto.nullable) = false];
}

// TrafficWeights describes the current status of how traffic has been split
message TrafficWeights {
  // Canary is the current traffic weight split to canary ReplicaSet
  optional WeightDestination canary = 1 [(gogoproto.customname) = "Canary", (gogoproto.nullable) = false];

  // Stable is the current traffic weight split to stable ReplicaSet
  optional WeightDestination stable = 2 [(gogoproto.customname) = "Stable", (gogoproto.nullable) = false];

  // Additional holds the weights split to additional ReplicaSets such as experiment ReplicaSets
  repeated WeightDestination additional = 3 [(gogoproto.customname) = "Additional", (gogoproto.nullable) = false];

  // Verified is an optional indicator that the weight has been verified to have taken effect.
  // This is currently only applicable to ALB traffic router
  optional bool verified = 4 [(gogoproto.customname) = "Verified"];
}

message ValueFrom {
  // Secret is a reference to where a secret is stored. This field is one of the fields with valueFrom
  // +optional
  optional SecretKeyRef secretKeyRef = 1 [(gogoproto.customname) = "SecretKeyRef"];

  // FieldRef is a reference to the fields in metadata which we are referencing. This field is one of the fields with
  // valueFrom
  // +optional
  optional FieldRef fieldRef = 2 [(gogoproto.customname) = "FieldRef"];
}

// WavefrontMetric defines the wavefront query to perform canary analysis
message WavefrontMetric {
  // Address is the HTTP address and port of the wavefront server
  optional string address = 1 [(gogoproto.customname) = "Address", (gogoproto.nullable) = false];

  // Query is a raw wavefront query to perform
  optional string query = 2 [(gogoproto.customname) = "Query", (gogoproto.nullable) = false];
}

message WebMetric {
  // Method is the method of the web metric (empty defaults to GET)
  optional string method = 1 [(gogoproto.casttype) = "WebMetricMethod", (gogoproto.customname) = "Method", (gogoproto.nullable) = false];

  // URL is the address of the web metric
  optional string url = 2 [(gogoproto.customname) = "URL", (gogoproto.nullable) = false];

  // +patchMergeKey=key
  // +patchStrategy=merge
  // Headers are optional HTTP headers to use in the request
  repeated WebMetricHeader headers = 3 [(gogoproto.customname) = "Headers", (gogoproto.nullable) = false];

  // Body is the body of the web metric (must be POST/PUT)
  optional string body = 4 [(gogoproto.customname) = "Body", (gogoproto.nullable) = false];

  // TimeoutSeconds is the timeout for the request in seconds (default: 10)
  optional int64 timeoutSeconds = 5 [(gogoproto.customname) = "TimeoutSeconds", (gogoproto.nullable) = false];

  // JSONPath is a JSON Path to use as the result variable (default: "{$}")
  optional string jsonPath = 6 [(gogoproto.customname) = "JSONPath", (gogoproto.nullable) = false];

  // Insecure skips host TLS verification
  optional bool insecure = 7 [(gogoproto.customname) = "Insecure", (gogoproto.nullable) = false];

  // +kubebuilder:validation:Schemaless
  // +kubebuilder:pruning:PreserveUnknownFields
  // +kubebuilder:validation:Type=object
  // JSONBody is the body of the web metric in a json format (method must be POST/PUT)
  optional bytes jsonBody = 8 [(gogoproto.casttype) = "encoding/json.RawMessage", (gogoproto.customname) = "JSONBody"];

  // Authentication details
  // +optional
  optional Authentication authentication = 9 [(gogoproto.customname) = "Authentication", (gogoproto.nullable) = false];
}

message WebMetricHeader {
  optional string key = 1 [(gogoproto.customname) = "Key", (gogoproto.nullable) = false];

  optional string value = 2 [(gogoproto.customname) = "Value", (gogoproto.nullable) = false];
}

message WeightDestination {
  // Weight is an percentage of traffic being sent to this destination
  optional int32 weight = 1 [(gogoproto.customname) = "Weight", (gogoproto.nullable) = false];

  // ServiceName is the Kubernetes service name traffic is being sent to
  optional string serviceName = 2 [(gogoproto.customname) = "ServiceName", (gogoproto.nullable) = false];

  // PodTemplateHash is the pod template hash label for this destination
  optional string podTemplateHash = 3 [(gogoproto.customname) = "PodTemplateHash", (gogoproto.nullable) = false];
}

