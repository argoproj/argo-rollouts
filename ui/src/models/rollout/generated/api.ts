/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * pkg/apiclient/rollout/rollout.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus
     */
    loadBalancer?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus
     */
    canaryTargetGroup?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus
     */
    stableTargetGroup?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus
     */
    ingress?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    ingress?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    servicePort?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    rootService?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    annotationPrefix?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StickinessConfig}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    stickinessConfig?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StickinessConfig;
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    ingresses?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting {
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting
     */
    mappings?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
     */
    value?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
     */
    valueFrom?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunMetadata
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunMetadata {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunMetadata
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunMetadata
     */
    annotations?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunSpec
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunSpec {
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunSpec
     */
    metrics?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Argument>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunSpec
     */
    args?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Argument>;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunSpec
     */
    terminate?: boolean;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DryRun>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunSpec
     */
    dryRun?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DryRun>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MeasurementRetention>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunSpec
     */
    measurementRetention?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MeasurementRetention>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus
     */
    phase?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus
     */
    message?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus
     */
    metricResults?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult>;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus
     */
    startedAt?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus
     */
    runSummary?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus
     */
    dryRunSummary?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStrategy
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStrategy {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStrategy
     */
    successfulRunHistoryLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStrategy
     */
    unsuccessfulRunHistoryLimit?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RequiredDuringSchedulingIgnoredDuringExecution}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RequiredDuringSchedulingIgnoredDuringExecution;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixRoute
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixRoute {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixRoute
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixRoute
     */
    rules?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixTrafficRouting {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixRoute}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixTrafficRouting
     */
    route?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixRoute;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshTrafficRouting {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualService}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshTrafficRouting
     */
    virtualService?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualService;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeGroup}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshTrafficRouting
     */
    virtualNodeGroup?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeGroup;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeGroup
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeGroup {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeReference}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeGroup
     */
    canaryVirtualNodeRef?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeReference;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeReference}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeGroup
     */
    stableVirtualNodeRef?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeReference;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeReference
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeReference {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualNodeReference
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualService
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualService {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualService
     */
    name?: string;
    /**
     * Routes is list of HTTP routes within virtual router associated with virtual service to edit. If omitted, virtual service must have a single route of this type.
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshVirtualService
     */
    routes?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Argument
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Argument {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Argument
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Argument
     */
    value?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ValueFrom}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Argument
     */
    valueFrom?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ValueFrom;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom
     */
    podTemplateHashValue?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom
     */
    fieldRef?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef
     */
    arn?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AwsResourceRef
     */
    fullName?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    previewSelector?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    activeSelector?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    scaleUpPreviewCheckPoint?: boolean;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    prePromotionAnalysisRunStatus?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    postPromotionAnalysisRunStatus?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy {
    /**
     * Name of the service that the rollout modifies as the active service.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    activeService?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    previewService?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    previewReplicaCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    autoPromotionEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    autoPromotionSeconds?: number;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    maxUnavailable?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    scaleDownDelaySeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    scaleDownDelayRevisionLimit?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    prePromotionAnalysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    antiAffinity?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    postPromotionAnalysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    previewMetadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    activeMetadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    abortScaleDownDelaySeconds?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
     */
    currentStepAnalysisRunStatus?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
     */
    currentBackgroundAnalysisRunStatus?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
     */
    currentExperiment?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TrafficWeights}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
     */
    weights?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TrafficWeights;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
     */
    stablePingPong?: string;
}
/**
 * CanaryStep defines a step of a canary deployment.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    setWeight?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    pause?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    experiment?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    analysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    setCanaryScale?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetHeaderRoute}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    setHeaderRoute?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetHeaderRoute;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetMirrorRoute}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    setMirrorRoute?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetMirrorRoute;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    canaryService?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    stableService?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    steps?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    trafficRouting?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    maxUnavailable?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    maxSurge?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    analysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    antiAffinity?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    canaryMetadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    stableMetadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    scaleDownDelaySeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    scaleDownDelayRevisionLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    abortScaleDownDelaySeconds?: number;
    /**
     * DynamicStableScale is a traffic routing feature which dynamically scales the stable ReplicaSet to minimize total pods which are running during an update. This is calculated by scaling down the stable as traffic is increased to canary. When disabled (the default behavior) the stable ReplicaSet remains fully scaled to support instantaneous aborts.
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    dynamicStableScale?: boolean;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PingPongSpec}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    pingPong?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PingPongSpec;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    minPodsPerReplicaSet?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetric
     */
    interval?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetric
     */
    metricDataQueries?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery
     */
    expression?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery
     */
    label?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStat}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery
     */
    metricStat?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStat;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery
     */
    period?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricDataQuery
     */
    returnData?: boolean;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStat
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStat {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStat
     */
    metric?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetric;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStat
     */
    period?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStat
     */
    stat?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStat
     */
    unit?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetric {
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetricDimension>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetric
     */
    dimensions?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetricDimension>;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetric
     */
    metricName?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetric
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetricDimension
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetricDimension {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetricDimension
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetricStatMetricDimension
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DatadogMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DatadogMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DatadogMetric
     */
    interval?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DatadogMetric
     */
    query?: string;
    /**
     * ApiVersion refers to the Datadog API version being used (default: v1). v1 will eventually be deprecated.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DatadogMetric
     */
    apiVersion?: string;
}
/**
 * DryRun defines the settings for running the analysis in Dry-Run mode.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DryRun
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DryRun {
    /**
     * Name of the metric which needs to be evaluated in the Dry-Run mode. Wildcard '*' is supported and denotes all the available metrics.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DryRun
     */
    metricName?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef
     */
    fieldPath?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1GraphiteMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1GraphiteMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1GraphiteMetric
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1GraphiteMetric
     */
    query?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1HeaderRoutingMatch
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1HeaderRoutingMatch {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1HeaderRoutingMatch
     */
    headerName?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1HeaderRoutingMatch
     */
    headerValue?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1InfluxdbMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1InfluxdbMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1InfluxdbMetric
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1InfluxdbMetric
     */
    query?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule
     */
    canarySubsetName?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule
     */
    stableSubsetName?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting
     */
    virtualService?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting
     */
    destinationRule?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting
     */
    virtualServices?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService
     */
    name?: string;
    /**
     * A list of HTTP routes within VirtualService to edit. If omitted, VirtualService must have a single route of this type.
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService
     */
    routes?: Array<string>;
    /**
     * A list of TLS/HTTPS routes within VirtualService to edit. If omitted, VirtualService must have a single route of this type.
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TLSRoute>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService
     */
    tlsRoutes?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TLSRoute>;
    /**
     * A list of TCP routes within VirtualService to edit. If omitted, VirtualService must have a single route of this type.
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TCPRoute>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService
     */
    tcpRoutes?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TCPRoute>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobMetric {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobMetric
     */
    metadata?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {K8sIoApiBatchV1JobSpec}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobMetric
     */
    spec?: K8sIoApiBatchV1JobSpec;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric
     */
    application?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric
     */
    canaryConfigName?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric
     */
    metricsAccountName?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric
     */
    configurationAccountName?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric
     */
    storageAccountName?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaThreshold}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric
     */
    threshold?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaThreshold;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaScope>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric
     */
    scopes?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaScope>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaScope
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaScope {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaScope
     */
    name?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaScope
     */
    controlScope?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaScope
     */
    experimentScope?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaThreshold
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaThreshold {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaThreshold
     */
    pass?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaThreshold
     */
    marginal?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MangedRoutes
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MangedRoutes {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MangedRoutes
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement
     */
    phase?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement
     */
    message?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement
     */
    startedAt?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement
     */
    finishedAt?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement
     */
    value?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement
     */
    metadata?: { [key: string]: string; };
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement
     */
    resumeAt?: K8sIoApimachineryPkgApisMetaV1Time;
}
/**
 * MeasurementRetention defines the settings for retaining the number of measurements during the analysis.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MeasurementRetention
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MeasurementRetention {
    /**
     * MetricName is the name of the metric on which this retention policy should be applied.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MeasurementRetention
     */
    metricName?: string;
    /**
     * Limit is the maximum number of measurements to be retained for this given metric.
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MeasurementRetention
     */
    limit?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    interval?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    initialDelay?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    count?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    successCondition?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    failureCondition?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    failureLimit?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    inconclusiveLimit?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    consecutiveErrorLimit?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Metric
     */
    provider?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    prometheus?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    kayenta?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1KayentaMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    web?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DatadogMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    datadog?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DatadogMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WavefrontMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    wavefront?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WavefrontMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NewRelicMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    newRelic?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NewRelicMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    job?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    cloudWatch?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CloudWatchMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1GraphiteMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    graphite?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1GraphiteMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1InfluxdbMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    influxdb?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1InfluxdbMetric;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SkyWalkingMetric}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    skywalking?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SkyWalkingMetric;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricProvider
     */
    plugin?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    phase?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    measurements?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Measurement>;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    successful?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    failed?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    inconclusive?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    error?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    consecutiveError?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    dryRun?: boolean;
    /**
     * Metadata stores additional metadata about this metric. It is used by different providers to store the final state which gets used while taking measurements. For example, Prometheus uses this field to store the final resolved query after substituting the template arguments.
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MetricResult
     */
    metadata?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NewRelicMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NewRelicMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NewRelicMetric
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NewRelicMetric
     */
    query?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting
     */
    annotationPrefix?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting
     */
    stableIngress?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting
     */
    additionalIngressAnnotations?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting
     */
    stableIngresses?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef
     */
    apiVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition
     */
    reason?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition
     */
    startTime?: K8sIoApimachineryPkgApisMetaV1Time;
}
/**
 * PingPongSpec holds the ping and pong service name.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PingPongSpec
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PingPongSpec {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PingPongSpec
     */
    pingService?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PingPongSpec
     */
    pongService?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata
     */
    annotations?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * Weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution
     */
    weight?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusAuth
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusAuth {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Sigv4Config}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusAuth
     */
    sigv4?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Sigv4Config;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric
     */
    query?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusAuth}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric
     */
    authentication?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusAuth;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric
     */
    timeout?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric
     */
    insecure?: boolean;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetricHeader>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PrometheusMetric
     */
    headers?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetricHeader>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RequiredDuringSchedulingIgnoredDuringExecution {
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RollbackWindowSpec
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RollbackWindowSpec {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RollbackWindowSpec
     */
    revisions?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout
     */
    metadata?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout
     */
    spec?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout
     */
    status?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis {
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
     */
    templates?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
     */
    args?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DryRun>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
     */
    dryRun?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1DryRun>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MeasurementRetention>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
     */
    measurementRetention?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MeasurementRetention>;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
     */
    analysisRunMetadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunMetadata;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground
     */
    rolloutAnalysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground
     */
    startingStep?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate
     */
    templateName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate
     */
    clusterScope?: boolean;
}
/**
 * RolloutCondition describes the state of a rollout at a certain point.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition {
    /**
     * Type of deployment condition.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    type?: string;
    /**
     * Phase of the condition, one of True, False, Unknown.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    status?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    lastUpdateTime?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    lastTransitionTime?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * The reason for the condition's last transition.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    reason?: string;
    /**
     * A human readable message indicating details about the transition.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep {
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
     */
    templates?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate>;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
     */
    duration?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
     */
    analyses?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    templateName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    clusterScope?: boolean;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    args?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    requiredForCompletion?: boolean;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    specRef?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    replicas?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    metadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    selector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    weight?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TemplateService}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    service?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TemplateService;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause {
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause
     */
    duration?: K8sIoApimachineryPkgUtilIntstrIntOrString;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    replicas?: number;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    selector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1PodTemplateSpec}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    template?: K8sIoApiCoreV1PodTemplateSpec;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    workloadRef?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    minReadySeconds?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RollbackWindowSpec}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    rollbackWindow?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RollbackWindowSpec;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    strategy?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    revisionHistoryLimit?: number;
    /**
     * Paused pauses the rollout at its current step.
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    paused?: boolean;
    /**
     * ProgressDeadlineSeconds The maximum time in seconds for a rollout to make progress before it is considered to be failed. Argo Rollouts will continue to process failed rollouts and a condition with a ProgressDeadlineExceeded reason will be surfaced in the rollout status. Note that progress will not be estimated during the time a rollout is paused. Defaults to 600s.
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    progressDeadlineSeconds?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    progressDeadlineAbort?: boolean;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    restartAt?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStrategy}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    analysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStrategy;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus {
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    abort?: boolean;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    pauseConditions?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition>;
    /**
     * ControllerPause indicates the controller has paused the rollout. It is set to true when the controller adds a pause condition. This field helps to discern the scenario where a rollout was resumed after being paused by the controller (e.g. via the plugin). In that situation, the pauseConditions would have been cleared , but controllerPause would still be set to true.
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    controllerPause?: boolean;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    abortedAt?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    currentPodHash?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    currentStepHash?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    replicas?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    updatedReplicas?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    readyReplicas?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    availableReplicas?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    currentStepIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    collisionCount?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    observedGeneration?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    conditions?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition>;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    canary?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    blueGreen?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    hPAReplicas?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    selector?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    stableRS?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    restartedAt?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * PromoteFull indicates if the rollout should perform a full promotion, skipping analysis and pauses.
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    promoteFull?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    phase?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    workloadObservedGeneration?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    alb?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    albs?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBStatus>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy
     */
    blueGreen?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy
     */
    canary?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    istio?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    nginx?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    alb?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    smi?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    ambassador?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    appMesh?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AppMeshTrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TraefikTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    traefik?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TraefikTrafficRouting;
    /**
     * ManagedRoutes A list of HTTP routes that Argo Rollouts manages, the order of this array also becomes the precedence in the upstream traffic router.
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MangedRoutes>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    managedRoutes?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1MangedRoutes>;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    apisix?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ApisixTrafficRouting;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    plugins?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RouteMatch
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RouteMatch {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RouteMatch
     */
    method?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RouteMatch
     */
    path?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch;
    /**
     * 
     * @type {{ [key: string]: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RouteMatch
     */
    headers?: { [key: string]: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch; };
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary
     */
    successful?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary
     */
    failed?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary
     */
    inconclusive?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RunSummary
     */
    error?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting
     */
    rootService?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting
     */
    trafficSplitName?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail
     */
    step?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ScopeDetail
     */
    end?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SecretKeyRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SecretKeyRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SecretKeyRef
     */
    name?: string;
    /**
     * Key is the key of the secret to select from.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SecretKeyRef
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
     */
    weight?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
     */
    replicas?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
     */
    matchTrafficWeight?: boolean;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetHeaderRoute
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetHeaderRoute {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetHeaderRoute
     */
    name?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1HeaderRoutingMatch>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetHeaderRoute
     */
    match?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1HeaderRoutingMatch>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetMirrorRoute
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetMirrorRoute {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetMirrorRoute
     */
    name?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RouteMatch>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetMirrorRoute
     */
    match?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RouteMatch>;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetMirrorRoute
     */
    percentage?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Sigv4Config
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Sigv4Config {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Sigv4Config
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Sigv4Config
     */
    profile?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Sigv4Config
     */
    roleArn?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SkyWalkingMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SkyWalkingMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SkyWalkingMetric
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SkyWalkingMetric
     */
    query?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SkyWalkingMetric
     */
    interval?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StickinessConfig
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StickinessConfig {
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StickinessConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StickinessConfig
     */
    durationSeconds?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch
     */
    exact?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch
     */
    prefix?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1StringMatch
     */
    regex?: string;
}
/**
 * TCPRoute holds the information on the virtual service's TCP routes that are desired to be matched for changing weights.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TCPRoute
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TCPRoute {
    /**
     * Port number of the TCP Route desired to be matched in the given Istio VirtualService.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TCPRoute
     */
    port?: string;
}
/**
 * TLSRoute holds the information on the virtual service's TLS/HTTPS routes that are desired to be matched for changing weights.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TLSRoute
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TLSRoute {
    /**
     * Port number of the TLS Route desired to be matched in the given Istio VirtualService.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TLSRoute
     */
    port?: string;
    /**
     * A list of all the SNI Hosts of the TLS Route desired to be matched in the given Istio VirtualService.
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TLSRoute
     */
    sniHosts?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TemplateService
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TemplateService {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TemplateService
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TraefikTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TraefikTrafficRouting {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TraefikTrafficRouting
     */
    weightedTraefikServiceName?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TrafficWeights
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TrafficWeights {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TrafficWeights
     */
    canary?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TrafficWeights
     */
    stable?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TrafficWeights
     */
    additional?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination>;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1TrafficWeights
     */
    verified?: boolean;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ValueFrom
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ValueFrom {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SecretKeyRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ValueFrom
     */
    secretKeyRef?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SecretKeyRef;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ValueFrom
     */
    fieldRef?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WavefrontMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WavefrontMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WavefrontMetric
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WavefrontMetric
     */
    query?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric
     */
    method?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric
     */
    url?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetricHeader>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric
     */
    headers?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetricHeader>;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric
     */
    body?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric
     */
    timeoutSeconds?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric
     */
    jsonPath?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric
     */
    insecure?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetric
     */
    jsonBody?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetricHeader
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetricHeader {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetricHeader
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WebMetricHeader
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination
     */
    weight?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination
     */
    serviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1WeightDestination
     */
    podTemplateHash?: string;
}
/**
 * 
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    typeUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<GoogleProtobufAny>}
     * @memberof GrpcGatewayRuntimeError
     */
    details?: Array<GoogleProtobufAny>;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeStreamError
 */
export interface GrpcGatewayRuntimeStreamError {
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    grpcCode?: number;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    httpCode?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    httpStatus?: string;
    /**
     * 
     * @type {Array<GoogleProtobufAny>}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    details?: Array<GoogleProtobufAny>;
}
/**
 * JobSpec describes how the job execution will look like.
 * @export
 * @interface K8sIoApiBatchV1JobSpec
 */
export interface K8sIoApiBatchV1JobSpec {
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    parallelism?: number;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    completions?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    activeDeadlineSeconds?: string;
    /**
     * 
     * @type {K8sIoApiBatchV1PodFailurePolicy}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    podFailurePolicy?: K8sIoApiBatchV1PodFailurePolicy;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    backoffLimit?: number;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    selector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    manualSelector?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1PodTemplateSpec}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    template?: K8sIoApiCoreV1PodTemplateSpec;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    ttlSecondsAfterFinished?: number;
    /**
     * CompletionMode specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`.  `NonIndexed` means that the Job is considered complete when there have been .spec.completions successfully completed Pods. Each Pod completion is homologous to each other.  `Indexed` means that the Pods of a Job get an associated completion index from 0 to (.spec.completions - 1), available in the annotation batch.kubernetes.io/job-completion-index. The Job is considered complete when there is one successfully completed Pod for each index. When value is `Indexed`, .spec.completions must be specified and `.spec.parallelism` must be less than or equal to 10^5. In addition, The Pod name takes the form `$(job-name)-$(index)-$(random-string)`, the Pod hostname takes the form `$(job-name)-$(index)`.  More completion modes can be added in the future. If the Job controller observes a mode that it doesn't recognize, which is possible during upgrades due to version skew, the controller skips updates for the Job. +optional
     * @type {string}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    completionMode?: string;
    /**
     * Suspend specifies whether the Job controller should create Pods or not. If a Job is created with suspend set to true, no Pods are created by the Job controller. If a Job is suspended after creation (i.e. the flag goes from false to true), the Job controller will delete all active Pods associated with this Job. Users must design their workload to gracefully handle this. Suspending a Job will reset the StartTime field of the Job, effectively resetting the ActiveDeadlineSeconds timer too. Defaults to false.  +optional
     * @type {boolean}
     * @memberof K8sIoApiBatchV1JobSpec
     */
    suspend?: boolean;
}
/**
 * PodFailurePolicy describes how failed pods influence the backoffLimit.
 * @export
 * @interface K8sIoApiBatchV1PodFailurePolicy
 */
export interface K8sIoApiBatchV1PodFailurePolicy {
    /**
     * 
     * @type {Array<K8sIoApiBatchV1PodFailurePolicyRule>}
     * @memberof K8sIoApiBatchV1PodFailurePolicy
     */
    rules?: Array<K8sIoApiBatchV1PodFailurePolicyRule>;
}
/**
 * PodFailurePolicyOnExitCodesRequirement describes the requirement for handling a failed pod based on its container exit codes. In particular, it lookups the .state.terminated.exitCode for each app container and init container status, represented by the .status.containerStatuses and .status.initContainerStatuses fields in the Pod status, respectively. Containers completed with success (exit code 0) are excluded from the requirement check.
 * @export
 * @interface K8sIoApiBatchV1PodFailurePolicyOnExitCodesRequirement
 */
export interface K8sIoApiBatchV1PodFailurePolicyOnExitCodesRequirement {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiBatchV1PodFailurePolicyOnExitCodesRequirement
     */
    containerName?: string;
    /**
     * Represents the relationship between the container exit code(s) and the specified values. Containers completed with success (exit code 0) are excluded from the requirement check. Possible values are: - In: the requirement is satisfied if at least one container exit code   (might be multiple if there are multiple containers not restricted   by the 'containerName' field) is in the set of specified values. - NotIn: the requirement is satisfied if at least one container exit code   (might be multiple if there are multiple containers not restricted   by the 'containerName' field) is not in the set of specified values. Additional values are considered to be added in the future. Clients should react to an unknown operator by assuming the requirement is not satisfied.
     * @type {string}
     * @memberof K8sIoApiBatchV1PodFailurePolicyOnExitCodesRequirement
     */
    operator?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof K8sIoApiBatchV1PodFailurePolicyOnExitCodesRequirement
     */
    values?: Array<number>;
}
/**
 * PodFailurePolicyOnPodConditionsPattern describes a pattern for matching an actual pod condition type.
 * @export
 * @interface K8sIoApiBatchV1PodFailurePolicyOnPodConditionsPattern
 */
export interface K8sIoApiBatchV1PodFailurePolicyOnPodConditionsPattern {
    /**
     * Specifies the required Pod condition type. To match a pod condition it is required that specified type equals the pod condition type.
     * @type {string}
     * @memberof K8sIoApiBatchV1PodFailurePolicyOnPodConditionsPattern
     */
    type?: string;
    /**
     * Specifies the required Pod condition status. To match a pod condition it is required that the specified status equals the pod condition status. Defaults to True.
     * @type {string}
     * @memberof K8sIoApiBatchV1PodFailurePolicyOnPodConditionsPattern
     */
    status?: string;
}
/**
 * PodFailurePolicyRule describes how a pod failure is handled when the requirements are met. One of OnExitCodes and onPodConditions, but not both, can be used in each rule.
 * @export
 * @interface K8sIoApiBatchV1PodFailurePolicyRule
 */
export interface K8sIoApiBatchV1PodFailurePolicyRule {
    /**
     * Specifies the action taken on a pod failure when the requirements are satisfied. Possible values are: - FailJob: indicates that the pod's job is marked as Failed and all   running pods are terminated. - Ignore: indicates that the counter towards the .backoffLimit is not   incremented and a replacement pod is created. - Count: indicates that the pod is handled in the default way - the   counter towards the .backoffLimit is incremented. Additional values are considered to be added in the future. Clients should react to an unknown action by skipping the rule.
     * @type {string}
     * @memberof K8sIoApiBatchV1PodFailurePolicyRule
     */
    action?: string;
    /**
     * 
     * @type {K8sIoApiBatchV1PodFailurePolicyOnExitCodesRequirement}
     * @memberof K8sIoApiBatchV1PodFailurePolicyRule
     */
    onExitCodes?: K8sIoApiBatchV1PodFailurePolicyOnExitCodesRequirement;
    /**
     * 
     * @type {Array<K8sIoApiBatchV1PodFailurePolicyOnPodConditionsPattern>}
     * @memberof K8sIoApiBatchV1PodFailurePolicyRule
     */
    onPodConditions?: Array<K8sIoApiBatchV1PodFailurePolicyOnPodConditionsPattern>;
}
/**
 * Represents a Persistent Disk resource in AWS.  An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
 */
export interface K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    volumeID?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    partition?: number;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Affinity is a group of affinity scheduling rules.
 * @export
 * @interface K8sIoApiCoreV1Affinity
 */
export interface K8sIoApiCoreV1Affinity {
    /**
     * 
     * @type {K8sIoApiCoreV1NodeAffinity}
     * @memberof K8sIoApiCoreV1Affinity
     */
    nodeAffinity?: K8sIoApiCoreV1NodeAffinity;
    /**
     * 
     * @type {K8sIoApiCoreV1PodAffinity}
     * @memberof K8sIoApiCoreV1Affinity
     */
    podAffinity?: K8sIoApiCoreV1PodAffinity;
    /**
     * 
     * @type {K8sIoApiCoreV1PodAntiAffinity}
     * @memberof K8sIoApiCoreV1Affinity
     */
    podAntiAffinity?: K8sIoApiCoreV1PodAntiAffinity;
}
/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * @export
 * @interface K8sIoApiCoreV1AzureDiskVolumeSource
 */
export interface K8sIoApiCoreV1AzureDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    diskName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    diskURI?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    cachingMode?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    kind?: string;
}
/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * @export
 * @interface K8sIoApiCoreV1AzureFileVolumeSource
 */
export interface K8sIoApiCoreV1AzureFileVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureFileVolumeSource
     */
    secretName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureFileVolumeSource
     */
    shareName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1AzureFileVolumeSource
     */
    readOnly?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1CSIVolumeSource
 */
export interface K8sIoApiCoreV1CSIVolumeSource {
    /**
     * driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
     * @type {string}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    driver?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    volumeAttributes?: { [key: string]: string; };
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    nodePublishSecretRef?: K8sIoApiCoreV1LocalObjectReference;
}
/**
 * Adds and removes POSIX capabilities from running containers.
 * @export
 * @interface K8sIoApiCoreV1Capabilities
 */
export interface K8sIoApiCoreV1Capabilities {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1Capabilities
     */
    add?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1Capabilities
     */
    drop?: Array<string>;
}
/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1CephFSVolumeSource
 */
export interface K8sIoApiCoreV1CephFSVolumeSource {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    monitors?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    secretFile?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1CinderVolumeSource
 */
export interface K8sIoApiCoreV1CinderVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CinderVolumeSource
     */
    volumeID?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CinderVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1CinderVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1CinderVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
}
/**
 * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.  The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
 * @export
 * @interface K8sIoApiCoreV1ConfigMapEnvSource
 */
export interface K8sIoApiCoreV1ConfigMapEnvSource {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ConfigMapEnvSource
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ConfigMapEnvSource
     */
    optional?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1ConfigMapKeySelector
 */
export interface K8sIoApiCoreV1ConfigMapKeySelector {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ConfigMapKeySelector
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * The key to select.
     * @type {string}
     * @memberof K8sIoApiCoreV1ConfigMapKeySelector
     */
    key?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ConfigMapKeySelector
     */
    optional?: boolean;
}
/**
 * Adapts a ConfigMap into a projected volume.  The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
 * @export
 * @interface K8sIoApiCoreV1ConfigMapProjection
 */
export interface K8sIoApiCoreV1ConfigMapProjection {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ConfigMapProjection
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1KeyToPath>}
     * @memberof K8sIoApiCoreV1ConfigMapProjection
     */
    items?: Array<K8sIoApiCoreV1KeyToPath>;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ConfigMapProjection
     */
    optional?: boolean;
}
/**
 * Adapts a ConfigMap into a volume.  The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1ConfigMapVolumeSource
 */
export interface K8sIoApiCoreV1ConfigMapVolumeSource {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ConfigMapVolumeSource
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1KeyToPath>}
     * @memberof K8sIoApiCoreV1ConfigMapVolumeSource
     */
    items?: Array<K8sIoApiCoreV1KeyToPath>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1ConfigMapVolumeSource
     */
    defaultMode?: number;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ConfigMapVolumeSource
     */
    optional?: boolean;
}
/**
 * A single application container that you want to run within a pod.
 * @export
 * @interface K8sIoApiCoreV1Container
 */
export interface K8sIoApiCoreV1Container {
    /**
     * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    image?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1Container
     */
    command?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1Container
     */
    args?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    workingDir?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1ContainerPort>}
     * @memberof K8sIoApiCoreV1Container
     */
    ports?: Array<K8sIoApiCoreV1ContainerPort>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EnvFromSource>}
     * @memberof K8sIoApiCoreV1Container
     */
    envFrom?: Array<K8sIoApiCoreV1EnvFromSource>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EnvVar>}
     * @memberof K8sIoApiCoreV1Container
     */
    env?: Array<K8sIoApiCoreV1EnvVar>;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceRequirements}
     * @memberof K8sIoApiCoreV1Container
     */
    resources?: K8sIoApiCoreV1ResourceRequirements;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeMount>}
     * @memberof K8sIoApiCoreV1Container
     */
    volumeMounts?: Array<K8sIoApiCoreV1VolumeMount>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeDevice>}
     * @memberof K8sIoApiCoreV1Container
     */
    volumeDevices?: Array<K8sIoApiCoreV1VolumeDevice>;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1Container
     */
    livenessProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1Container
     */
    readinessProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1Container
     */
    startupProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Lifecycle}
     * @memberof K8sIoApiCoreV1Container
     */
    lifecycle?: K8sIoApiCoreV1Lifecycle;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    terminationMessagePath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    terminationMessagePolicy?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    imagePullPolicy?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1SecurityContext}
     * @memberof K8sIoApiCoreV1Container
     */
    securityContext?: K8sIoApiCoreV1SecurityContext;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1Container
     */
    stdin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1Container
     */
    stdinOnce?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1Container
     */
    tty?: boolean;
}
/**
 * ContainerPort represents a network port in a single container.
 * @export
 * @interface K8sIoApiCoreV1ContainerPort
 */
export interface K8sIoApiCoreV1ContainerPort {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    hostPort?: number;
    /**
     * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
     * @type {number}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    containerPort?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    protocol?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    hostIP?: string;
}
/**
 * Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
 * @export
 * @interface K8sIoApiCoreV1DownwardAPIProjection
 */
export interface K8sIoApiCoreV1DownwardAPIProjection {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1DownwardAPIVolumeFile>}
     * @memberof K8sIoApiCoreV1DownwardAPIProjection
     */
    items?: Array<K8sIoApiCoreV1DownwardAPIVolumeFile>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1DownwardAPIVolumeFile
 */
export interface K8sIoApiCoreV1DownwardAPIVolumeFile {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeFile
     */
    path?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1ObjectFieldSelector}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeFile
     */
    fieldRef?: K8sIoApiCoreV1ObjectFieldSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceFieldSelector}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeFile
     */
    resourceFieldRef?: K8sIoApiCoreV1ResourceFieldSelector;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeFile
     */
    mode?: number;
}
/**
 * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1DownwardAPIVolumeSource
 */
export interface K8sIoApiCoreV1DownwardAPIVolumeSource {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1DownwardAPIVolumeFile>}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeSource
     */
    items?: Array<K8sIoApiCoreV1DownwardAPIVolumeFile>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeSource
     */
    defaultMode?: number;
}
/**
 * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1EmptyDirVolumeSource
 */
export interface K8sIoApiCoreV1EmptyDirVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EmptyDirVolumeSource
     */
    medium?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApiResourceQuantity}
     * @memberof K8sIoApiCoreV1EmptyDirVolumeSource
     */
    sizeLimit?: K8sIoApimachineryPkgApiResourceQuantity;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1EnvFromSource
 */
export interface K8sIoApiCoreV1EnvFromSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EnvFromSource
     */
    prefix?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1ConfigMapEnvSource}
     * @memberof K8sIoApiCoreV1EnvFromSource
     */
    configMapRef?: K8sIoApiCoreV1ConfigMapEnvSource;
    /**
     * 
     * @type {K8sIoApiCoreV1SecretEnvSource}
     * @memberof K8sIoApiCoreV1EnvFromSource
     */
    secretRef?: K8sIoApiCoreV1SecretEnvSource;
}
/**
 * EnvVar represents an environment variable present in a Container.
 * @export
 * @interface K8sIoApiCoreV1EnvVar
 */
export interface K8sIoApiCoreV1EnvVar {
    /**
     * Name of the environment variable. Must be a C_IDENTIFIER.
     * @type {string}
     * @memberof K8sIoApiCoreV1EnvVar
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EnvVar
     */
    value?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1EnvVarSource}
     * @memberof K8sIoApiCoreV1EnvVar
     */
    valueFrom?: K8sIoApiCoreV1EnvVarSource;
}
/**
 * EnvVarSource represents a source for the value of an EnvVar.
 * @export
 * @interface K8sIoApiCoreV1EnvVarSource
 */
export interface K8sIoApiCoreV1EnvVarSource {
    /**
     * 
     * @type {K8sIoApiCoreV1ObjectFieldSelector}
     * @memberof K8sIoApiCoreV1EnvVarSource
     */
    fieldRef?: K8sIoApiCoreV1ObjectFieldSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceFieldSelector}
     * @memberof K8sIoApiCoreV1EnvVarSource
     */
    resourceFieldRef?: K8sIoApiCoreV1ResourceFieldSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1ConfigMapKeySelector}
     * @memberof K8sIoApiCoreV1EnvVarSource
     */
    configMapKeyRef?: K8sIoApiCoreV1ConfigMapKeySelector;
    /**
     * 
     * @type {K8sIoApiCoreV1SecretKeySelector}
     * @memberof K8sIoApiCoreV1EnvVarSource
     */
    secretKeyRef?: K8sIoApiCoreV1SecretKeySelector;
}
/**
 * An EphemeralContainer is a temporary container that you may add to an existing Pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a Pod is removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.  To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral containers may not be removed or restarted.
 * @export
 * @interface K8sIoApiCoreV1EphemeralContainer
 */
export interface K8sIoApiCoreV1EphemeralContainer {
    /**
     * 
     * @type {K8sIoApiCoreV1EphemeralContainerCommon}
     * @memberof K8sIoApiCoreV1EphemeralContainer
     */
    ephemeralContainerCommon?: K8sIoApiCoreV1EphemeralContainerCommon;
    /**
     * If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the ephemeral container uses the namespaces configured in the Pod spec.  The container runtime must implement support for this feature. If the runtime does not support namespace targeting then the result of setting this field is undefined. +optional
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainer
     */
    targetContainerName?: string;
}
/**
 * EphemeralContainerCommon is a copy of all fields in Container to be inlined in EphemeralContainer. This separate type allows easy conversion from EphemeralContainer to Container and allows separate documentation for the fields of EphemeralContainer. When a new field is added to Container it must be added here as well.
 * @export
 * @interface K8sIoApiCoreV1EphemeralContainerCommon
 */
export interface K8sIoApiCoreV1EphemeralContainerCommon {
    /**
     * Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    image?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    command?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    args?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    workingDir?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1ContainerPort>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    ports?: Array<K8sIoApiCoreV1ContainerPort>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EnvFromSource>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    envFrom?: Array<K8sIoApiCoreV1EnvFromSource>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EnvVar>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    env?: Array<K8sIoApiCoreV1EnvVar>;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceRequirements}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    resources?: K8sIoApiCoreV1ResourceRequirements;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeMount>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    volumeMounts?: Array<K8sIoApiCoreV1VolumeMount>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeDevice>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    volumeDevices?: Array<K8sIoApiCoreV1VolumeDevice>;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    livenessProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    readinessProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    startupProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Lifecycle}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    lifecycle?: K8sIoApiCoreV1Lifecycle;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    terminationMessagePath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    terminationMessagePolicy?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    imagePullPolicy?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1SecurityContext}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    securityContext?: K8sIoApiCoreV1SecurityContext;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    stdin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    stdinOnce?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    tty?: boolean;
}
/**
 * Represents an ephemeral volume that is handled by a normal storage driver.
 * @export
 * @interface K8sIoApiCoreV1EphemeralVolumeSource
 */
export interface K8sIoApiCoreV1EphemeralVolumeSource {
    /**
     * 
     * @type {K8sIoApiCoreV1PersistentVolumeClaimTemplate}
     * @memberof K8sIoApiCoreV1EphemeralVolumeSource
     */
    volumeClaimTemplate?: K8sIoApiCoreV1PersistentVolumeClaimTemplate;
}
/**
 * ExecAction describes a \"run in container\" action.
 * @export
 * @interface K8sIoApiCoreV1ExecAction
 */
export interface K8sIoApiCoreV1ExecAction {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1ExecAction
     */
    command?: Array<string>;
}
/**
 * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1FCVolumeSource
 */
export interface K8sIoApiCoreV1FCVolumeSource {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    targetWWNs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    lun?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    wwids?: Array<string>;
}
/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 * @export
 * @interface K8sIoApiCoreV1FlexVolumeSource
 */
export interface K8sIoApiCoreV1FlexVolumeSource {
    /**
     * driver is the name of the driver to use for this volume.
     * @type {string}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    driver?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    options?: { [key: string]: string; };
}
/**
 * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1FlockerVolumeSource
 */
export interface K8sIoApiCoreV1FlockerVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1FlockerVolumeSource
     */
    datasetName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1FlockerVolumeSource
     */
    datasetUUID?: string;
}
/**
 * Represents a Persistent Disk resource in Google Compute Engine.  A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1GCEPersistentDiskVolumeSource
 */
export interface K8sIoApiCoreV1GCEPersistentDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GCEPersistentDiskVolumeSource
     */
    pdName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GCEPersistentDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1GCEPersistentDiskVolumeSource
     */
    partition?: number;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1GCEPersistentDiskVolumeSource
     */
    readOnly?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1GRPCAction
 */
export interface K8sIoApiCoreV1GRPCAction {
    /**
     * Port number of the gRPC service. Number must be in the range 1 to 65535.
     * @type {number}
     * @memberof K8sIoApiCoreV1GRPCAction
     */
    port?: number;
    /**
     * Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).  If this is not specified, the default behavior is defined by gRPC. +optional +default=\"\"
     * @type {string}
     * @memberof K8sIoApiCoreV1GRPCAction
     */
    service?: string;
}
/**
 * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.  DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 * @export
 * @interface K8sIoApiCoreV1GitRepoVolumeSource
 */
export interface K8sIoApiCoreV1GitRepoVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GitRepoVolumeSource
     */
    repository?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GitRepoVolumeSource
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GitRepoVolumeSource
     */
    directory?: string;
}
/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1GlusterfsVolumeSource
 */
export interface K8sIoApiCoreV1GlusterfsVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GlusterfsVolumeSource
     */
    endpoints?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GlusterfsVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1GlusterfsVolumeSource
     */
    readOnly?: boolean;
}
/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 * @export
 * @interface K8sIoApiCoreV1HTTPGetAction
 */
export interface K8sIoApiCoreV1HTTPGetAction {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    path?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    port?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    host?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    scheme?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1HTTPHeader>}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    httpHeaders?: Array<K8sIoApiCoreV1HTTPHeader>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1HTTPHeader
 */
export interface K8sIoApiCoreV1HTTPHeader {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPHeader
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPHeader
     */
    value?: string;
}
/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 * @export
 * @interface K8sIoApiCoreV1HostAlias
 */
export interface K8sIoApiCoreV1HostAlias {
    /**
     * IP address of the host file entry.
     * @type {string}
     * @memberof K8sIoApiCoreV1HostAlias
     */
    ip?: string;
    /**
     * Hostnames for the above IP address.
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1HostAlias
     */
    hostnames?: Array<string>;
}
/**
 * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1HostPathVolumeSource
 */
export interface K8sIoApiCoreV1HostPathVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HostPathVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HostPathVolumeSource
     */
    type?: string;
}
/**
 * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1ISCSIVolumeSource
 */
export interface K8sIoApiCoreV1ISCSIVolumeSource {
    /**
     * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    targetPortal?: string;
    /**
     * iqn is the target iSCSI Qualified Name.
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    iqn?: string;
    /**
     * lun represents iSCSI Target Lun number.
     * @type {number}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    lun?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    iscsiInterface?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    portals?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    chapAuthDiscovery?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    chapAuthSession?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    initiatorName?: string;
}
/**
 * Maps a string key to a path within a volume.
 * @export
 * @interface K8sIoApiCoreV1KeyToPath
 */
export interface K8sIoApiCoreV1KeyToPath {
    /**
     * key is the key to project.
     * @type {string}
     * @memberof K8sIoApiCoreV1KeyToPath
     */
    key?: string;
    /**
     * path is the relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
     * @type {string}
     * @memberof K8sIoApiCoreV1KeyToPath
     */
    path?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1KeyToPath
     */
    mode?: number;
}
/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
 * @export
 * @interface K8sIoApiCoreV1Lifecycle
 */
export interface K8sIoApiCoreV1Lifecycle {
    /**
     * 
     * @type {K8sIoApiCoreV1LifecycleHandler}
     * @memberof K8sIoApiCoreV1Lifecycle
     */
    postStart?: K8sIoApiCoreV1LifecycleHandler;
    /**
     * 
     * @type {K8sIoApiCoreV1LifecycleHandler}
     * @memberof K8sIoApiCoreV1Lifecycle
     */
    preStop?: K8sIoApiCoreV1LifecycleHandler;
}
/**
 * LifecycleHandler defines a specific action that should be taken in a lifecycle hook. One and only one of the fields, except TCPSocket must be specified.
 * @export
 * @interface K8sIoApiCoreV1LifecycleHandler
 */
export interface K8sIoApiCoreV1LifecycleHandler {
    /**
     * 
     * @type {K8sIoApiCoreV1ExecAction}
     * @memberof K8sIoApiCoreV1LifecycleHandler
     */
    exec?: K8sIoApiCoreV1ExecAction;
    /**
     * 
     * @type {K8sIoApiCoreV1HTTPGetAction}
     * @memberof K8sIoApiCoreV1LifecycleHandler
     */
    httpGet?: K8sIoApiCoreV1HTTPGetAction;
    /**
     * 
     * @type {K8sIoApiCoreV1TCPSocketAction}
     * @memberof K8sIoApiCoreV1LifecycleHandler
     */
    tcpSocket?: K8sIoApiCoreV1TCPSocketAction;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1LocalObjectReference
 */
export interface K8sIoApiCoreV1LocalObjectReference {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1LocalObjectReference
     */
    name?: string;
}
/**
 * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1NFSVolumeSource
 */
export interface K8sIoApiCoreV1NFSVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1NFSVolumeSource
     */
    server?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1NFSVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1NFSVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Node affinity is a group of node affinity scheduling rules.
 * @export
 * @interface K8sIoApiCoreV1NodeAffinity
 */
export interface K8sIoApiCoreV1NodeAffinity {
    /**
     * 
     * @type {K8sIoApiCoreV1NodeSelector}
     * @memberof K8sIoApiCoreV1NodeAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: K8sIoApiCoreV1NodeSelector;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PreferredSchedulingTerm>}
     * @memberof K8sIoApiCoreV1NodeAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1PreferredSchedulingTerm>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1NodeSelector
 */
export interface K8sIoApiCoreV1NodeSelector {
    /**
     * Required. A list of node selector terms. The terms are ORed.
     * @type {Array<K8sIoApiCoreV1NodeSelectorTerm>}
     * @memberof K8sIoApiCoreV1NodeSelector
     */
    nodeSelectorTerms?: Array<K8sIoApiCoreV1NodeSelectorTerm>;
}
/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 * @export
 * @interface K8sIoApiCoreV1NodeSelectorRequirement
 */
export interface K8sIoApiCoreV1NodeSelectorRequirement {
    /**
     * The label key that the selector applies to.
     * @type {string}
     * @memberof K8sIoApiCoreV1NodeSelectorRequirement
     */
    key?: string;
    /**
     * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
     * @type {string}
     * @memberof K8sIoApiCoreV1NodeSelectorRequirement
     */
    operator?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1NodeSelectorRequirement
     */
    values?: Array<string>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1NodeSelectorTerm
 */
export interface K8sIoApiCoreV1NodeSelectorTerm {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1NodeSelectorRequirement>}
     * @memberof K8sIoApiCoreV1NodeSelectorTerm
     */
    matchExpressions?: Array<K8sIoApiCoreV1NodeSelectorRequirement>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1NodeSelectorRequirement>}
     * @memberof K8sIoApiCoreV1NodeSelectorTerm
     */
    matchFields?: Array<K8sIoApiCoreV1NodeSelectorRequirement>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1ObjectFieldSelector
 */
export interface K8sIoApiCoreV1ObjectFieldSelector {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ObjectFieldSelector
     */
    apiVersion?: string;
    /**
     * Path of the field to select in the specified API version.
     * @type {string}
     * @memberof K8sIoApiCoreV1ObjectFieldSelector
     */
    fieldPath?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1PersistentVolumeClaimSpec
 */
export interface K8sIoApiCoreV1PersistentVolumeClaimSpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    accessModes?: Array<string>;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    selector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceRequirements}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    resources?: K8sIoApiCoreV1ResourceRequirements;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    volumeName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    storageClassName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    volumeMode?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1TypedLocalObjectReference}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    dataSource?: K8sIoApiCoreV1TypedLocalObjectReference;
    /**
     * 
     * @type {K8sIoApiCoreV1TypedLocalObjectReference}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    dataSourceRef?: K8sIoApiCoreV1TypedLocalObjectReference;
}
/**
 * PersistentVolumeClaimTemplate is used to produce PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
 * @export
 * @interface K8sIoApiCoreV1PersistentVolumeClaimTemplate
 */
export interface K8sIoApiCoreV1PersistentVolumeClaimTemplate {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimTemplate
     */
    metadata?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {K8sIoApiCoreV1PersistentVolumeClaimSpec}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimTemplate
     */
    spec?: K8sIoApiCoreV1PersistentVolumeClaimSpec;
}
/**
 * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
 * @export
 * @interface K8sIoApiCoreV1PersistentVolumeClaimVolumeSource
 */
export interface K8sIoApiCoreV1PersistentVolumeClaimVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimVolumeSource
     */
    claimName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Represents a Photon Controller persistent disk resource.
 * @export
 * @interface K8sIoApiCoreV1PhotonPersistentDiskVolumeSource
 */
export interface K8sIoApiCoreV1PhotonPersistentDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PhotonPersistentDiskVolumeSource
     */
    pdID?: string;
    /**
     * fsType is the filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.
     * @type {string}
     * @memberof K8sIoApiCoreV1PhotonPersistentDiskVolumeSource
     */
    fsType?: string;
}
/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 * @export
 * @interface K8sIoApiCoreV1PodAffinity
 */
export interface K8sIoApiCoreV1PodAffinity {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PodAffinityTerm>}
     * @memberof K8sIoApiCoreV1PodAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1PodAffinityTerm>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1WeightedPodAffinityTerm>}
     * @memberof K8sIoApiCoreV1PodAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1WeightedPodAffinityTerm>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1PodAffinityTerm
 */
export interface K8sIoApiCoreV1PodAffinityTerm {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof K8sIoApiCoreV1PodAffinityTerm
     */
    labelSelector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PodAffinityTerm
     */
    namespaces?: Array<string>;
    /**
     * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
     * @type {string}
     * @memberof K8sIoApiCoreV1PodAffinityTerm
     */
    topologyKey?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof K8sIoApiCoreV1PodAffinityTerm
     */
    namespaceSelector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
}
/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 * @export
 * @interface K8sIoApiCoreV1PodAntiAffinity
 */
export interface K8sIoApiCoreV1PodAntiAffinity {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PodAffinityTerm>}
     * @memberof K8sIoApiCoreV1PodAntiAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1PodAffinityTerm>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1WeightedPodAffinityTerm>}
     * @memberof K8sIoApiCoreV1PodAntiAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1WeightedPodAffinityTerm>;
}
/**
 * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
 * @export
 * @interface K8sIoApiCoreV1PodDNSConfig
 */
export interface K8sIoApiCoreV1PodDNSConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PodDNSConfig
     */
    nameservers?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PodDNSConfig
     */
    searches?: Array<string>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PodDNSConfigOption>}
     * @memberof K8sIoApiCoreV1PodDNSConfig
     */
    options?: Array<K8sIoApiCoreV1PodDNSConfigOption>;
}
/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 * @export
 * @interface K8sIoApiCoreV1PodDNSConfigOption
 */
export interface K8sIoApiCoreV1PodDNSConfigOption {
    /**
     * Required.
     * @type {string}
     * @memberof K8sIoApiCoreV1PodDNSConfigOption
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodDNSConfigOption
     */
    value?: string;
}
/**
 * PodOS defines the OS parameters of a pod.
 * @export
 * @interface K8sIoApiCoreV1PodOS
 */
export interface K8sIoApiCoreV1PodOS {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodOS
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1PodReadinessGate
 */
export interface K8sIoApiCoreV1PodReadinessGate {
    /**
     * ConditionType refers to a condition in the pod's condition list with matching type.
     * @type {string}
     * @memberof K8sIoApiCoreV1PodReadinessGate
     */
    conditionType?: string;
}
/**
 * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
 * @export
 * @interface K8sIoApiCoreV1PodSecurityContext
 */
export interface K8sIoApiCoreV1PodSecurityContext {
    /**
     * 
     * @type {K8sIoApiCoreV1SELinuxOptions}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    seLinuxOptions?: K8sIoApiCoreV1SELinuxOptions;
    /**
     * 
     * @type {K8sIoApiCoreV1WindowsSecurityContextOptions}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    windowsOptions?: K8sIoApiCoreV1WindowsSecurityContextOptions;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    runAsUser?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    runAsGroup?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    runAsNonRoot?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    supplementalGroups?: Array<string>;
    /**
     * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----  If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows. +optional
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    fsGroup?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Sysctl>}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    sysctls?: Array<K8sIoApiCoreV1Sysctl>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    fsGroupChangePolicy?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1SeccompProfile}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    seccompProfile?: K8sIoApiCoreV1SeccompProfile;
}
/**
 * PodSpec is a description of a pod.
 * @export
 * @interface K8sIoApiCoreV1PodSpec
 */
export interface K8sIoApiCoreV1PodSpec {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Volume>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    volumes?: Array<K8sIoApiCoreV1Volume>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Container>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    initContainers?: Array<K8sIoApiCoreV1Container>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Container>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    containers?: Array<K8sIoApiCoreV1Container>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EphemeralContainer>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    ephemeralContainers?: Array<K8sIoApiCoreV1EphemeralContainer>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    restartPolicy?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    terminationGracePeriodSeconds?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    activeDeadlineSeconds?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    dnsPolicy?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    nodeSelector?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    serviceAccountName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    serviceAccount?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    automountServiceAccountToken?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    nodeName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostNetwork?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostPID?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostIPC?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    shareProcessNamespace?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1PodSecurityContext}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    securityContext?: K8sIoApiCoreV1PodSecurityContext;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1LocalObjectReference>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    imagePullSecrets?: Array<K8sIoApiCoreV1LocalObjectReference>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostname?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    subdomain?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1Affinity}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    affinity?: K8sIoApiCoreV1Affinity;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    schedulerName?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Toleration>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    tolerations?: Array<K8sIoApiCoreV1Toleration>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1HostAlias>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostAliases?: Array<K8sIoApiCoreV1HostAlias>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    priorityClassName?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    priority?: number;
    /**
     * 
     * @type {K8sIoApiCoreV1PodDNSConfig}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    dnsConfig?: K8sIoApiCoreV1PodDNSConfig;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PodReadinessGate>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    readinessGates?: Array<K8sIoApiCoreV1PodReadinessGate>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    runtimeClassName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    enableServiceLinks?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    preemptionPolicy?: string;
    /**
     * 
     * @type {{ [key: string]: K8sIoApimachineryPkgApiResourceQuantity; }}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    overhead?: { [key: string]: K8sIoApimachineryPkgApiResourceQuantity; };
    /**
     * 
     * @type {Array<K8sIoApiCoreV1TopologySpreadConstraint>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    topologySpreadConstraints?: Array<K8sIoApiCoreV1TopologySpreadConstraint>;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    setHostnameAsFQDN?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1PodOS}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    os?: K8sIoApiCoreV1PodOS;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostUsers?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1PodTemplateSpec
 */
export interface K8sIoApiCoreV1PodTemplateSpec {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof K8sIoApiCoreV1PodTemplateSpec
     */
    metadata?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {K8sIoApiCoreV1PodSpec}
     * @memberof K8sIoApiCoreV1PodTemplateSpec
     */
    spec?: K8sIoApiCoreV1PodSpec;
}
/**
 * PortworxVolumeSource represents a Portworx volume resource.
 * @export
 * @interface K8sIoApiCoreV1PortworxVolumeSource
 */
export interface K8sIoApiCoreV1PortworxVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PortworxVolumeSource
     */
    volumeID?: string;
    /**
     * fSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\". Implicitly inferred to be \"ext4\" if unspecified.
     * @type {string}
     * @memberof K8sIoApiCoreV1PortworxVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PortworxVolumeSource
     */
    readOnly?: boolean;
}
/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 * @export
 * @interface K8sIoApiCoreV1PreferredSchedulingTerm
 */
export interface K8sIoApiCoreV1PreferredSchedulingTerm {
    /**
     * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
     * @type {number}
     * @memberof K8sIoApiCoreV1PreferredSchedulingTerm
     */
    weight?: number;
    /**
     * 
     * @type {K8sIoApiCoreV1NodeSelectorTerm}
     * @memberof K8sIoApiCoreV1PreferredSchedulingTerm
     */
    preference?: K8sIoApiCoreV1NodeSelectorTerm;
}
/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 * @export
 * @interface K8sIoApiCoreV1Probe
 */
export interface K8sIoApiCoreV1Probe {
    /**
     * 
     * @type {K8sIoApiCoreV1ProbeHandler}
     * @memberof K8sIoApiCoreV1Probe
     */
    handler?: K8sIoApiCoreV1ProbeHandler;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    initialDelaySeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    timeoutSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    periodSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    successThreshold?: number;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    failureThreshold?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Probe
     */
    terminationGracePeriodSeconds?: string;
}
/**
 * ProbeHandler defines a specific action that should be taken in a probe. One and only one of the fields must be specified.
 * @export
 * @interface K8sIoApiCoreV1ProbeHandler
 */
export interface K8sIoApiCoreV1ProbeHandler {
    /**
     * 
     * @type {K8sIoApiCoreV1ExecAction}
     * @memberof K8sIoApiCoreV1ProbeHandler
     */
    exec?: K8sIoApiCoreV1ExecAction;
    /**
     * 
     * @type {K8sIoApiCoreV1HTTPGetAction}
     * @memberof K8sIoApiCoreV1ProbeHandler
     */
    httpGet?: K8sIoApiCoreV1HTTPGetAction;
    /**
     * 
     * @type {K8sIoApiCoreV1TCPSocketAction}
     * @memberof K8sIoApiCoreV1ProbeHandler
     */
    tcpSocket?: K8sIoApiCoreV1TCPSocketAction;
    /**
     * 
     * @type {K8sIoApiCoreV1GRPCAction}
     * @memberof K8sIoApiCoreV1ProbeHandler
     */
    grpc?: K8sIoApiCoreV1GRPCAction;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1ProjectedVolumeSource
 */
export interface K8sIoApiCoreV1ProjectedVolumeSource {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeProjection>}
     * @memberof K8sIoApiCoreV1ProjectedVolumeSource
     */
    sources?: Array<K8sIoApiCoreV1VolumeProjection>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1ProjectedVolumeSource
     */
    defaultMode?: number;
}
/**
 * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1QuobyteVolumeSource
 */
export interface K8sIoApiCoreV1QuobyteVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    registry?: string;
    /**
     * volume is a string that references an already created Quobyte volume by name.
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    volume?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    group?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    tenant?: string;
}
/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1RBDVolumeSource
 */
export interface K8sIoApiCoreV1RBDVolumeSource {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    monitors?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    keyring?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    readOnly?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1ResourceFieldSelector
 */
export interface K8sIoApiCoreV1ResourceFieldSelector {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ResourceFieldSelector
     */
    containerName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ResourceFieldSelector
     */
    resource?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApiResourceQuantity}
     * @memberof K8sIoApiCoreV1ResourceFieldSelector
     */
    divisor?: K8sIoApimachineryPkgApiResourceQuantity;
}
/**
 * ResourceRequirements describes the compute resource requirements.
 * @export
 * @interface K8sIoApiCoreV1ResourceRequirements
 */
export interface K8sIoApiCoreV1ResourceRequirements {
    /**
     * 
     * @type {{ [key: string]: K8sIoApimachineryPkgApiResourceQuantity; }}
     * @memberof K8sIoApiCoreV1ResourceRequirements
     */
    limits?: { [key: string]: K8sIoApimachineryPkgApiResourceQuantity; };
    /**
     * 
     * @type {{ [key: string]: K8sIoApimachineryPkgApiResourceQuantity; }}
     * @memberof K8sIoApiCoreV1ResourceRequirements
     */
    requests?: { [key: string]: K8sIoApimachineryPkgApiResourceQuantity; };
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1SELinuxOptions
 */
export interface K8sIoApiCoreV1SELinuxOptions {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SELinuxOptions
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SELinuxOptions
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SELinuxOptions
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SELinuxOptions
     */
    level?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1ScaleIOVolumeSource
 */
export interface K8sIoApiCoreV1ScaleIOVolumeSource {
    /**
     * gateway is the host address of the ScaleIO API Gateway.
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    gateway?: string;
    /**
     * system is the name of the storage system as configured in ScaleIO.
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    system?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    sslEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    protectionDomain?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    storagePool?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    storageMode?: string;
    /**
     * volumeName is the name of a volume already created in the ScaleIO system that is associated with this volume source.
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    volumeName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    readOnly?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1SeccompProfile
 */
export interface K8sIoApiCoreV1SeccompProfile {
    /**
     * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied. +unionDiscriminator
     * @type {string}
     * @memberof K8sIoApiCoreV1SeccompProfile
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SeccompProfile
     */
    localhostProfile?: string;
}
/**
 * SecretEnvSource selects a Secret to populate the environment variables with.  The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
 * @export
 * @interface K8sIoApiCoreV1SecretEnvSource
 */
export interface K8sIoApiCoreV1SecretEnvSource {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1SecretEnvSource
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecretEnvSource
     */
    optional?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1SecretKeySelector
 */
export interface K8sIoApiCoreV1SecretKeySelector {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1SecretKeySelector
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * The key of the secret to select from.  Must be a valid secret key.
     * @type {string}
     * @memberof K8sIoApiCoreV1SecretKeySelector
     */
    key?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecretKeySelector
     */
    optional?: boolean;
}
/**
 * Adapts a secret into a projected volume.  The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
 * @export
 * @interface K8sIoApiCoreV1SecretProjection
 */
export interface K8sIoApiCoreV1SecretProjection {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1SecretProjection
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1KeyToPath>}
     * @memberof K8sIoApiCoreV1SecretProjection
     */
    items?: Array<K8sIoApiCoreV1KeyToPath>;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecretProjection
     */
    optional?: boolean;
}
/**
 * Adapts a Secret into a volume.  The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1SecretVolumeSource
 */
export interface K8sIoApiCoreV1SecretVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SecretVolumeSource
     */
    secretName?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1KeyToPath>}
     * @memberof K8sIoApiCoreV1SecretVolumeSource
     */
    items?: Array<K8sIoApiCoreV1KeyToPath>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1SecretVolumeSource
     */
    defaultMode?: number;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecretVolumeSource
     */
    optional?: boolean;
}
/**
 * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
 * @export
 * @interface K8sIoApiCoreV1SecurityContext
 */
export interface K8sIoApiCoreV1SecurityContext {
    /**
     * 
     * @type {K8sIoApiCoreV1Capabilities}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    capabilities?: K8sIoApiCoreV1Capabilities;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    privileged?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1SELinuxOptions}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    seLinuxOptions?: K8sIoApiCoreV1SELinuxOptions;
    /**
     * 
     * @type {K8sIoApiCoreV1WindowsSecurityContextOptions}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    windowsOptions?: K8sIoApiCoreV1WindowsSecurityContextOptions;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    runAsUser?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    runAsGroup?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    runAsNonRoot?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    readOnlyRootFilesystem?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    allowPrivilegeEscalation?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    procMount?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1SeccompProfile}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    seccompProfile?: K8sIoApiCoreV1SeccompProfile;
}
/**
 * ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
 * @export
 * @interface K8sIoApiCoreV1ServiceAccountTokenProjection
 */
export interface K8sIoApiCoreV1ServiceAccountTokenProjection {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ServiceAccountTokenProjection
     */
    audience?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ServiceAccountTokenProjection
     */
    expirationSeconds?: string;
    /**
     * path is the path relative to the mount point of the file to project the token into.
     * @type {string}
     * @memberof K8sIoApiCoreV1ServiceAccountTokenProjection
     */
    path?: string;
}
/**
 * Represents a StorageOS persistent volume resource.
 * @export
 * @interface K8sIoApiCoreV1StorageOSVolumeSource
 */
export interface K8sIoApiCoreV1StorageOSVolumeSource {
    /**
     * volumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
     * @type {string}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    volumeName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    volumeNamespace?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1Sysctl
 */
export interface K8sIoApiCoreV1Sysctl {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Sysctl
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Sysctl
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1TCPSocketAction
 */
export interface K8sIoApiCoreV1TCPSocketAction {
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof K8sIoApiCoreV1TCPSocketAction
     */
    port?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1TCPSocketAction
     */
    host?: string;
}
/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 * @export
 * @interface K8sIoApiCoreV1Toleration
 */
export interface K8sIoApiCoreV1Toleration {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    operator?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    effect?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    tolerationSeconds?: string;
}
/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 * @export
 * @interface K8sIoApiCoreV1TopologySpreadConstraint
 */
export interface K8sIoApiCoreV1TopologySpreadConstraint {
    /**
     * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. The global minimum is the minimum number of matching pods in an eligible domain or zero if the number of eligible domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 2/2/1: In this case, the global minimum is 1. +-------+-------+-------+ | zone1 | zone2 | zone3 | +-------+-------+-------+ |  P P  |  P P  |   P   | +-------+-------+-------+ - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
     * @type {number}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    maxSkew?: number;
    /**
     * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a \"bucket\", and try to put balanced number of pods into each bucket. We define a domain as a particular instance of a topology. Also, we define an eligible domain as a domain whose nodes meet the requirements of nodeAffinityPolicy and nodeTaintsPolicy. e.g. If TopologyKey is \"kubernetes.io/hostname\", each Node is a domain of that topology. And, if TopologyKey is \"topology.kubernetes.io/zone\", each zone is a domain of that topology. It's a required field.
     * @type {string}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    topologyKey?: string;
    /**
     * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location,   but giving higher precedence to topologies that would help reduce the   skew. A constraint is considered \"Unsatisfiable\" for an incoming pod if and only if every possible node assignment for that pod would violate \"MaxSkew\" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: +-------+-------+-------+ | zone1 | zone2 | zone3 | +-------+-------+-------+ | P P P |   P   |   P   | +-------+-------+-------+ If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
     * @type {string}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    whenUnsatisfiable?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    labelSelector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
    /**
     * MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats \"global minimum\" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.  For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: +-------+-------+-------+ | zone1 | zone2 | zone3 | +-------+-------+-------+ |  P P  |  P P  |  P P  | +-------+-------+-------+ The number of domains is less than 5(MinDomains), so \"global minimum\" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.  This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default). +optional
     * @type {number}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    minDomains?: number;
    /**
     * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.  If this value is nil, the behavior is equivalent to the Honor policy. This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag. +optional
     * @type {string}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    nodeAffinityPolicy?: string;
    /**
     * NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.  If this value is nil, the behavior is equivalent to the Ignore policy. This is a alpha-level feature enabled by the NodeInclusionPolicyInPodTopologySpread feature flag. +optional
     * @type {string}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    nodeTaintsPolicy?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    matchLabelKeys?: Array<string>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1TypedLocalObjectReference
 */
export interface K8sIoApiCoreV1TypedLocalObjectReference {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1TypedLocalObjectReference
     */
    apiGroup?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1TypedLocalObjectReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1TypedLocalObjectReference
     */
    name?: string;
}
/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 * @export
 * @interface K8sIoApiCoreV1Volume
 */
export interface K8sIoApiCoreV1Volume {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Volume
     */
    name?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1VolumeSource}
     * @memberof K8sIoApiCoreV1Volume
     */
    volumeSource?: K8sIoApiCoreV1VolumeSource;
}
/**
 * volumeDevice describes a mapping of a raw block device within a container.
 * @export
 * @interface K8sIoApiCoreV1VolumeDevice
 */
export interface K8sIoApiCoreV1VolumeDevice {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeDevice
     */
    name?: string;
    /**
     * devicePath is the path inside of the container that the device will be mapped to.
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeDevice
     */
    devicePath?: string;
}
/**
 * VolumeMount describes a mounting of a Volume within a container.
 * @export
 * @interface K8sIoApiCoreV1VolumeMount
 */
export interface K8sIoApiCoreV1VolumeMount {
    /**
     * This must match the Name of a Volume.
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    readOnly?: boolean;
    /**
     * Path within the container at which the volume should be mounted.  Must not contain ':'.
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    mountPath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    subPath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    mountPropagation?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    subPathExpr?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1VolumeProjection
 */
export interface K8sIoApiCoreV1VolumeProjection {
    /**
     * 
     * @type {K8sIoApiCoreV1SecretProjection}
     * @memberof K8sIoApiCoreV1VolumeProjection
     */
    secret?: K8sIoApiCoreV1SecretProjection;
    /**
     * 
     * @type {K8sIoApiCoreV1DownwardAPIProjection}
     * @memberof K8sIoApiCoreV1VolumeProjection
     */
    downwardAPI?: K8sIoApiCoreV1DownwardAPIProjection;
    /**
     * 
     * @type {K8sIoApiCoreV1ConfigMapProjection}
     * @memberof K8sIoApiCoreV1VolumeProjection
     */
    configMap?: K8sIoApiCoreV1ConfigMapProjection;
    /**
     * 
     * @type {K8sIoApiCoreV1ServiceAccountTokenProjection}
     * @memberof K8sIoApiCoreV1VolumeProjection
     */
    serviceAccountToken?: K8sIoApiCoreV1ServiceAccountTokenProjection;
}
/**
 * Represents the source of a volume to mount. Only one of its members may be specified.
 * @export
 * @interface K8sIoApiCoreV1VolumeSource
 */
export interface K8sIoApiCoreV1VolumeSource {
    /**
     * 
     * @type {K8sIoApiCoreV1HostPathVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    hostPath?: K8sIoApiCoreV1HostPathVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1EmptyDirVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    emptyDir?: K8sIoApiCoreV1EmptyDirVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1GCEPersistentDiskVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    gcePersistentDisk?: K8sIoApiCoreV1GCEPersistentDiskVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    awsElasticBlockStore?: K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1GitRepoVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    gitRepo?: K8sIoApiCoreV1GitRepoVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1SecretVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    secret?: K8sIoApiCoreV1SecretVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1NFSVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    nfs?: K8sIoApiCoreV1NFSVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1ISCSIVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    iscsi?: K8sIoApiCoreV1ISCSIVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1GlusterfsVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    glusterfs?: K8sIoApiCoreV1GlusterfsVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1PersistentVolumeClaimVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    persistentVolumeClaim?: K8sIoApiCoreV1PersistentVolumeClaimVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1RBDVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    rbd?: K8sIoApiCoreV1RBDVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1FlexVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    flexVolume?: K8sIoApiCoreV1FlexVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1CinderVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    cinder?: K8sIoApiCoreV1CinderVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1CephFSVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    cephfs?: K8sIoApiCoreV1CephFSVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1FlockerVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    flocker?: K8sIoApiCoreV1FlockerVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1DownwardAPIVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    downwardAPI?: K8sIoApiCoreV1DownwardAPIVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1FCVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    fc?: K8sIoApiCoreV1FCVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1AzureFileVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    azureFile?: K8sIoApiCoreV1AzureFileVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1ConfigMapVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    configMap?: K8sIoApiCoreV1ConfigMapVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1VsphereVirtualDiskVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    vsphereVolume?: K8sIoApiCoreV1VsphereVirtualDiskVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1QuobyteVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    quobyte?: K8sIoApiCoreV1QuobyteVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1AzureDiskVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    azureDisk?: K8sIoApiCoreV1AzureDiskVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1PhotonPersistentDiskVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    photonPersistentDisk?: K8sIoApiCoreV1PhotonPersistentDiskVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1ProjectedVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    projected?: K8sIoApiCoreV1ProjectedVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1PortworxVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    portworxVolume?: K8sIoApiCoreV1PortworxVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1ScaleIOVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    scaleIO?: K8sIoApiCoreV1ScaleIOVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1StorageOSVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    storageos?: K8sIoApiCoreV1StorageOSVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1CSIVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    csi?: K8sIoApiCoreV1CSIVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1EphemeralVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    ephemeral?: K8sIoApiCoreV1EphemeralVolumeSource;
}
/**
 * Represents a vSphere volume resource.
 * @export
 * @interface K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
 */
export interface K8sIoApiCoreV1VsphereVirtualDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
     */
    volumePath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
     */
    storagePolicyName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
     */
    storagePolicyID?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1WeightedPodAffinityTerm
 */
export interface K8sIoApiCoreV1WeightedPodAffinityTerm {
    /**
     * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
     * @type {number}
     * @memberof K8sIoApiCoreV1WeightedPodAffinityTerm
     */
    weight?: number;
    /**
     * 
     * @type {K8sIoApiCoreV1PodAffinityTerm}
     * @memberof K8sIoApiCoreV1WeightedPodAffinityTerm
     */
    podAffinityTerm?: K8sIoApiCoreV1PodAffinityTerm;
}
/**
 * WindowsSecurityContextOptions contain Windows-specific options and credentials.
 * @export
 * @interface K8sIoApiCoreV1WindowsSecurityContextOptions
 */
export interface K8sIoApiCoreV1WindowsSecurityContextOptions {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1WindowsSecurityContextOptions
     */
    gmsaCredentialSpecName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1WindowsSecurityContextOptions
     */
    gmsaCredentialSpec?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1WindowsSecurityContextOptions
     */
    runAsUserName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1WindowsSecurityContextOptions
     */
    hostProcess?: boolean;
}
/**
 * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.  The serialization format is:  ``` <quantity>        ::= <signedNumber><suffix>   (Note that <suffix> may be empty, from the \"\" case in <decimalSI>.)  <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= \"+\" | \"-\" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei   (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)  <decimalSI>       ::= m | \"\" | k | M | G | T | P | E   (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)  <decimalExponent> ::= \"e\" <signedNumber> | \"E\" <signedNumber> ```  No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.  When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.  Before serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:  - No precision is lost - No fractional digits will be emitted - The exponent (or suffix) is as large as possible.  The sign will be omitted unless the number is negative.  Examples:  - 1.5 will be serialized as \"1500m\" - 1.5Gi will be serialized as \"1536Mi\"  Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.  Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)  This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.  +protobuf=true +protobuf.embed=string +protobuf.options.marshal=false +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:deepcopy-gen=true +k8s:openapi-gen=true
 * @export
 * @interface K8sIoApimachineryPkgApiResourceQuantity
 */
export interface K8sIoApimachineryPkgApiResourceQuantity {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApiResourceQuantity
     */
    string?: string;
}
/**
 * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.  Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.  The exact format is defined in sigs.k8s.io/structured-merge-diff +protobuf.options.(gogoproto.goproto_stringer)=false
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1FieldsV1
 */
export interface K8sIoApimachineryPkgApisMetaV1FieldsV1 {
    /**
     * Raw is the underlying serialization of this object.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1FieldsV1
     */
    raw?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1LabelSelector
 */
export interface K8sIoApimachineryPkgApisMetaV1LabelSelector {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelector
     */
    matchLabels?: { [key: string]: string; };
    /**
     * 
     * @type {Array<K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement>}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelector
     */
    matchExpressions?: Array<K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement>;
}
/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
 */
export interface K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
     */
    key?: string;
    /**
     * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
     */
    operator?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
     */
    values?: Array<string>;
}
/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
 */
export interface K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry {
    /**
     * Manager is an identifier of the workflow managing these fields.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    manager?: string;
    /**
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    operation?: string;
    /**
     * APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    apiVersion?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    time?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    fieldsType?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1FieldsV1}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    fieldsV1?: K8sIoApimachineryPkgApisMetaV1FieldsV1;
    /**
     * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    subresource?: string;
}
/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1ObjectMeta
 */
export interface K8sIoApimachineryPkgApisMetaV1ObjectMeta {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    name?: string;
    /**
     * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will return a 409.  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    generateName?: string;
    /**
     * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    namespace?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    selfLink?: string;
    /**
     * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.  Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    uid?: string;
    /**
     * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    resourceVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    generation?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    creationTimestamp?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    deletionTimestamp?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    deletionGracePeriodSeconds?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {Array<K8sIoApimachineryPkgApisMetaV1OwnerReference>}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    ownerReferences?: Array<K8sIoApimachineryPkgApisMetaV1OwnerReference>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    finalizers?: Array<string>;
    /**
     * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
     * @type {Array<K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry>}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    managedFields?: Array<K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry>;
}
/**
 * 
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1OwnerReference
 */
export interface K8sIoApimachineryPkgApisMetaV1OwnerReference {
    /**
     * API version of the referent.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    apiVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    uid?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    controller?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    blockOwnerDeletion?: boolean;
}
/**
 * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.  +protobuf.options.marshal=false +protobuf.as=Timestamp +protobuf.options.(gogoproto.goproto_stringer)=false
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1Time
 */
export interface K8sIoApimachineryPkgApisMetaV1Time {
    /**
     * Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1Time
     */
    seconds?: string;
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     * @type {number}
     * @memberof K8sIoApimachineryPkgApisMetaV1Time
     */
    nanos?: number;
}
/**
 * +protobuf=true +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:openapi-gen=true
 * @export
 * @interface K8sIoApimachineryPkgUtilIntstrIntOrString
 */
export interface K8sIoApimachineryPkgUtilIntstrIntOrString {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgUtilIntstrIntOrString
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApimachineryPkgUtilIntstrIntOrString
     */
    intVal?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgUtilIntstrIntOrString
     */
    strVal?: string;
}
/**
 * 
 * @export
 * @interface RolloutAbortRolloutRequest
 */
export interface RolloutAbortRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutAbortRolloutRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutAbortRolloutRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutAnalysisRunInfo
 */
export interface RolloutAnalysisRunInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutAnalysisRunInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * field type from 161 -170 will be deprecated in future.
     * @type {string}
     * @memberof RolloutAnalysisRunInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutAnalysisRunInfo
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutAnalysisRunInfo
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutAnalysisRunInfo
     */
    successful?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutAnalysisRunInfo
     */
    failed?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutAnalysisRunInfo
     */
    inconclusive?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutAnalysisRunInfo
     */
    error?: number;
    /**
     * 
     * @type {Array<RolloutJobInfo>}
     * @memberof RolloutAnalysisRunInfo
     */
    jobs?: Array<RolloutJobInfo>;
    /**
     * 
     * @type {Array<RolloutNonJobInfo>}
     * @memberof RolloutAnalysisRunInfo
     */
    nonJobInfo?: Array<RolloutNonJobInfo>;
    /**
     * 
     * @type {Array<RolloutMetrics>}
     * @memberof RolloutAnalysisRunInfo
     */
    metrics?: Array<RolloutMetrics>;
    /**
     * 
     * @type {RolloutAnalysisRunSpecAndStatus}
     * @memberof RolloutAnalysisRunInfo
     */
    specAndStatus?: RolloutAnalysisRunSpecAndStatus;
}
/**
 * 
 * @export
 * @interface RolloutAnalysisRunSpecAndStatus
 */
export interface RolloutAnalysisRunSpecAndStatus {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunSpec}
     * @memberof RolloutAnalysisRunSpecAndStatus
     */
    spec?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunSpec;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus}
     * @memberof RolloutAnalysisRunSpecAndStatus
     */
    status?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunStatus;
}
/**
 * 
 * @export
 * @interface RolloutContainerInfo
 */
export interface RolloutContainerInfo {
    /**
     * 
     * @type {string}
     * @memberof RolloutContainerInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutContainerInfo
     */
    image?: string;
}
/**
 * 
 * @export
 * @interface RolloutExperimentInfo
 */
export interface RolloutExperimentInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutExperimentInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutExperimentInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutExperimentInfo
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutExperimentInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutExperimentInfo
     */
    message?: string;
    /**
     * 
     * @type {Array<RolloutReplicaSetInfo>}
     * @memberof RolloutExperimentInfo
     */
    replicaSets?: Array<RolloutReplicaSetInfo>;
    /**
     * 
     * @type {Array<RolloutAnalysisRunInfo>}
     * @memberof RolloutExperimentInfo
     */
    analysisRuns?: Array<RolloutAnalysisRunInfo>;
}
/**
 * 
 * @export
 * @interface RolloutJobInfo
 */
export interface RolloutJobInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutJobInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutJobInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutJobInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutJobInfo
     */
    metricName?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof RolloutJobInfo
     */
    startedAt?: K8sIoApimachineryPkgApisMetaV1Time;
}
/**
 * 
 * @export
 * @interface RolloutMetrics
 */
export interface RolloutMetrics {
    /**
     * 
     * @type {string}
     * @memberof RolloutMetrics
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutMetrics
     */
    successCondition?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutMetrics
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutMetrics
     */
    inconclusiveLimit?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutMetrics
     */
    failureLimit?: number;
}
/**
 * 
 * @export
 * @interface RolloutNamespaceInfo
 */
export interface RolloutNamespaceInfo {
    /**
     * 
     * @type {string}
     * @memberof RolloutNamespaceInfo
     */
    namespace?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RolloutNamespaceInfo
     */
    availableNamespaces?: Array<string>;
}
/**
 * 
 * @export
 * @interface RolloutNonJobInfo
 */
export interface RolloutNonJobInfo {
    /**
     * 
     * @type {string}
     * @memberof RolloutNonJobInfo
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutNonJobInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutNonJobInfo
     */
    metricName?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof RolloutNonJobInfo
     */
    startedAt?: K8sIoApimachineryPkgApisMetaV1Time;
}
/**
 * 
 * @export
 * @interface RolloutPodInfo
 */
export interface RolloutPodInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutPodInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutPodInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutPodInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutPodInfo
     */
    ready?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutPodInfo
     */
    restarts?: number;
}
/**
 * 
 * @export
 * @interface RolloutPromoteRolloutRequest
 */
export interface RolloutPromoteRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutPromoteRolloutRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutPromoteRolloutRequest
     */
    namespace?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutPromoteRolloutRequest
     */
    full?: boolean;
}
/**
 * 
 * @export
 * @interface RolloutReplicaSetInfo
 */
export interface RolloutReplicaSetInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutReplicaSetInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutReplicaSetInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutReplicaSetInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutReplicaSetInfo
     */
    revision?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    stable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    canary?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    preview?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RolloutReplicaSetInfo
     */
    replicas?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutReplicaSetInfo
     */
    available?: number;
    /**
     * 
     * @type {string}
     * @memberof RolloutReplicaSetInfo
     */
    template?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutReplicaSetInfo
     */
    scaleDownDeadline?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RolloutReplicaSetInfo
     */
    images?: Array<string>;
    /**
     * 
     * @type {Array<RolloutPodInfo>}
     * @memberof RolloutReplicaSetInfo
     */
    pods?: Array<RolloutPodInfo>;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    ping?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    pong?: boolean;
}
/**
 * 
 * @export
 * @interface RolloutRestartRolloutRequest
 */
export interface RolloutRestartRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutRestartRolloutRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRestartRolloutRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutRetryRolloutRequest
 */
export interface RolloutRetryRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutRetryRolloutRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRetryRolloutRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutRolloutInfo
 */
export interface RolloutRolloutInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutRolloutInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    strategy?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    step?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    setWeight?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    actualWeight?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    ready?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    current?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    desired?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    updated?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    available?: number;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    restartedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    generation?: string;
    /**
     * 
     * @type {Array<RolloutReplicaSetInfo>}
     * @memberof RolloutRolloutInfo
     */
    replicaSets?: Array<RolloutReplicaSetInfo>;
    /**
     * 
     * @type {Array<RolloutExperimentInfo>}
     * @memberof RolloutRolloutInfo
     */
    experiments?: Array<RolloutExperimentInfo>;
    /**
     * 
     * @type {Array<RolloutAnalysisRunInfo>}
     * @memberof RolloutRolloutInfo
     */
    analysisRuns?: Array<RolloutAnalysisRunInfo>;
    /**
     * 
     * @type {Array<RolloutContainerInfo>}
     * @memberof RolloutRolloutInfo
     */
    containers?: Array<RolloutContainerInfo>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>}
     * @memberof RolloutRolloutInfo
     */
    steps?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>;
}
/**
 * 
 * @export
 * @interface RolloutRolloutInfoList
 */
export interface RolloutRolloutInfoList {
    /**
     * 
     * @type {Array<RolloutRolloutInfo>}
     * @memberof RolloutRolloutInfoList
     */
    rollouts?: Array<RolloutRolloutInfo>;
}
/**
 * 
 * @export
 * @interface RolloutRolloutWatchEvent
 */
export interface RolloutRolloutWatchEvent {
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutWatchEvent
     */
    type?: string;
    /**
     * 
     * @type {RolloutRolloutInfo}
     * @memberof RolloutRolloutWatchEvent
     */
    rolloutInfo?: RolloutRolloutInfo;
}
/**
 * 
 * @export
 * @interface RolloutSetImageRequest
 */
export interface RolloutSetImageRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    rollout?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    container?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutUndoRolloutRequest
 */
export interface RolloutUndoRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutUndoRolloutRequest
     */
    rollout?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutUndoRolloutRequest
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutUndoRolloutRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutVersionInfo
 */
export interface RolloutVersionInfo {
    /**
     * 
     * @type {string}
     * @memberof RolloutVersionInfo
     */
    rolloutsVersion?: string;
}
/**
 * 
 * @export
 * @interface StreamResultOfRolloutRolloutInfo
 */
export interface StreamResultOfRolloutRolloutInfo {
    /**
     * 
     * @type {RolloutRolloutInfo}
     * @memberof StreamResultOfRolloutRolloutInfo
     */
    result?: RolloutRolloutInfo;
    /**
     * 
     * @type {GrpcGatewayRuntimeStreamError}
     * @memberof StreamResultOfRolloutRolloutInfo
     */
    error?: GrpcGatewayRuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfRolloutRolloutWatchEvent
 */
export interface StreamResultOfRolloutRolloutWatchEvent {
    /**
     * 
     * @type {RolloutRolloutWatchEvent}
     * @memberof StreamResultOfRolloutRolloutWatchEvent
     */
    result?: RolloutRolloutWatchEvent;
    /**
     * 
     * @type {GrpcGatewayRuntimeStreamError}
     * @memberof StreamResultOfRolloutRolloutWatchEvent
     */
    error?: GrpcGatewayRuntimeStreamError;
}
/**
 * RolloutServiceApi - fetch parameter creator
 * @export
 */
export const RolloutServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RolloutAbortRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceAbortRollout(body: RolloutAbortRolloutRequest, namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceAbortRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceAbortRollout.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceAbortRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/abort`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutAbortRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetNamespace(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/namespace`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetRolloutInfo(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceGetRolloutInfo.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceGetRolloutInfo.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/info`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceListRolloutInfos(namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceListRolloutInfos.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/info`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutPromoteRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServicePromoteRollout(body: RolloutPromoteRolloutRequest, namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServicePromoteRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServicePromoteRollout.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServicePromoteRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/promote`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutPromoteRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutRestartRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRestartRollout(body: RolloutRestartRolloutRequest, namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceRestartRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceRestartRollout.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceRestartRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/restart`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutRestartRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutRetryRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRetryRollout(body: RolloutRetryRolloutRequest, namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceRetryRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceRetryRollout.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceRetryRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/retry`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutRetryRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutSetImageRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} container 
         * @param {string} image 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceSetRolloutImage(body: RolloutSetImageRequest, namespace: string, rollout: string, container: string, image: string, tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'rollout' is not null or undefined
            if (rollout === null || rollout === undefined) {
                throw new RequiredError('rollout','Required parameter rollout was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{rollout}/set/{container}/{image}/{tag}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"rollout"}}`, encodeURIComponent(String(rollout)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"image"}}`, encodeURIComponent(String(image)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutSetImageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutUndoRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} revision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceUndoRollout(body: RolloutUndoRolloutRequest, namespace: string, rollout: string, revision: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceUndoRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceUndoRollout.');
            }
            // verify required parameter 'rollout' is not null or undefined
            if (rollout === null || rollout === undefined) {
                throw new RequiredError('rollout','Required parameter rollout was null or undefined when calling rolloutServiceUndoRollout.');
            }
            // verify required parameter 'revision' is not null or undefined
            if (revision === null || revision === undefined) {
                throw new RequiredError('revision','Required parameter revision was null or undefined when calling rolloutServiceUndoRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{rollout}/undo/{revision}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"rollout"}}`, encodeURIComponent(String(rollout)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutUndoRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceVersion(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfo(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceWatchRolloutInfo.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceWatchRolloutInfo.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/info/watch`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfos(namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceWatchRolloutInfos.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/info/watch`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolloutServiceApi - functional programming interface
 * @export
 */
export const RolloutServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RolloutAbortRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceAbortRollout(body: RolloutAbortRolloutRequest, namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceAbortRollout(body, namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetNamespace(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutNamespaceInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceGetNamespace(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetRolloutInfo(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutRolloutInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceGetRolloutInfo(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceListRolloutInfos(namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutRolloutInfoList> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceListRolloutInfos(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutPromoteRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServicePromoteRollout(body: RolloutPromoteRolloutRequest, namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServicePromoteRollout(body, namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutRestartRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRestartRollout(body: RolloutRestartRolloutRequest, namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceRestartRollout(body, namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutRetryRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRetryRollout(body: RolloutRetryRolloutRequest, namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceRetryRollout(body, namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutSetImageRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} container 
         * @param {string} image 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceSetRolloutImage(body: RolloutSetImageRequest, namespace: string, rollout: string, container: string, image: string, tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceSetRolloutImage(body, namespace, rollout, container, image, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutUndoRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} revision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceUndoRollout(body: RolloutUndoRolloutRequest, namespace: string, rollout: string, revision: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceUndoRollout(body, namespace, rollout, revision, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceVersion(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutVersionInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceVersion(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfo(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfRolloutRolloutInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceWatchRolloutInfo(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfos(namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfRolloutRolloutWatchEvent> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceWatchRolloutInfos(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RolloutServiceApi - factory interface
 * @export
 */
export const RolloutServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {RolloutAbortRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceAbortRollout(body: RolloutAbortRolloutRequest, namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceAbortRollout(body, namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetNamespace(options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceGetNamespace(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetRolloutInfo(namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceGetRolloutInfo(namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceListRolloutInfos(namespace: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceListRolloutInfos(namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutPromoteRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServicePromoteRollout(body: RolloutPromoteRolloutRequest, namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServicePromoteRollout(body, namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutRestartRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRestartRollout(body: RolloutRestartRolloutRequest, namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceRestartRollout(body, namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutRetryRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRetryRollout(body: RolloutRetryRolloutRequest, namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceRetryRollout(body, namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutSetImageRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} container 
         * @param {string} image 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceSetRolloutImage(body: RolloutSetImageRequest, namespace: string, rollout: string, container: string, image: string, tag: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceSetRolloutImage(body, namespace, rollout, container, image, tag, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutUndoRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} revision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceUndoRollout(body: RolloutUndoRolloutRequest, namespace: string, rollout: string, revision: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceUndoRollout(body, namespace, rollout, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceVersion(options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceVersion(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfo(namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceWatchRolloutInfo(namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfos(namespace: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceWatchRolloutInfos(namespace, options)(fetch, basePath);
        },
    };
};

/**
 * RolloutServiceApi - object-oriented interface
 * @export
 * @class RolloutServiceApi
 * @extends {BaseAPI}
 */
export class RolloutServiceApi extends BaseAPI {
    /**
     * 
     * @param {RolloutAbortRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceAbortRollout(body: RolloutAbortRolloutRequest, namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceAbortRollout(body, namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceGetNamespace(options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceGetNamespace(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceGetRolloutInfo(namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceGetRolloutInfo(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceListRolloutInfos(namespace: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceListRolloutInfos(namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutPromoteRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServicePromoteRollout(body: RolloutPromoteRolloutRequest, namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServicePromoteRollout(body, namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutRestartRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceRestartRollout(body: RolloutRestartRolloutRequest, namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceRestartRollout(body, namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutRetryRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceRetryRollout(body: RolloutRetryRolloutRequest, namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceRetryRollout(body, namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutSetImageRequest} body 
     * @param {string} namespace 
     * @param {string} rollout 
     * @param {string} container 
     * @param {string} image 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceSetRolloutImage(body: RolloutSetImageRequest, namespace: string, rollout: string, container: string, image: string, tag: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceSetRolloutImage(body, namespace, rollout, container, image, tag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutUndoRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} rollout 
     * @param {string} revision 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceUndoRollout(body: RolloutUndoRolloutRequest, namespace: string, rollout: string, revision: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceUndoRollout(body, namespace, rollout, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceVersion(options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceVersion(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceWatchRolloutInfo(namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceWatchRolloutInfo(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceWatchRolloutInfos(namespace: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceWatchRolloutInfos(namespace, options)(this.fetch, this.basePath);
    }

}
