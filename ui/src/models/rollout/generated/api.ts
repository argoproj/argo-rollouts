/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * pkg/apiclient/rollout/rollout.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    ingress?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    servicePort?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    rootService?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting
     */
    annotationPrefix?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting {
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting
     */
    mappings?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
     */
    value?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
     */
    valueFrom?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RequiredDuringSchedulingIgnoredDuringExecution}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RequiredDuringSchedulingIgnoredDuringExecution;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom
     */
    podTemplateHashValue?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom
     */
    fieldRef?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    previewSelector?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    activeSelector?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    scaleUpPreviewCheckPoint?: boolean;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    prePromotionAnalysisRunStatus?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus
     */
    postPromotionAnalysisRunStatus?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy {
    /**
     * Name of the service that the rollout modifies as the active service.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    activeService?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    previewService?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    previewReplicaCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    autoPromotionEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    autoPromotionSeconds?: number;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    maxUnavailable?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    scaleDownDelaySeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    scaleDownDelayRevisionLimit?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    prePromotionAnalysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    antiAffinity?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    postPromotionAnalysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    previewMetadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy
     */
    activeMetadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
     */
    currentStepAnalysisRunStatus?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
     */
    currentBackgroundAnalysisRunStatus?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus
     */
    currentExperiment?: string;
}
/**
 * CanaryStep defines a step of a canary deployment.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    setWeight?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    pause?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    experiment?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    analysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    setCanaryScale?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    canaryService?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    stableService?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    steps?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    trafficRouting?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    maxUnavailable?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    maxSurge?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    analysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    antiAffinity?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AntiAffinity;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    canaryMetadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    stableMetadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    scaleDownDelaySeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy
     */
    scaleDownDelayRevisionLimit?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef
     */
    fieldPath?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule
     */
    canarySubsetName?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule
     */
    stableSubsetName?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting
     */
    virtualService?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting
     */
    destinationRule?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioDestinationRule;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioVirtualService
     */
    routes?: Array<string>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting
     */
    annotationPrefix?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting
     */
    stableIngress?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting
     */
    additionalIngressAnnotations?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef
     */
    apiVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition
     */
    reason?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition
     */
    startTime?: K8sIoApimachineryPkgApisMetaV1Time;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata
     */
    annotations?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution {
    /**
     * Weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PreferredDuringSchedulingIgnoredDuringExecution
     */
    weight?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RequiredDuringSchedulingIgnoredDuringExecution
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RequiredDuringSchedulingIgnoredDuringExecution {
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout
     */
    metadata?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout
     */
    spec?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout
     */
    status?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis {
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
     */
    templates?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
     */
    args?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground
     */
    rolloutAnalysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisBackground
     */
    startingStep?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisRunStatus
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate
     */
    templateName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate
     */
    clusterScope?: boolean;
}
/**
 * RolloutCondition describes the state of a rollout at a certain point.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition {
    /**
     * Type of deployment condition.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    type?: string;
    /**
     * Phase of the condition, one of True, False, Unknown.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    status?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    lastUpdateTime?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    lastTransitionTime?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * The reason for the condition's last transition.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    reason?: string;
    /**
     * A human readable message indicating details about the transition.
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep {
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
     */
    templates?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate>;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
     */
    duration?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
     */
    analyses?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    templateName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    clusterScope?: boolean;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    args?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    requiredForCompletion?: boolean;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    specRef?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    replicas?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    metadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    selector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause {
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause
     */
    duration?: K8sIoApimachineryPkgUtilIntstrIntOrString;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    replicas?: number;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    selector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1PodTemplateSpec}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    template?: K8sIoApiCoreV1PodTemplateSpec;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    workloadRef?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ObjectRef;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    minReadySeconds?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    strategy?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    revisionHistoryLimit?: number;
    /**
     * Paused pauses the rollout at its current step.
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    paused?: boolean;
    /**
     * ProgressDeadlineSeconds The maximum time in seconds for a rollout to make progress before it is considered to be failed. Argo Rollouts will continue to process failed rollouts and a condition with a ProgressDeadlineExceeded reason will be surfaced in the rollout status. Note that progress will not be estimated during the time a rollout is paused. Defaults to 600s.
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    progressDeadlineSeconds?: number;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutSpec
     */
    restartAt?: K8sIoApimachineryPkgApisMetaV1Time;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus {
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    abort?: boolean;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    pauseConditions?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PauseCondition>;
    /**
     * ControllerPause indicates the controller has paused the rollout. It is set to true when the controller adds a pause condition. This field helps to discern the scenario where a rollout was resumed after being paused by the controller (e.g. via the plugin). In that situation, the pauseConditions would have been cleared , but controllerPause would still be set to true.
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    controllerPause?: boolean;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    abortedAt?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    currentPodHash?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    currentStepHash?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    replicas?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    updatedReplicas?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    readyReplicas?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    availableReplicas?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    currentStepIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    collisionCount?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    observedGeneration?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    conditions?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutCondition>;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    canary?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStatus;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    blueGreen?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStatus;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    hPAReplicas?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    selector?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    stableRS?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    restartedAt?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * PromoteFull indicates if the rollout should perform a full promotion, skipping analysis and pauses.
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStatus
     */
    promoteFull?: boolean;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy
     */
    blueGreen?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1BlueGreenStrategy;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutStrategy
     */
    canary?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStrategy;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    istio?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1IstioTrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    nginx?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1NginxTrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    alb?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ALBTrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    smi?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutTrafficRouting
     */
    ambassador?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AmbassadorTrafficRouting;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting
     */
    rootService?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SMITrafficRouting
     */
    trafficSplitName?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
     */
    weight?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
     */
    replicas?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
     */
    matchTrafficWeight?: boolean;
}
/**
 * 
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    typeUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<GoogleProtobufAny>}
     * @memberof GrpcGatewayRuntimeError
     */
    details?: Array<GoogleProtobufAny>;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeStreamError
 */
export interface GrpcGatewayRuntimeStreamError {
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    grpcCode?: number;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    httpCode?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    httpStatus?: string;
    /**
     * 
     * @type {Array<GoogleProtobufAny>}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    details?: Array<GoogleProtobufAny>;
}
/**
 * Represents a Persistent Disk resource in AWS.  An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
 */
export interface K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    volumeID?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    partition?: number;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Affinity is a group of affinity scheduling rules.
 * @export
 * @interface K8sIoApiCoreV1Affinity
 */
export interface K8sIoApiCoreV1Affinity {
    /**
     * 
     * @type {K8sIoApiCoreV1NodeAffinity}
     * @memberof K8sIoApiCoreV1Affinity
     */
    nodeAffinity?: K8sIoApiCoreV1NodeAffinity;
    /**
     * 
     * @type {K8sIoApiCoreV1PodAffinity}
     * @memberof K8sIoApiCoreV1Affinity
     */
    podAffinity?: K8sIoApiCoreV1PodAffinity;
    /**
     * 
     * @type {K8sIoApiCoreV1PodAntiAffinity}
     * @memberof K8sIoApiCoreV1Affinity
     */
    podAntiAffinity?: K8sIoApiCoreV1PodAntiAffinity;
}
/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 * @export
 * @interface K8sIoApiCoreV1AzureDiskVolumeSource
 */
export interface K8sIoApiCoreV1AzureDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    diskName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    diskURI?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    cachingMode?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureDiskVolumeSource
     */
    kind?: string;
}
/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 * @export
 * @interface K8sIoApiCoreV1AzureFileVolumeSource
 */
export interface K8sIoApiCoreV1AzureFileVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureFileVolumeSource
     */
    secretName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1AzureFileVolumeSource
     */
    shareName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1AzureFileVolumeSource
     */
    readOnly?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1CSIVolumeSource
 */
export interface K8sIoApiCoreV1CSIVolumeSource {
    /**
     * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
     * @type {string}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    driver?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    volumeAttributes?: { [key: string]: string; };
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1CSIVolumeSource
     */
    nodePublishSecretRef?: K8sIoApiCoreV1LocalObjectReference;
}
/**
 * Adds and removes POSIX capabilities from running containers.
 * @export
 * @interface K8sIoApiCoreV1Capabilities
 */
export interface K8sIoApiCoreV1Capabilities {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1Capabilities
     */
    add?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1Capabilities
     */
    drop?: Array<string>;
}
/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1CephFSVolumeSource
 */
export interface K8sIoApiCoreV1CephFSVolumeSource {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    monitors?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    secretFile?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1CephFSVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1CinderVolumeSource
 */
export interface K8sIoApiCoreV1CinderVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CinderVolumeSource
     */
    volumeID?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1CinderVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1CinderVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1CinderVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
}
/**
 * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.  The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
 * @export
 * @interface K8sIoApiCoreV1ConfigMapEnvSource
 */
export interface K8sIoApiCoreV1ConfigMapEnvSource {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ConfigMapEnvSource
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ConfigMapEnvSource
     */
    optional?: boolean;
}
/**
 * Selects a key from a ConfigMap.
 * @export
 * @interface K8sIoApiCoreV1ConfigMapKeySelector
 */
export interface K8sIoApiCoreV1ConfigMapKeySelector {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ConfigMapKeySelector
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * The key to select.
     * @type {string}
     * @memberof K8sIoApiCoreV1ConfigMapKeySelector
     */
    key?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ConfigMapKeySelector
     */
    optional?: boolean;
}
/**
 * Adapts a ConfigMap into a projected volume.  The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
 * @export
 * @interface K8sIoApiCoreV1ConfigMapProjection
 */
export interface K8sIoApiCoreV1ConfigMapProjection {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ConfigMapProjection
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1KeyToPath>}
     * @memberof K8sIoApiCoreV1ConfigMapProjection
     */
    items?: Array<K8sIoApiCoreV1KeyToPath>;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ConfigMapProjection
     */
    optional?: boolean;
}
/**
 * Adapts a ConfigMap into a volume.  The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1ConfigMapVolumeSource
 */
export interface K8sIoApiCoreV1ConfigMapVolumeSource {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ConfigMapVolumeSource
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1KeyToPath>}
     * @memberof K8sIoApiCoreV1ConfigMapVolumeSource
     */
    items?: Array<K8sIoApiCoreV1KeyToPath>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1ConfigMapVolumeSource
     */
    defaultMode?: number;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ConfigMapVolumeSource
     */
    optional?: boolean;
}
/**
 * A single application container that you want to run within a pod.
 * @export
 * @interface K8sIoApiCoreV1Container
 */
export interface K8sIoApiCoreV1Container {
    /**
     * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    image?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1Container
     */
    command?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1Container
     */
    args?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    workingDir?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1ContainerPort>}
     * @memberof K8sIoApiCoreV1Container
     */
    ports?: Array<K8sIoApiCoreV1ContainerPort>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EnvFromSource>}
     * @memberof K8sIoApiCoreV1Container
     */
    envFrom?: Array<K8sIoApiCoreV1EnvFromSource>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EnvVar>}
     * @memberof K8sIoApiCoreV1Container
     */
    env?: Array<K8sIoApiCoreV1EnvVar>;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceRequirements}
     * @memberof K8sIoApiCoreV1Container
     */
    resources?: K8sIoApiCoreV1ResourceRequirements;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeMount>}
     * @memberof K8sIoApiCoreV1Container
     */
    volumeMounts?: Array<K8sIoApiCoreV1VolumeMount>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeDevice>}
     * @memberof K8sIoApiCoreV1Container
     */
    volumeDevices?: Array<K8sIoApiCoreV1VolumeDevice>;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1Container
     */
    livenessProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1Container
     */
    readinessProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1Container
     */
    startupProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Lifecycle}
     * @memberof K8sIoApiCoreV1Container
     */
    lifecycle?: K8sIoApiCoreV1Lifecycle;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    terminationMessagePath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    terminationMessagePolicy?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Container
     */
    imagePullPolicy?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1SecurityContext}
     * @memberof K8sIoApiCoreV1Container
     */
    securityContext?: K8sIoApiCoreV1SecurityContext;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1Container
     */
    stdin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1Container
     */
    stdinOnce?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1Container
     */
    tty?: boolean;
}
/**
 * ContainerPort represents a network port in a single container.
 * @export
 * @interface K8sIoApiCoreV1ContainerPort
 */
export interface K8sIoApiCoreV1ContainerPort {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    hostPort?: number;
    /**
     * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
     * @type {number}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    containerPort?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    protocol?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ContainerPort
     */
    hostIP?: string;
}
/**
 * Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
 * @export
 * @interface K8sIoApiCoreV1DownwardAPIProjection
 */
export interface K8sIoApiCoreV1DownwardAPIProjection {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1DownwardAPIVolumeFile>}
     * @memberof K8sIoApiCoreV1DownwardAPIProjection
     */
    items?: Array<K8sIoApiCoreV1DownwardAPIVolumeFile>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1DownwardAPIVolumeFile
 */
export interface K8sIoApiCoreV1DownwardAPIVolumeFile {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeFile
     */
    path?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1ObjectFieldSelector}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeFile
     */
    fieldRef?: K8sIoApiCoreV1ObjectFieldSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceFieldSelector}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeFile
     */
    resourceFieldRef?: K8sIoApiCoreV1ResourceFieldSelector;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeFile
     */
    mode?: number;
}
/**
 * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1DownwardAPIVolumeSource
 */
export interface K8sIoApiCoreV1DownwardAPIVolumeSource {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1DownwardAPIVolumeFile>}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeSource
     */
    items?: Array<K8sIoApiCoreV1DownwardAPIVolumeFile>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1DownwardAPIVolumeSource
     */
    defaultMode?: number;
}
/**
 * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1EmptyDirVolumeSource
 */
export interface K8sIoApiCoreV1EmptyDirVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EmptyDirVolumeSource
     */
    medium?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApiResourceQuantity}
     * @memberof K8sIoApiCoreV1EmptyDirVolumeSource
     */
    sizeLimit?: K8sIoApimachineryPkgApiResourceQuantity;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1EnvFromSource
 */
export interface K8sIoApiCoreV1EnvFromSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EnvFromSource
     */
    prefix?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1ConfigMapEnvSource}
     * @memberof K8sIoApiCoreV1EnvFromSource
     */
    configMapRef?: K8sIoApiCoreV1ConfigMapEnvSource;
    /**
     * 
     * @type {K8sIoApiCoreV1SecretEnvSource}
     * @memberof K8sIoApiCoreV1EnvFromSource
     */
    secretRef?: K8sIoApiCoreV1SecretEnvSource;
}
/**
 * EnvVar represents an environment variable present in a Container.
 * @export
 * @interface K8sIoApiCoreV1EnvVar
 */
export interface K8sIoApiCoreV1EnvVar {
    /**
     * Name of the environment variable. Must be a C_IDENTIFIER.
     * @type {string}
     * @memberof K8sIoApiCoreV1EnvVar
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EnvVar
     */
    value?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1EnvVarSource}
     * @memberof K8sIoApiCoreV1EnvVar
     */
    valueFrom?: K8sIoApiCoreV1EnvVarSource;
}
/**
 * EnvVarSource represents a source for the value of an EnvVar.
 * @export
 * @interface K8sIoApiCoreV1EnvVarSource
 */
export interface K8sIoApiCoreV1EnvVarSource {
    /**
     * 
     * @type {K8sIoApiCoreV1ObjectFieldSelector}
     * @memberof K8sIoApiCoreV1EnvVarSource
     */
    fieldRef?: K8sIoApiCoreV1ObjectFieldSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceFieldSelector}
     * @memberof K8sIoApiCoreV1EnvVarSource
     */
    resourceFieldRef?: K8sIoApiCoreV1ResourceFieldSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1ConfigMapKeySelector}
     * @memberof K8sIoApiCoreV1EnvVarSource
     */
    configMapKeyRef?: K8sIoApiCoreV1ConfigMapKeySelector;
    /**
     * 
     * @type {K8sIoApiCoreV1SecretKeySelector}
     * @memberof K8sIoApiCoreV1EnvVarSource
     */
    secretKeyRef?: K8sIoApiCoreV1SecretKeySelector;
}
/**
 * An EphemeralContainer is a container that may be added temporarily to an existing pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a pod is removed or restarted. If an ephemeral container causes a pod to exceed its resource allocation, the pod may be evicted. Ephemeral containers may not be added by directly updating the pod spec. They must be added via the pod's ephemeralcontainers subresource, and they will appear in the pod spec once added. This is an alpha feature enabled by the EphemeralContainers feature flag.
 * @export
 * @interface K8sIoApiCoreV1EphemeralContainer
 */
export interface K8sIoApiCoreV1EphemeralContainer {
    /**
     * 
     * @type {K8sIoApiCoreV1EphemeralContainerCommon}
     * @memberof K8sIoApiCoreV1EphemeralContainer
     */
    ephemeralContainerCommon?: K8sIoApiCoreV1EphemeralContainerCommon;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainer
     */
    targetContainerName?: string;
}
/**
 * EphemeralContainerCommon is a copy of all fields in Container to be inlined in EphemeralContainer. This separate type allows easy conversion from EphemeralContainer to Container and allows separate documentation for the fields of EphemeralContainer. When a new field is added to Container it must be added here as well.
 * @export
 * @interface K8sIoApiCoreV1EphemeralContainerCommon
 */
export interface K8sIoApiCoreV1EphemeralContainerCommon {
    /**
     * Name of the ephemeral container specified as a DNS_LABEL. This name must be unique among all containers, init containers and ephemeral containers.
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    image?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    command?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    args?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    workingDir?: string;
    /**
     * Ports are not allowed for ephemeral containers.
     * @type {Array<K8sIoApiCoreV1ContainerPort>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    ports?: Array<K8sIoApiCoreV1ContainerPort>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EnvFromSource>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    envFrom?: Array<K8sIoApiCoreV1EnvFromSource>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EnvVar>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    env?: Array<K8sIoApiCoreV1EnvVar>;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceRequirements}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    resources?: K8sIoApiCoreV1ResourceRequirements;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeMount>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    volumeMounts?: Array<K8sIoApiCoreV1VolumeMount>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeDevice>}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    volumeDevices?: Array<K8sIoApiCoreV1VolumeDevice>;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    livenessProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    readinessProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Probe}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    startupProbe?: K8sIoApiCoreV1Probe;
    /**
     * 
     * @type {K8sIoApiCoreV1Lifecycle}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    lifecycle?: K8sIoApiCoreV1Lifecycle;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    terminationMessagePath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    terminationMessagePolicy?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    imagePullPolicy?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1SecurityContext}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    securityContext?: K8sIoApiCoreV1SecurityContext;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    stdin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    stdinOnce?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1EphemeralContainerCommon
     */
    tty?: boolean;
}
/**
 * Represents an ephemeral volume that is handled by a normal storage driver.
 * @export
 * @interface K8sIoApiCoreV1EphemeralVolumeSource
 */
export interface K8sIoApiCoreV1EphemeralVolumeSource {
    /**
     * 
     * @type {K8sIoApiCoreV1PersistentVolumeClaimTemplate}
     * @memberof K8sIoApiCoreV1EphemeralVolumeSource
     */
    volumeClaimTemplate?: K8sIoApiCoreV1PersistentVolumeClaimTemplate;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1EphemeralVolumeSource
     */
    readOnly?: boolean;
}
/**
 * ExecAction describes a \"run in container\" action.
 * @export
 * @interface K8sIoApiCoreV1ExecAction
 */
export interface K8sIoApiCoreV1ExecAction {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1ExecAction
     */
    command?: Array<string>;
}
/**
 * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1FCVolumeSource
 */
export interface K8sIoApiCoreV1FCVolumeSource {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    targetWWNs?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    lun?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1FCVolumeSource
     */
    wwids?: Array<string>;
}
/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 * @export
 * @interface K8sIoApiCoreV1FlexVolumeSource
 */
export interface K8sIoApiCoreV1FlexVolumeSource {
    /**
     * Driver is the name of the driver to use for this volume.
     * @type {string}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    driver?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApiCoreV1FlexVolumeSource
     */
    options?: { [key: string]: string; };
}
/**
 * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1FlockerVolumeSource
 */
export interface K8sIoApiCoreV1FlockerVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1FlockerVolumeSource
     */
    datasetName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1FlockerVolumeSource
     */
    datasetUUID?: string;
}
/**
 * Represents a Persistent Disk resource in Google Compute Engine.  A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1GCEPersistentDiskVolumeSource
 */
export interface K8sIoApiCoreV1GCEPersistentDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GCEPersistentDiskVolumeSource
     */
    pdName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GCEPersistentDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1GCEPersistentDiskVolumeSource
     */
    partition?: number;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1GCEPersistentDiskVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.  DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 * @export
 * @interface K8sIoApiCoreV1GitRepoVolumeSource
 */
export interface K8sIoApiCoreV1GitRepoVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GitRepoVolumeSource
     */
    repository?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GitRepoVolumeSource
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GitRepoVolumeSource
     */
    directory?: string;
}
/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1GlusterfsVolumeSource
 */
export interface K8sIoApiCoreV1GlusterfsVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GlusterfsVolumeSource
     */
    endpoints?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1GlusterfsVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1GlusterfsVolumeSource
     */
    readOnly?: boolean;
}
/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 * @export
 * @interface K8sIoApiCoreV1HTTPGetAction
 */
export interface K8sIoApiCoreV1HTTPGetAction {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    path?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    port?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    host?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    scheme?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1HTTPHeader>}
     * @memberof K8sIoApiCoreV1HTTPGetAction
     */
    httpHeaders?: Array<K8sIoApiCoreV1HTTPHeader>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1HTTPHeader
 */
export interface K8sIoApiCoreV1HTTPHeader {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPHeader
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HTTPHeader
     */
    value?: string;
}
/**
 * Handler defines a specific action that should be taken TODO: pass structured data to these actions, and document that data here.
 * @export
 * @interface K8sIoApiCoreV1Handler
 */
export interface K8sIoApiCoreV1Handler {
    /**
     * 
     * @type {K8sIoApiCoreV1ExecAction}
     * @memberof K8sIoApiCoreV1Handler
     */
    exec?: K8sIoApiCoreV1ExecAction;
    /**
     * 
     * @type {K8sIoApiCoreV1HTTPGetAction}
     * @memberof K8sIoApiCoreV1Handler
     */
    httpGet?: K8sIoApiCoreV1HTTPGetAction;
    /**
     * 
     * @type {K8sIoApiCoreV1TCPSocketAction}
     * @memberof K8sIoApiCoreV1Handler
     */
    tcpSocket?: K8sIoApiCoreV1TCPSocketAction;
}
/**
 * HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the pod's hosts file.
 * @export
 * @interface K8sIoApiCoreV1HostAlias
 */
export interface K8sIoApiCoreV1HostAlias {
    /**
     * IP address of the host file entry.
     * @type {string}
     * @memberof K8sIoApiCoreV1HostAlias
     */
    ip?: string;
    /**
     * Hostnames for the above IP address.
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1HostAlias
     */
    hostnames?: Array<string>;
}
/**
 * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1HostPathVolumeSource
 */
export interface K8sIoApiCoreV1HostPathVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HostPathVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1HostPathVolumeSource
     */
    type?: string;
}
/**
 * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1ISCSIVolumeSource
 */
export interface K8sIoApiCoreV1ISCSIVolumeSource {
    /**
     * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    targetPortal?: string;
    /**
     * Target iSCSI Qualified Name.
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    iqn?: string;
    /**
     * iSCSI Target Lun number.
     * @type {number}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    lun?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    iscsiInterface?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    portals?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    chapAuthDiscovery?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    chapAuthSession?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ISCSIVolumeSource
     */
    initiatorName?: string;
}
/**
 * Maps a string key to a path within a volume.
 * @export
 * @interface K8sIoApiCoreV1KeyToPath
 */
export interface K8sIoApiCoreV1KeyToPath {
    /**
     * The key to project.
     * @type {string}
     * @memberof K8sIoApiCoreV1KeyToPath
     */
    key?: string;
    /**
     * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
     * @type {string}
     * @memberof K8sIoApiCoreV1KeyToPath
     */
    path?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1KeyToPath
     */
    mode?: number;
}
/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
 * @export
 * @interface K8sIoApiCoreV1Lifecycle
 */
export interface K8sIoApiCoreV1Lifecycle {
    /**
     * 
     * @type {K8sIoApiCoreV1Handler}
     * @memberof K8sIoApiCoreV1Lifecycle
     */
    postStart?: K8sIoApiCoreV1Handler;
    /**
     * 
     * @type {K8sIoApiCoreV1Handler}
     * @memberof K8sIoApiCoreV1Lifecycle
     */
    preStop?: K8sIoApiCoreV1Handler;
}
/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 * @export
 * @interface K8sIoApiCoreV1LocalObjectReference
 */
export interface K8sIoApiCoreV1LocalObjectReference {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1LocalObjectReference
     */
    name?: string;
}
/**
 * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1NFSVolumeSource
 */
export interface K8sIoApiCoreV1NFSVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1NFSVolumeSource
     */
    server?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1NFSVolumeSource
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1NFSVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Node affinity is a group of node affinity scheduling rules.
 * @export
 * @interface K8sIoApiCoreV1NodeAffinity
 */
export interface K8sIoApiCoreV1NodeAffinity {
    /**
     * 
     * @type {K8sIoApiCoreV1NodeSelector}
     * @memberof K8sIoApiCoreV1NodeAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: K8sIoApiCoreV1NodeSelector;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PreferredSchedulingTerm>}
     * @memberof K8sIoApiCoreV1NodeAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1PreferredSchedulingTerm>;
}
/**
 * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 * @export
 * @interface K8sIoApiCoreV1NodeSelector
 */
export interface K8sIoApiCoreV1NodeSelector {
    /**
     * Required. A list of node selector terms. The terms are ORed.
     * @type {Array<K8sIoApiCoreV1NodeSelectorTerm>}
     * @memberof K8sIoApiCoreV1NodeSelector
     */
    nodeSelectorTerms?: Array<K8sIoApiCoreV1NodeSelectorTerm>;
}
/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 * @export
 * @interface K8sIoApiCoreV1NodeSelectorRequirement
 */
export interface K8sIoApiCoreV1NodeSelectorRequirement {
    /**
     * The label key that the selector applies to.
     * @type {string}
     * @memberof K8sIoApiCoreV1NodeSelectorRequirement
     */
    key?: string;
    /**
     * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
     * @type {string}
     * @memberof K8sIoApiCoreV1NodeSelectorRequirement
     */
    operator?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1NodeSelectorRequirement
     */
    values?: Array<string>;
}
/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 * @export
 * @interface K8sIoApiCoreV1NodeSelectorTerm
 */
export interface K8sIoApiCoreV1NodeSelectorTerm {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1NodeSelectorRequirement>}
     * @memberof K8sIoApiCoreV1NodeSelectorTerm
     */
    matchExpressions?: Array<K8sIoApiCoreV1NodeSelectorRequirement>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1NodeSelectorRequirement>}
     * @memberof K8sIoApiCoreV1NodeSelectorTerm
     */
    matchFields?: Array<K8sIoApiCoreV1NodeSelectorRequirement>;
}
/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 * @export
 * @interface K8sIoApiCoreV1ObjectFieldSelector
 */
export interface K8sIoApiCoreV1ObjectFieldSelector {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ObjectFieldSelector
     */
    apiVersion?: string;
    /**
     * Path of the field to select in the specified API version.
     * @type {string}
     * @memberof K8sIoApiCoreV1ObjectFieldSelector
     */
    fieldPath?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1PersistentVolumeClaimSpec
 */
export interface K8sIoApiCoreV1PersistentVolumeClaimSpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    accessModes?: Array<string>;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    selector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
    /**
     * 
     * @type {K8sIoApiCoreV1ResourceRequirements}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    resources?: K8sIoApiCoreV1ResourceRequirements;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    volumeName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    storageClassName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    volumeMode?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1TypedLocalObjectReference}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimSpec
     */
    dataSource?: K8sIoApiCoreV1TypedLocalObjectReference;
}
/**
 * PersistentVolumeClaimTemplate is used to produce PersistentVolumeClaim objects as part of an EphemeralVolumeSource.
 * @export
 * @interface K8sIoApiCoreV1PersistentVolumeClaimTemplate
 */
export interface K8sIoApiCoreV1PersistentVolumeClaimTemplate {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimTemplate
     */
    metadata?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {K8sIoApiCoreV1PersistentVolumeClaimSpec}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimTemplate
     */
    spec?: K8sIoApiCoreV1PersistentVolumeClaimSpec;
}
/**
 * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
 * @export
 * @interface K8sIoApiCoreV1PersistentVolumeClaimVolumeSource
 */
export interface K8sIoApiCoreV1PersistentVolumeClaimVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimVolumeSource
     */
    claimName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PersistentVolumeClaimVolumeSource
     */
    readOnly?: boolean;
}
/**
 * Represents a Photon Controller persistent disk resource.
 * @export
 * @interface K8sIoApiCoreV1PhotonPersistentDiskVolumeSource
 */
export interface K8sIoApiCoreV1PhotonPersistentDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PhotonPersistentDiskVolumeSource
     */
    pdID?: string;
    /**
     * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified.
     * @type {string}
     * @memberof K8sIoApiCoreV1PhotonPersistentDiskVolumeSource
     */
    fsType?: string;
}
/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 * @export
 * @interface K8sIoApiCoreV1PodAffinity
 */
export interface K8sIoApiCoreV1PodAffinity {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PodAffinityTerm>}
     * @memberof K8sIoApiCoreV1PodAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1PodAffinityTerm>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1WeightedPodAffinityTerm>}
     * @memberof K8sIoApiCoreV1PodAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1WeightedPodAffinityTerm>;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1PodAffinityTerm
 */
export interface K8sIoApiCoreV1PodAffinityTerm {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof K8sIoApiCoreV1PodAffinityTerm
     */
    labelSelector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PodAffinityTerm
     */
    namespaces?: Array<string>;
    /**
     * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
     * @type {string}
     * @memberof K8sIoApiCoreV1PodAffinityTerm
     */
    topologyKey?: string;
}
/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 * @export
 * @interface K8sIoApiCoreV1PodAntiAffinity
 */
export interface K8sIoApiCoreV1PodAntiAffinity {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PodAffinityTerm>}
     * @memberof K8sIoApiCoreV1PodAntiAffinity
     */
    requiredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1PodAffinityTerm>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1WeightedPodAffinityTerm>}
     * @memberof K8sIoApiCoreV1PodAntiAffinity
     */
    preferredDuringSchedulingIgnoredDuringExecution?: Array<K8sIoApiCoreV1WeightedPodAffinityTerm>;
}
/**
 * PodDNSConfig defines the DNS parameters of a pod in addition to those generated from DNSPolicy.
 * @export
 * @interface K8sIoApiCoreV1PodDNSConfig
 */
export interface K8sIoApiCoreV1PodDNSConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PodDNSConfig
     */
    nameservers?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PodDNSConfig
     */
    searches?: Array<string>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PodDNSConfigOption>}
     * @memberof K8sIoApiCoreV1PodDNSConfig
     */
    options?: Array<K8sIoApiCoreV1PodDNSConfigOption>;
}
/**
 * PodDNSConfigOption defines DNS resolver options of a pod.
 * @export
 * @interface K8sIoApiCoreV1PodDNSConfigOption
 */
export interface K8sIoApiCoreV1PodDNSConfigOption {
    /**
     * Required.
     * @type {string}
     * @memberof K8sIoApiCoreV1PodDNSConfigOption
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodDNSConfigOption
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1PodReadinessGate
 */
export interface K8sIoApiCoreV1PodReadinessGate {
    /**
     * ConditionType refers to a condition in the pod's condition list with matching type.
     * @type {string}
     * @memberof K8sIoApiCoreV1PodReadinessGate
     */
    conditionType?: string;
}
/**
 * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
 * @export
 * @interface K8sIoApiCoreV1PodSecurityContext
 */
export interface K8sIoApiCoreV1PodSecurityContext {
    /**
     * 
     * @type {K8sIoApiCoreV1SELinuxOptions}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    seLinuxOptions?: K8sIoApiCoreV1SELinuxOptions;
    /**
     * 
     * @type {K8sIoApiCoreV1WindowsSecurityContextOptions}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    windowsOptions?: K8sIoApiCoreV1WindowsSecurityContextOptions;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    runAsUser?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    runAsGroup?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    runAsNonRoot?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    supplementalGroups?: Array<string>;
    /**
     * 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----  If unset, the Kubelet will not modify the ownership and permissions of any volume. +optional
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    fsGroup?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Sysctl>}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    sysctls?: Array<K8sIoApiCoreV1Sysctl>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    fsGroupChangePolicy?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1SeccompProfile}
     * @memberof K8sIoApiCoreV1PodSecurityContext
     */
    seccompProfile?: K8sIoApiCoreV1SeccompProfile;
}
/**
 * PodSpec is a description of a pod.
 * @export
 * @interface K8sIoApiCoreV1PodSpec
 */
export interface K8sIoApiCoreV1PodSpec {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Volume>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    volumes?: Array<K8sIoApiCoreV1Volume>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Container>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    initContainers?: Array<K8sIoApiCoreV1Container>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Container>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    containers?: Array<K8sIoApiCoreV1Container>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1EphemeralContainer>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    ephemeralContainers?: Array<K8sIoApiCoreV1EphemeralContainer>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    restartPolicy?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    terminationGracePeriodSeconds?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    activeDeadlineSeconds?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    dnsPolicy?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    nodeSelector?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    serviceAccountName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    serviceAccount?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    automountServiceAccountToken?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    nodeName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostNetwork?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostPID?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostIPC?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    shareProcessNamespace?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1PodSecurityContext}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    securityContext?: K8sIoApiCoreV1PodSecurityContext;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1LocalObjectReference>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    imagePullSecrets?: Array<K8sIoApiCoreV1LocalObjectReference>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostname?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    subdomain?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1Affinity}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    affinity?: K8sIoApiCoreV1Affinity;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    schedulerName?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1Toleration>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    tolerations?: Array<K8sIoApiCoreV1Toleration>;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1HostAlias>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    hostAliases?: Array<K8sIoApiCoreV1HostAlias>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    priorityClassName?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    priority?: number;
    /**
     * 
     * @type {K8sIoApiCoreV1PodDNSConfig}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    dnsConfig?: K8sIoApiCoreV1PodDNSConfig;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1PodReadinessGate>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    readinessGates?: Array<K8sIoApiCoreV1PodReadinessGate>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    runtimeClassName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    enableServiceLinks?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    preemptionPolicy?: string;
    /**
     * 
     * @type {{ [key: string]: K8sIoApimachineryPkgApiResourceQuantity; }}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    overhead?: { [key: string]: K8sIoApimachineryPkgApiResourceQuantity; };
    /**
     * 
     * @type {Array<K8sIoApiCoreV1TopologySpreadConstraint>}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    topologySpreadConstraints?: Array<K8sIoApiCoreV1TopologySpreadConstraint>;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PodSpec
     */
    setHostnameAsFQDN?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1PodTemplateSpec
 */
export interface K8sIoApiCoreV1PodTemplateSpec {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof K8sIoApiCoreV1PodTemplateSpec
     */
    metadata?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {K8sIoApiCoreV1PodSpec}
     * @memberof K8sIoApiCoreV1PodTemplateSpec
     */
    spec?: K8sIoApiCoreV1PodSpec;
}
/**
 * PortworxVolumeSource represents a Portworx volume resource.
 * @export
 * @interface K8sIoApiCoreV1PortworxVolumeSource
 */
export interface K8sIoApiCoreV1PortworxVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1PortworxVolumeSource
     */
    volumeID?: string;
    /**
     * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. \"ext4\", \"xfs\". Implicitly inferred to be \"ext4\" if unspecified.
     * @type {string}
     * @memberof K8sIoApiCoreV1PortworxVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1PortworxVolumeSource
     */
    readOnly?: boolean;
}
/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 * @export
 * @interface K8sIoApiCoreV1PreferredSchedulingTerm
 */
export interface K8sIoApiCoreV1PreferredSchedulingTerm {
    /**
     * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
     * @type {number}
     * @memberof K8sIoApiCoreV1PreferredSchedulingTerm
     */
    weight?: number;
    /**
     * 
     * @type {K8sIoApiCoreV1NodeSelectorTerm}
     * @memberof K8sIoApiCoreV1PreferredSchedulingTerm
     */
    preference?: K8sIoApiCoreV1NodeSelectorTerm;
}
/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 * @export
 * @interface K8sIoApiCoreV1Probe
 */
export interface K8sIoApiCoreV1Probe {
    /**
     * 
     * @type {K8sIoApiCoreV1Handler}
     * @memberof K8sIoApiCoreV1Probe
     */
    handler?: K8sIoApiCoreV1Handler;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    initialDelaySeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    timeoutSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    periodSeconds?: number;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    successThreshold?: number;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1Probe
     */
    failureThreshold?: number;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1ProjectedVolumeSource
 */
export interface K8sIoApiCoreV1ProjectedVolumeSource {
    /**
     * 
     * @type {Array<K8sIoApiCoreV1VolumeProjection>}
     * @memberof K8sIoApiCoreV1ProjectedVolumeSource
     */
    sources?: Array<K8sIoApiCoreV1VolumeProjection>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1ProjectedVolumeSource
     */
    defaultMode?: number;
}
/**
 * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1QuobyteVolumeSource
 */
export interface K8sIoApiCoreV1QuobyteVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    registry?: string;
    /**
     * Volume is a string that references an already created Quobyte volume by name.
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    volume?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    group?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1QuobyteVolumeSource
     */
    tenant?: string;
}
/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1RBDVolumeSource
 */
export interface K8sIoApiCoreV1RBDVolumeSource {
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    monitors?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    pool?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    keyring?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1RBDVolumeSource
     */
    readOnly?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1ResourceFieldSelector
 */
export interface K8sIoApiCoreV1ResourceFieldSelector {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ResourceFieldSelector
     */
    containerName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ResourceFieldSelector
     */
    resource?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApiResourceQuantity}
     * @memberof K8sIoApiCoreV1ResourceFieldSelector
     */
    divisor?: K8sIoApimachineryPkgApiResourceQuantity;
}
/**
 * ResourceRequirements describes the compute resource requirements.
 * @export
 * @interface K8sIoApiCoreV1ResourceRequirements
 */
export interface K8sIoApiCoreV1ResourceRequirements {
    /**
     * 
     * @type {{ [key: string]: K8sIoApimachineryPkgApiResourceQuantity; }}
     * @memberof K8sIoApiCoreV1ResourceRequirements
     */
    limits?: { [key: string]: K8sIoApimachineryPkgApiResourceQuantity; };
    /**
     * 
     * @type {{ [key: string]: K8sIoApimachineryPkgApiResourceQuantity; }}
     * @memberof K8sIoApiCoreV1ResourceRequirements
     */
    requests?: { [key: string]: K8sIoApimachineryPkgApiResourceQuantity; };
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1SELinuxOptions
 */
export interface K8sIoApiCoreV1SELinuxOptions {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SELinuxOptions
     */
    user?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SELinuxOptions
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SELinuxOptions
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SELinuxOptions
     */
    level?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1ScaleIOVolumeSource
 */
export interface K8sIoApiCoreV1ScaleIOVolumeSource {
    /**
     * The host address of the ScaleIO API Gateway.
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    gateway?: string;
    /**
     * The name of the storage system as configured in ScaleIO.
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    system?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    sslEnabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    protectionDomain?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    storagePool?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    storageMode?: string;
    /**
     * The name of a volume already created in the ScaleIO system that is associated with this volume source.
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    volumeName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1ScaleIOVolumeSource
     */
    readOnly?: boolean;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1SeccompProfile
 */
export interface K8sIoApiCoreV1SeccompProfile {
    /**
     * Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied. +unionDiscriminator
     * @type {string}
     * @memberof K8sIoApiCoreV1SeccompProfile
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SeccompProfile
     */
    localhostProfile?: string;
}
/**
 * SecretEnvSource selects a Secret to populate the environment variables with.  The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
 * @export
 * @interface K8sIoApiCoreV1SecretEnvSource
 */
export interface K8sIoApiCoreV1SecretEnvSource {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1SecretEnvSource
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecretEnvSource
     */
    optional?: boolean;
}
/**
 * SecretKeySelector selects a key of a Secret.
 * @export
 * @interface K8sIoApiCoreV1SecretKeySelector
 */
export interface K8sIoApiCoreV1SecretKeySelector {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1SecretKeySelector
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * The key of the secret to select from.  Must be a valid secret key.
     * @type {string}
     * @memberof K8sIoApiCoreV1SecretKeySelector
     */
    key?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecretKeySelector
     */
    optional?: boolean;
}
/**
 * Adapts a secret into a projected volume.  The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
 * @export
 * @interface K8sIoApiCoreV1SecretProjection
 */
export interface K8sIoApiCoreV1SecretProjection {
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1SecretProjection
     */
    localObjectReference?: K8sIoApiCoreV1LocalObjectReference;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1KeyToPath>}
     * @memberof K8sIoApiCoreV1SecretProjection
     */
    items?: Array<K8sIoApiCoreV1KeyToPath>;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecretProjection
     */
    optional?: boolean;
}
/**
 * Adapts a Secret into a volume.  The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
 * @export
 * @interface K8sIoApiCoreV1SecretVolumeSource
 */
export interface K8sIoApiCoreV1SecretVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SecretVolumeSource
     */
    secretName?: string;
    /**
     * 
     * @type {Array<K8sIoApiCoreV1KeyToPath>}
     * @memberof K8sIoApiCoreV1SecretVolumeSource
     */
    items?: Array<K8sIoApiCoreV1KeyToPath>;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApiCoreV1SecretVolumeSource
     */
    defaultMode?: number;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecretVolumeSource
     */
    optional?: boolean;
}
/**
 * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
 * @export
 * @interface K8sIoApiCoreV1SecurityContext
 */
export interface K8sIoApiCoreV1SecurityContext {
    /**
     * 
     * @type {K8sIoApiCoreV1Capabilities}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    capabilities?: K8sIoApiCoreV1Capabilities;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    privileged?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1SELinuxOptions}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    seLinuxOptions?: K8sIoApiCoreV1SELinuxOptions;
    /**
     * 
     * @type {K8sIoApiCoreV1WindowsSecurityContextOptions}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    windowsOptions?: K8sIoApiCoreV1WindowsSecurityContextOptions;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    runAsUser?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    runAsGroup?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    runAsNonRoot?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    readOnlyRootFilesystem?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    allowPrivilegeEscalation?: boolean;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    procMount?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1SeccompProfile}
     * @memberof K8sIoApiCoreV1SecurityContext
     */
    seccompProfile?: K8sIoApiCoreV1SeccompProfile;
}
/**
 * ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
 * @export
 * @interface K8sIoApiCoreV1ServiceAccountTokenProjection
 */
export interface K8sIoApiCoreV1ServiceAccountTokenProjection {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ServiceAccountTokenProjection
     */
    audience?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1ServiceAccountTokenProjection
     */
    expirationSeconds?: string;
    /**
     * Path is the path relative to the mount point of the file to project the token into.
     * @type {string}
     * @memberof K8sIoApiCoreV1ServiceAccountTokenProjection
     */
    path?: string;
}
/**
 * Represents a StorageOS persistent volume resource.
 * @export
 * @interface K8sIoApiCoreV1StorageOSVolumeSource
 */
export interface K8sIoApiCoreV1StorageOSVolumeSource {
    /**
     * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
     * @type {string}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    volumeName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    volumeNamespace?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    readOnly?: boolean;
    /**
     * 
     * @type {K8sIoApiCoreV1LocalObjectReference}
     * @memberof K8sIoApiCoreV1StorageOSVolumeSource
     */
    secretRef?: K8sIoApiCoreV1LocalObjectReference;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1Sysctl
 */
export interface K8sIoApiCoreV1Sysctl {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Sysctl
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Sysctl
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1TCPSocketAction
 */
export interface K8sIoApiCoreV1TCPSocketAction {
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof K8sIoApiCoreV1TCPSocketAction
     */
    port?: K8sIoApimachineryPkgUtilIntstrIntOrString;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1TCPSocketAction
     */
    host?: string;
}
/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 * @export
 * @interface K8sIoApiCoreV1Toleration
 */
export interface K8sIoApiCoreV1Toleration {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    operator?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    effect?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Toleration
     */
    tolerationSeconds?: string;
}
/**
 * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
 * @export
 * @interface K8sIoApiCoreV1TopologySpreadConstraint
 */
export interface K8sIoApiCoreV1TopologySpreadConstraint {
    /**
     * MaxSkew describes the degree to which pods may be unevenly distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference between the number of matching pods in the target topology and the global minimum. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 1/1/0: +-------+-------+-------+ | zone1 | zone2 | zone3 | +-------+-------+-------+ |   P   |   P   |       | +-------+-------+-------+ - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 1/1/1; scheduling it onto zone1(zone2) would make the ActualSkew(2-0) on zone1(zone2) violate MaxSkew(1). - if MaxSkew is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence to topologies that satisfy it. It's a required field. Default value is 1 and 0 is not allowed.
     * @type {number}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    maxSkew?: number;
    /**
     * TopologyKey is the key of node labels. Nodes that have a label with this key and identical values are considered to be in the same topology. We consider each <key, value> as a \"bucket\", and try to put balanced number of pods into each bucket. It's a required field.
     * @type {string}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    topologyKey?: string;
    /**
     * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location,   but giving higher precedence to topologies that would help reduce the   skew. A constraint is considered \"Unsatisfiable\" for an incoming pod if and only if every possible node assigment for that pod would violate \"MaxSkew\" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: +-------+-------+-------+ | zone1 | zone2 | zone3 | +-------+-------+-------+ | P P P |   P   |   P   | +-------+-------+-------+ If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.
     * @type {string}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    whenUnsatisfiable?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof K8sIoApiCoreV1TopologySpreadConstraint
     */
    labelSelector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
}
/**
 * TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.
 * @export
 * @interface K8sIoApiCoreV1TypedLocalObjectReference
 */
export interface K8sIoApiCoreV1TypedLocalObjectReference {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1TypedLocalObjectReference
     */
    apiGroup?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1TypedLocalObjectReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1TypedLocalObjectReference
     */
    name?: string;
}
/**
 * Volume represents a named volume in a pod that may be accessed by any container in the pod.
 * @export
 * @interface K8sIoApiCoreV1Volume
 */
export interface K8sIoApiCoreV1Volume {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1Volume
     */
    name?: string;
    /**
     * 
     * @type {K8sIoApiCoreV1VolumeSource}
     * @memberof K8sIoApiCoreV1Volume
     */
    volumeSource?: K8sIoApiCoreV1VolumeSource;
}
/**
 * volumeDevice describes a mapping of a raw block device within a container.
 * @export
 * @interface K8sIoApiCoreV1VolumeDevice
 */
export interface K8sIoApiCoreV1VolumeDevice {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeDevice
     */
    name?: string;
    /**
     * devicePath is the path inside of the container that the device will be mapped to.
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeDevice
     */
    devicePath?: string;
}
/**
 * VolumeMount describes a mounting of a Volume within a container.
 * @export
 * @interface K8sIoApiCoreV1VolumeMount
 */
export interface K8sIoApiCoreV1VolumeMount {
    /**
     * This must match the Name of a Volume.
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    readOnly?: boolean;
    /**
     * Path within the container at which the volume should be mounted.  Must not contain ':'.
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    mountPath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    subPath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    mountPropagation?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VolumeMount
     */
    subPathExpr?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1VolumeProjection
 */
export interface K8sIoApiCoreV1VolumeProjection {
    /**
     * 
     * @type {K8sIoApiCoreV1SecretProjection}
     * @memberof K8sIoApiCoreV1VolumeProjection
     */
    secret?: K8sIoApiCoreV1SecretProjection;
    /**
     * 
     * @type {K8sIoApiCoreV1DownwardAPIProjection}
     * @memberof K8sIoApiCoreV1VolumeProjection
     */
    downwardAPI?: K8sIoApiCoreV1DownwardAPIProjection;
    /**
     * 
     * @type {K8sIoApiCoreV1ConfigMapProjection}
     * @memberof K8sIoApiCoreV1VolumeProjection
     */
    configMap?: K8sIoApiCoreV1ConfigMapProjection;
    /**
     * 
     * @type {K8sIoApiCoreV1ServiceAccountTokenProjection}
     * @memberof K8sIoApiCoreV1VolumeProjection
     */
    serviceAccountToken?: K8sIoApiCoreV1ServiceAccountTokenProjection;
}
/**
 * Represents the source of a volume to mount. Only one of its members may be specified.
 * @export
 * @interface K8sIoApiCoreV1VolumeSource
 */
export interface K8sIoApiCoreV1VolumeSource {
    /**
     * 
     * @type {K8sIoApiCoreV1HostPathVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    hostPath?: K8sIoApiCoreV1HostPathVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1EmptyDirVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    emptyDir?: K8sIoApiCoreV1EmptyDirVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1GCEPersistentDiskVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    gcePersistentDisk?: K8sIoApiCoreV1GCEPersistentDiskVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    awsElasticBlockStore?: K8sIoApiCoreV1AWSElasticBlockStoreVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1GitRepoVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    gitRepo?: K8sIoApiCoreV1GitRepoVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1SecretVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    secret?: K8sIoApiCoreV1SecretVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1NFSVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    nfs?: K8sIoApiCoreV1NFSVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1ISCSIVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    iscsi?: K8sIoApiCoreV1ISCSIVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1GlusterfsVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    glusterfs?: K8sIoApiCoreV1GlusterfsVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1PersistentVolumeClaimVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    persistentVolumeClaim?: K8sIoApiCoreV1PersistentVolumeClaimVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1RBDVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    rbd?: K8sIoApiCoreV1RBDVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1FlexVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    flexVolume?: K8sIoApiCoreV1FlexVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1CinderVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    cinder?: K8sIoApiCoreV1CinderVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1CephFSVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    cephfs?: K8sIoApiCoreV1CephFSVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1FlockerVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    flocker?: K8sIoApiCoreV1FlockerVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1DownwardAPIVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    downwardAPI?: K8sIoApiCoreV1DownwardAPIVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1FCVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    fc?: K8sIoApiCoreV1FCVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1AzureFileVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    azureFile?: K8sIoApiCoreV1AzureFileVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1ConfigMapVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    configMap?: K8sIoApiCoreV1ConfigMapVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1VsphereVirtualDiskVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    vsphereVolume?: K8sIoApiCoreV1VsphereVirtualDiskVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1QuobyteVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    quobyte?: K8sIoApiCoreV1QuobyteVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1AzureDiskVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    azureDisk?: K8sIoApiCoreV1AzureDiskVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1PhotonPersistentDiskVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    photonPersistentDisk?: K8sIoApiCoreV1PhotonPersistentDiskVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1ProjectedVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    projected?: K8sIoApiCoreV1ProjectedVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1PortworxVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    portworxVolume?: K8sIoApiCoreV1PortworxVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1ScaleIOVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    scaleIO?: K8sIoApiCoreV1ScaleIOVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1StorageOSVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    storageos?: K8sIoApiCoreV1StorageOSVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1CSIVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    csi?: K8sIoApiCoreV1CSIVolumeSource;
    /**
     * 
     * @type {K8sIoApiCoreV1EphemeralVolumeSource}
     * @memberof K8sIoApiCoreV1VolumeSource
     */
    ephemeral?: K8sIoApiCoreV1EphemeralVolumeSource;
}
/**
 * Represents a vSphere volume resource.
 * @export
 * @interface K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
 */
export interface K8sIoApiCoreV1VsphereVirtualDiskVolumeSource {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
     */
    volumePath?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
     */
    fsType?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
     */
    storagePolicyName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1VsphereVirtualDiskVolumeSource
     */
    storagePolicyID?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApiCoreV1WeightedPodAffinityTerm
 */
export interface K8sIoApiCoreV1WeightedPodAffinityTerm {
    /**
     * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
     * @type {number}
     * @memberof K8sIoApiCoreV1WeightedPodAffinityTerm
     */
    weight?: number;
    /**
     * 
     * @type {K8sIoApiCoreV1PodAffinityTerm}
     * @memberof K8sIoApiCoreV1WeightedPodAffinityTerm
     */
    podAffinityTerm?: K8sIoApiCoreV1PodAffinityTerm;
}
/**
 * WindowsSecurityContextOptions contain Windows-specific options and credentials.
 * @export
 * @interface K8sIoApiCoreV1WindowsSecurityContextOptions
 */
export interface K8sIoApiCoreV1WindowsSecurityContextOptions {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1WindowsSecurityContextOptions
     */
    gmsaCredentialSpecName?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1WindowsSecurityContextOptions
     */
    gmsaCredentialSpec?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApiCoreV1WindowsSecurityContextOptions
     */
    runAsUserName?: string;
}
/**
 * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and AsInt64() accessors.  The serialization format is:  <quantity>        ::= <signedNumber><suffix>   (Note that <suffix> may be empty, from the \"\" case in <decimalSI>.) <digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= \"+\" | \"-\" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei   (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html) <decimalSI>       ::= m | \"\" | k | M | G | T | P | E   (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.) <decimalExponent> ::= \"e\" <signedNumber> | \"E\" <signedNumber>  No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.  When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.  Before serializing, Quantity will be put in \"canonical form\". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:   a. No precision is lost   b. No fractional digits will be emitted   c. The exponent (or suffix) is as large as possible. The sign will be omitted unless the number is negative.  Examples:   1.5 will be serialized as \"1500m\"   1.5Gi will be serialized as \"1536Mi\"  Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.  Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)  This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.  +protobuf=true +protobuf.embed=string +protobuf.options.marshal=false +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:deepcopy-gen=true +k8s:openapi-gen=true
 * @export
 * @interface K8sIoApimachineryPkgApiResourceQuantity
 */
export interface K8sIoApimachineryPkgApiResourceQuantity {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApiResourceQuantity
     */
    string?: string;
}
/**
 * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.  Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.  The exact format is defined in sigs.k8s.io/structured-merge-diff +protobuf.options.(gogoproto.goproto_stringer)=false
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1FieldsV1
 */
export interface K8sIoApimachineryPkgApisMetaV1FieldsV1 {
    /**
     * Raw is the underlying serialization of this object.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1FieldsV1
     */
    raw?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1LabelSelector
 */
export interface K8sIoApimachineryPkgApisMetaV1LabelSelector {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelector
     */
    matchLabels?: { [key: string]: string; };
    /**
     * 
     * @type {Array<K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement>}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelector
     */
    matchExpressions?: Array<K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement>;
}
/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
 */
export interface K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
     */
    key?: string;
    /**
     * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
     */
    operator?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
     */
    values?: Array<string>;
}
/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
 */
export interface K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry {
    /**
     * Manager is an identifier of the workflow managing these fields.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    manager?: string;
    /**
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    operation?: string;
    /**
     * APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    apiVersion?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    time?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    fieldsType?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1FieldsV1}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    fieldsV1?: K8sIoApimachineryPkgApisMetaV1FieldsV1;
}
/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1ObjectMeta
 */
export interface K8sIoApimachineryPkgApisMetaV1ObjectMeta {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    name?: string;
    /**
     * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    generateName?: string;
    /**
     * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    namespace?: string;
    /**
     * SelfLink is a URL representing this object. Populated by the system. Read-only.  DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release. +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    selfLink?: string;
    /**
     * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.  Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    uid?: string;
    /**
     * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    resourceVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    generation?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    creationTimestamp?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    deletionTimestamp?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    deletionGracePeriodSeconds?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {Array<K8sIoApimachineryPkgApisMetaV1OwnerReference>}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    ownerReferences?: Array<K8sIoApimachineryPkgApisMetaV1OwnerReference>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    finalizers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    clusterName?: string;
    /**
     * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
     * @type {Array<K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry>}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    managedFields?: Array<K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry>;
}
/**
 * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1OwnerReference
 */
export interface K8sIoApimachineryPkgApisMetaV1OwnerReference {
    /**
     * API version of the referent.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    apiVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    uid?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    controller?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    blockOwnerDeletion?: boolean;
}
/**
 * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.  +protobuf.options.marshal=false +protobuf.as=Timestamp +protobuf.options.(gogoproto.goproto_stringer)=false
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1Time
 */
export interface K8sIoApimachineryPkgApisMetaV1Time {
    /**
     * Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1Time
     */
    seconds?: string;
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     * @type {number}
     * @memberof K8sIoApimachineryPkgApisMetaV1Time
     */
    nanos?: number;
}
/**
 * +protobuf=true +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:openapi-gen=true
 * @export
 * @interface K8sIoApimachineryPkgUtilIntstrIntOrString
 */
export interface K8sIoApimachineryPkgUtilIntstrIntOrString {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgUtilIntstrIntOrString
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApimachineryPkgUtilIntstrIntOrString
     */
    intVal?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgUtilIntstrIntOrString
     */
    strVal?: string;
}
/**
 * 
 * @export
 * @interface RolloutAbortRolloutRequest
 */
export interface RolloutAbortRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutAbortRolloutRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutAbortRolloutRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutAnalysisRunInfo
 */
export interface RolloutAnalysisRunInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutAnalysisRunInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutAnalysisRunInfo
     */
    icon?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutAnalysisRunInfo
     */
    revision?: number;
    /**
     * 
     * @type {string}
     * @memberof RolloutAnalysisRunInfo
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutAnalysisRunInfo
     */
    successful?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutAnalysisRunInfo
     */
    failed?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutAnalysisRunInfo
     */
    inconclusive?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutAnalysisRunInfo
     */
    error?: number;
    /**
     * 
     * @type {Array<RolloutJobInfo>}
     * @memberof RolloutAnalysisRunInfo
     */
    jobs?: Array<RolloutJobInfo>;
}
/**
 * 
 * @export
 * @interface RolloutContainerInfo
 */
export interface RolloutContainerInfo {
    /**
     * 
     * @type {string}
     * @memberof RolloutContainerInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutContainerInfo
     */
    image?: string;
}
/**
 * 
 * @export
 * @interface RolloutExperimentInfo
 */
export interface RolloutExperimentInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutExperimentInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutExperimentInfo
     */
    icon?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutExperimentInfo
     */
    revision?: number;
    /**
     * 
     * @type {string}
     * @memberof RolloutExperimentInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutExperimentInfo
     */
    message?: string;
    /**
     * 
     * @type {Array<RolloutReplicaSetInfo>}
     * @memberof RolloutExperimentInfo
     */
    replicaSets?: Array<RolloutReplicaSetInfo>;
    /**
     * 
     * @type {Array<RolloutAnalysisRunInfo>}
     * @memberof RolloutExperimentInfo
     */
    analysisRuns?: Array<RolloutAnalysisRunInfo>;
}
/**
 * 
 * @export
 * @interface RolloutJobInfo
 */
export interface RolloutJobInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutJobInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutJobInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutJobInfo
     */
    icon?: string;
}
/**
 * 
 * @export
 * @interface RolloutNamespaceInfo
 */
export interface RolloutNamespaceInfo {
    /**
     * 
     * @type {string}
     * @memberof RolloutNamespaceInfo
     */
    namespace?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof RolloutNamespaceInfo
     */
    availableNamespaces?: Array<string>;
}
/**
 * 
 * @export
 * @interface RolloutPodInfo
 */
export interface RolloutPodInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutPodInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutPodInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutPodInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutPodInfo
     */
    ready?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutPodInfo
     */
    restarts?: number;
}
/**
 * 
 * @export
 * @interface RolloutPromoteRolloutRequest
 */
export interface RolloutPromoteRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutPromoteRolloutRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutPromoteRolloutRequest
     */
    namespace?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutPromoteRolloutRequest
     */
    full?: boolean;
}
/**
 * 
 * @export
 * @interface RolloutReplicaSetInfo
 */
export interface RolloutReplicaSetInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutReplicaSetInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutReplicaSetInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutReplicaSetInfo
     */
    icon?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutReplicaSetInfo
     */
    revision?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    stable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    canary?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RolloutReplicaSetInfo
     */
    preview?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RolloutReplicaSetInfo
     */
    replicas?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutReplicaSetInfo
     */
    available?: number;
    /**
     * 
     * @type {string}
     * @memberof RolloutReplicaSetInfo
     */
    template?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutReplicaSetInfo
     */
    scaleDownDeadline?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RolloutReplicaSetInfo
     */
    images?: Array<string>;
    /**
     * 
     * @type {Array<RolloutPodInfo>}
     * @memberof RolloutReplicaSetInfo
     */
    pods?: Array<RolloutPodInfo>;
}
/**
 * 
 * @export
 * @interface RolloutRestartRolloutRequest
 */
export interface RolloutRestartRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutRestartRolloutRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRestartRolloutRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutRetryRolloutRequest
 */
export interface RolloutRetryRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutRetryRolloutRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRetryRolloutRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutRolloutInfo
 */
export interface RolloutRolloutInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof RolloutRolloutInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    strategy?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    step?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    setWeight?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    actualWeight?: string;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    ready?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    current?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    desired?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    updated?: number;
    /**
     * 
     * @type {number}
     * @memberof RolloutRolloutInfo
     */
    available?: number;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    restartedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutInfo
     */
    generation?: string;
    /**
     * 
     * @type {Array<RolloutReplicaSetInfo>}
     * @memberof RolloutRolloutInfo
     */
    replicaSets?: Array<RolloutReplicaSetInfo>;
    /**
     * 
     * @type {Array<RolloutExperimentInfo>}
     * @memberof RolloutRolloutInfo
     */
    experiments?: Array<RolloutExperimentInfo>;
    /**
     * 
     * @type {Array<RolloutAnalysisRunInfo>}
     * @memberof RolloutRolloutInfo
     */
    analysisRuns?: Array<RolloutAnalysisRunInfo>;
    /**
     * 
     * @type {Array<RolloutContainerInfo>}
     * @memberof RolloutRolloutInfo
     */
    containers?: Array<RolloutContainerInfo>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>}
     * @memberof RolloutRolloutInfo
     */
    steps?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>;
}
/**
 * 
 * @export
 * @interface RolloutRolloutInfoList
 */
export interface RolloutRolloutInfoList {
    /**
     * 
     * @type {Array<RolloutRolloutInfo>}
     * @memberof RolloutRolloutInfoList
     */
    rollouts?: Array<RolloutRolloutInfo>;
}
/**
 * 
 * @export
 * @interface RolloutRolloutWatchEvent
 */
export interface RolloutRolloutWatchEvent {
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutWatchEvent
     */
    type?: string;
    /**
     * 
     * @type {RolloutRolloutInfo}
     * @memberof RolloutRolloutWatchEvent
     */
    rolloutInfo?: RolloutRolloutInfo;
}
/**
 * 
 * @export
 * @interface RolloutSetImageRequest
 */
export interface RolloutSetImageRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    rollout?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    container?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    tag?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutSetImageRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutUndoRolloutRequest
 */
export interface RolloutUndoRolloutRequest {
    /**
     * 
     * @type {string}
     * @memberof RolloutUndoRolloutRequest
     */
    rollout?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutUndoRolloutRequest
     */
    revision?: string;
    /**
     * 
     * @type {string}
     * @memberof RolloutUndoRolloutRequest
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutVersionInfo
 */
export interface RolloutVersionInfo {
    /**
     * 
     * @type {string}
     * @memberof RolloutVersionInfo
     */
    rolloutsVersion?: string;
}
/**
 * 
 * @export
 * @interface StreamResultOfRolloutRolloutInfo
 */
export interface StreamResultOfRolloutRolloutInfo {
    /**
     * 
     * @type {RolloutRolloutInfo}
     * @memberof StreamResultOfRolloutRolloutInfo
     */
    result?: RolloutRolloutInfo;
    /**
     * 
     * @type {GrpcGatewayRuntimeStreamError}
     * @memberof StreamResultOfRolloutRolloutInfo
     */
    error?: GrpcGatewayRuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfRolloutRolloutWatchEvent
 */
export interface StreamResultOfRolloutRolloutWatchEvent {
    /**
     * 
     * @type {RolloutRolloutWatchEvent}
     * @memberof StreamResultOfRolloutRolloutWatchEvent
     */
    result?: RolloutRolloutWatchEvent;
    /**
     * 
     * @type {GrpcGatewayRuntimeStreamError}
     * @memberof StreamResultOfRolloutRolloutWatchEvent
     */
    error?: GrpcGatewayRuntimeStreamError;
}
/**
 * RolloutServiceApi - fetch parameter creator
 * @export
 */
export const RolloutServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RolloutAbortRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceAbortRollout(body: RolloutAbortRolloutRequest, namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceAbortRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceAbortRollout.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceAbortRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/abort`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutAbortRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetNamespace(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/namespace`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetRolloutInfo(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceGetRolloutInfo.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceGetRolloutInfo.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/info`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceListRolloutInfos(namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceListRolloutInfos.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/info`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutPromoteRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServicePromoteRollout(body: RolloutPromoteRolloutRequest, namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServicePromoteRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServicePromoteRollout.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServicePromoteRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/promote`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutPromoteRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutRestartRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRestartRollout(body: RolloutRestartRolloutRequest, namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceRestartRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceRestartRollout.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceRestartRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/restart`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutRestartRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutRetryRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRetryRollout(body: RolloutRetryRolloutRequest, namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceRetryRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceRetryRollout.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceRetryRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/retry`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutRetryRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutSetImageRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} container 
         * @param {string} image 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceSetRolloutImage(body: RolloutSetImageRequest, namespace: string, rollout: string, container: string, image: string, tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'rollout' is not null or undefined
            if (rollout === null || rollout === undefined) {
                throw new RequiredError('rollout','Required parameter rollout was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{rollout}/set/{container}/{image}/{tag}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"rollout"}}`, encodeURIComponent(String(rollout)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"image"}}`, encodeURIComponent(String(image)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutSetImageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RolloutUndoRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} revision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceUndoRollout(body: RolloutUndoRolloutRequest, namespace: string, rollout: string, revision: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling rolloutServiceUndoRollout.');
            }
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceUndoRollout.');
            }
            // verify required parameter 'rollout' is not null or undefined
            if (rollout === null || rollout === undefined) {
                throw new RequiredError('rollout','Required parameter rollout was null or undefined when calling rolloutServiceUndoRollout.');
            }
            // verify required parameter 'revision' is not null or undefined
            if (revision === null || revision === undefined) {
                throw new RequiredError('revision','Required parameter revision was null or undefined when calling rolloutServiceUndoRollout.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{rollout}/undo/{revision}`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"rollout"}}`, encodeURIComponent(String(rollout)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RolloutUndoRolloutRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceVersion(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfo(namespace: string, name: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceWatchRolloutInfo.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceWatchRolloutInfo.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/{name}/info/watch`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfos(namespace: string, options: any = {}): FetchArgs {
            // verify required parameter 'namespace' is not null or undefined
            if (namespace === null || namespace === undefined) {
                throw new RequiredError('namespace','Required parameter namespace was null or undefined when calling rolloutServiceWatchRolloutInfos.');
            }
            const localVarPath = `/api/v1/rollouts/{namespace}/info/watch`
                .replace(`{${"namespace"}}`, encodeURIComponent(String(namespace)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolloutServiceApi - functional programming interface
 * @export
 */
export const RolloutServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {RolloutAbortRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceAbortRollout(body: RolloutAbortRolloutRequest, namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceAbortRollout(body, namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetNamespace(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutNamespaceInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceGetNamespace(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetRolloutInfo(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutRolloutInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceGetRolloutInfo(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceListRolloutInfos(namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutRolloutInfoList> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceListRolloutInfos(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutPromoteRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServicePromoteRollout(body: RolloutPromoteRolloutRequest, namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServicePromoteRollout(body, namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutRestartRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRestartRollout(body: RolloutRestartRolloutRequest, namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceRestartRollout(body, namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutRetryRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRetryRollout(body: RolloutRetryRolloutRequest, namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceRetryRollout(body, namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutSetImageRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} container 
         * @param {string} image 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceSetRolloutImage(body: RolloutSetImageRequest, namespace: string, rollout: string, container: string, image: string, tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceSetRolloutImage(body, namespace, rollout, container, image, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {RolloutUndoRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} revision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceUndoRollout(body: RolloutUndoRolloutRequest, namespace: string, rollout: string, revision: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1Rollout> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceUndoRollout(body, namespace, rollout, revision, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceVersion(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutVersionInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceVersion(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfo(namespace: string, name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfRolloutRolloutInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceWatchRolloutInfo(namespace, name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfos(namespace: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfRolloutRolloutWatchEvent> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceWatchRolloutInfos(namespace, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RolloutServiceApi - factory interface
 * @export
 */
export const RolloutServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {RolloutAbortRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceAbortRollout(body: RolloutAbortRolloutRequest, namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceAbortRollout(body, namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetNamespace(options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceGetNamespace(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetRolloutInfo(namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceGetRolloutInfo(namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceListRolloutInfos(namespace: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceListRolloutInfos(namespace, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutPromoteRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServicePromoteRollout(body: RolloutPromoteRolloutRequest, namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServicePromoteRollout(body, namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutRestartRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRestartRollout(body: RolloutRestartRolloutRequest, namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceRestartRollout(body, namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutRetryRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRetryRollout(body: RolloutRetryRolloutRequest, namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceRetryRollout(body, namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutSetImageRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} container 
         * @param {string} image 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceSetRolloutImage(body: RolloutSetImageRequest, namespace: string, rollout: string, container: string, image: string, tag: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceSetRolloutImage(body, namespace, rollout, container, image, tag, options)(fetch, basePath);
        },
        /**
         * 
         * @param {RolloutUndoRolloutRequest} body 
         * @param {string} namespace 
         * @param {string} rollout 
         * @param {string} revision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceUndoRollout(body: RolloutUndoRolloutRequest, namespace: string, rollout: string, revision: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceUndoRollout(body, namespace, rollout, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceVersion(options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceVersion(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfo(namespace: string, name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceWatchRolloutInfo(namespace, name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} namespace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRolloutInfos(namespace: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceWatchRolloutInfos(namespace, options)(fetch, basePath);
        },
    };
};

/**
 * RolloutServiceApi - object-oriented interface
 * @export
 * @class RolloutServiceApi
 * @extends {BaseAPI}
 */
export class RolloutServiceApi extends BaseAPI {
    /**
     * 
     * @param {RolloutAbortRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceAbortRollout(body: RolloutAbortRolloutRequest, namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceAbortRollout(body, namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceGetNamespace(options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceGetNamespace(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceGetRolloutInfo(namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceGetRolloutInfo(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceListRolloutInfos(namespace: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceListRolloutInfos(namespace, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutPromoteRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServicePromoteRollout(body: RolloutPromoteRolloutRequest, namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServicePromoteRollout(body, namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutRestartRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceRestartRollout(body: RolloutRestartRolloutRequest, namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceRestartRollout(body, namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutRetryRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceRetryRollout(body: RolloutRetryRolloutRequest, namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceRetryRollout(body, namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutSetImageRequest} body 
     * @param {string} namespace 
     * @param {string} rollout 
     * @param {string} container 
     * @param {string} image 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceSetRolloutImage(body: RolloutSetImageRequest, namespace: string, rollout: string, container: string, image: string, tag: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceSetRolloutImage(body, namespace, rollout, container, image, tag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {RolloutUndoRolloutRequest} body 
     * @param {string} namespace 
     * @param {string} rollout 
     * @param {string} revision 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceUndoRollout(body: RolloutUndoRolloutRequest, namespace: string, rollout: string, revision: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceUndoRollout(body, namespace, rollout, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceVersion(options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceVersion(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceWatchRolloutInfo(namespace: string, name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceWatchRolloutInfo(namespace, name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} namespace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceWatchRolloutInfos(namespace: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceWatchRolloutInfos(namespace, options)(this.fetch, this.basePath);
    }

}
