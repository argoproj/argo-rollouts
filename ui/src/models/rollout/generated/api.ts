/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * pkg/apiclient/rollout/rollout.proto
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: version not set
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
     */
    value?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument
     */
    valueFrom?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
     */
    icon?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
     */
    revision?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
     */
    successful?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
     */
    failed?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
     */
    inconclusive?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
     */
    error?: number;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobInfo>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo
     */
    jobs?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobInfo>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom
     */
    podTemplateHashValue?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ArgumentValueFrom
     */
    fieldRef?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef;
}
/**
 * CanaryStep defines a step of a canary deployment.
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    setWeight?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    pause?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    experiment?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    analysis?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep
     */
    setCanaryScale?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ContainerInfo
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ContainerInfo {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ContainerInfo
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ContainerInfo
     */
    image?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo
     */
    icon?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo
     */
    revision?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo
     */
    message?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo
     */
    replicaSets?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo
     */
    analysisRuns?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1FieldRef
     */
    fieldPath?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobInfo
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1JobInfo
     */
    icon?: string;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodInfo
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodInfo
     */
    ready?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodInfo
     */
    restarts?: number;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata
     */
    annotations?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    icon?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    revision?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    stable?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    canary?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    active?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    preview?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    replicas?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    available?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    template?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    scaleDownDeadline?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    images?: Array<string>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodInfo>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo
     */
    pods?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodInfo>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis {
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
     */
    templates?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysis
     */
    args?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate
     */
    templateName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutAnalysisTemplate
     */
    clusterScope?: boolean;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep {
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
     */
    templates?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate>;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
     */
    duration?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStep
     */
    analyses?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    templateName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    clusterScope?: boolean;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    args?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunArgument>;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentStepAnalysisTemplateRef
     */
    requiredForCompletion?: boolean;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate {
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    specRef?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    replicas?: number;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    metadata?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1PodTemplateMetadata;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1LabelSelector}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutExperimentTemplate
     */
    selector?: K8sIoApimachineryPkgApisMetaV1LabelSelector;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo {
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1ObjectMeta}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    objectMeta?: K8sIoApimachineryPkgApisMetaV1ObjectMeta;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    icon?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    strategy?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    step?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    setWeight?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    actualWeight?: string;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    ready?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    current?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    desired?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    updated?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    available?: number;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    restartedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    generation?: string;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    replicaSets?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ReplicaSetInfo>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    experiments?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ExperimentInfo>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    analysisRuns?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1AnalysisRunInfo>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ContainerInfo>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    containers?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1ContainerInfo>;
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    steps?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1CanaryStep>;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause {
    /**
     * 
     * @type {K8sIoApimachineryPkgUtilIntstrIntOrString}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutPause
     */
    duration?: K8sIoApimachineryPkgUtilIntstrIntOrString;
}
/**
 * 
 * @export
 * @interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
 */
export interface GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale {
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
     */
    weight?: number;
    /**
     * 
     * @type {number}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
     */
    replicas?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1SetCanaryScale
     */
    matchTrafficWeight?: boolean;
}
/**
 * 
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    typeUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<GoogleProtobufAny>}
     * @memberof GrpcGatewayRuntimeError
     */
    details?: Array<GoogleProtobufAny>;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeStreamError
 */
export interface GrpcGatewayRuntimeStreamError {
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    grpcCode?: number;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    httpCode?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    httpStatus?: string;
    /**
     * 
     * @type {Array<GoogleProtobufAny>}
     * @memberof GrpcGatewayRuntimeStreamError
     */
    details?: Array<GoogleProtobufAny>;
}
/**
 * FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.  Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.  The exact format is defined in sigs.k8s.io/structured-merge-diff +protobuf.options.(gogoproto.goproto_stringer)=false
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1FieldsV1
 */
export interface K8sIoApimachineryPkgApisMetaV1FieldsV1 {
    /**
     * Raw is the underlying serialization of this object.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1FieldsV1
     */
    raw?: string;
}
/**
 * 
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1LabelSelector
 */
export interface K8sIoApimachineryPkgApisMetaV1LabelSelector {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelector
     */
    matchLabels?: { [key: string]: string; };
    /**
     * 
     * @type {Array<K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement>}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelector
     */
    matchExpressions?: Array<K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement>;
}
/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
 */
export interface K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
     */
    key?: string;
    /**
     * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
     */
    operator?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApimachineryPkgApisMetaV1LabelSelectorRequirement
     */
    values?: Array<string>;
}
/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
 */
export interface K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry {
    /**
     * Manager is an identifier of the workflow managing these fields.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    manager?: string;
    /**
     * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    operation?: string;
    /**
     * APIVersion defines the version of this resource that this field set applies to. The format is \"group/version\" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    apiVersion?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    time?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    fieldsType?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1FieldsV1}
     * @memberof K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry
     */
    fieldsV1?: K8sIoApimachineryPkgApisMetaV1FieldsV1;
}
/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1ObjectMeta
 */
export interface K8sIoApimachineryPkgApisMetaV1ObjectMeta {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    name?: string;
    /**
     * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.  If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).  Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    generateName?: string;
    /**
     * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.  Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    namespace?: string;
    /**
     * SelfLink is a URL representing this object. Populated by the system. Read-only.  DEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release. +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    selfLink?: string;
    /**
     * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.  Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    uid?: string;
    /**
     * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.  Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency +optional
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    resourceVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    generation?: string;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    creationTimestamp?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {K8sIoApimachineryPkgApisMetaV1Time}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    deletionTimestamp?: K8sIoApimachineryPkgApisMetaV1Time;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    deletionGracePeriodSeconds?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    labels?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    annotations?: { [key: string]: string; };
    /**
     * 
     * @type {Array<K8sIoApimachineryPkgApisMetaV1OwnerReference>}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    ownerReferences?: Array<K8sIoApimachineryPkgApisMetaV1OwnerReference>;
    /**
     * 
     * @type {Array<string>}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    finalizers?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    clusterName?: string;
    /**
     * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like \"ci-cd\". The set of fields is always in the version that the workflow used when modifying the object.  +optional
     * @type {Array<K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry>}
     * @memberof K8sIoApimachineryPkgApisMetaV1ObjectMeta
     */
    managedFields?: Array<K8sIoApimachineryPkgApisMetaV1ManagedFieldsEntry>;
}
/**
 * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1OwnerReference
 */
export interface K8sIoApimachineryPkgApisMetaV1OwnerReference {
    /**
     * API version of the referent.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    apiVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    uid?: string;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    controller?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof K8sIoApimachineryPkgApisMetaV1OwnerReference
     */
    blockOwnerDeletion?: boolean;
}
/**
 * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.  +protobuf.options.marshal=false +protobuf.as=Timestamp +protobuf.options.(gogoproto.goproto_stringer)=false
 * @export
 * @interface K8sIoApimachineryPkgApisMetaV1Time
 */
export interface K8sIoApimachineryPkgApisMetaV1Time {
    /**
     * Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
     * @type {string}
     * @memberof K8sIoApimachineryPkgApisMetaV1Time
     */
    seconds?: string;
    /**
     * Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
     * @type {number}
     * @memberof K8sIoApimachineryPkgApisMetaV1Time
     */
    nanos?: number;
}
/**
 * +protobuf=true +protobuf.options.(gogoproto.goproto_stringer)=false +k8s:openapi-gen=true
 * @export
 * @interface K8sIoApimachineryPkgUtilIntstrIntOrString
 */
export interface K8sIoApimachineryPkgUtilIntstrIntOrString {
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgUtilIntstrIntOrString
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof K8sIoApimachineryPkgUtilIntstrIntOrString
     */
    intVal?: number;
    /**
     * 
     * @type {string}
     * @memberof K8sIoApimachineryPkgUtilIntstrIntOrString
     */
    strVal?: string;
}
/**
 * 
 * @export
 * @interface RolloutNamespaceInfo
 */
export interface RolloutNamespaceInfo {
    /**
     * 
     * @type {string}
     * @memberof RolloutNamespaceInfo
     */
    namespace?: string;
}
/**
 * 
 * @export
 * @interface RolloutRolloutInfoList
 */
export interface RolloutRolloutInfoList {
    /**
     * 
     * @type {Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo>}
     * @memberof RolloutRolloutInfoList
     */
    rollouts?: Array<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo>;
}
/**
 * 
 * @export
 * @interface RolloutRolloutWatchEvent
 */
export interface RolloutRolloutWatchEvent {
    /**
     * 
     * @type {string}
     * @memberof RolloutRolloutWatchEvent
     */
    type?: string;
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo}
     * @memberof RolloutRolloutWatchEvent
     */
    rolloutInfo?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo;
}
/**
 * 
 * @export
 * @interface RolloutVersionInfo
 */
export interface RolloutVersionInfo {
    /**
     * 
     * @type {string}
     * @memberof RolloutVersionInfo
     */
    rolloutsVersion?: string;
}
/**
 * 
 * @export
 * @interface StreamResultOfGithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
 */
export interface StreamResultOfGithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo {
    /**
     * 
     * @type {GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo}
     * @memberof StreamResultOfGithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    result?: GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo;
    /**
     * 
     * @type {GrpcGatewayRuntimeStreamError}
     * @memberof StreamResultOfGithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo
     */
    error?: GrpcGatewayRuntimeStreamError;
}
/**
 * 
 * @export
 * @interface StreamResultOfRolloutRolloutWatchEvent
 */
export interface StreamResultOfRolloutRolloutWatchEvent {
    /**
     * 
     * @type {RolloutRolloutWatchEvent}
     * @memberof StreamResultOfRolloutRolloutWatchEvent
     */
    result?: RolloutRolloutWatchEvent;
    /**
     * 
     * @type {GrpcGatewayRuntimeStreamError}
     * @memberof StreamResultOfRolloutRolloutWatchEvent
     */
    error?: GrpcGatewayRuntimeStreamError;
}
/**
 * RolloutServiceApi - fetch parameter creator
 * @export
 */
export const RolloutServiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceAbortRollout(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceAbortRollout.');
            }
            const localVarPath = `/api/v1/rollout/abort/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetNamespace(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/namespace`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get returns a rollout
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetRollout(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceGetRollout.');
            }
            const localVarPath = `/api/v1/rollout/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceListRollouts(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/rollouts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServicePromoteRollout(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServicePromoteRollout.');
            }
            const localVarPath = `/api/v1/rollout/promote/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRestartRollout(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceRestartRollout.');
            }
            const localVarPath = `/api/v1/rollout/restart/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRetryRollout(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceRetryRollout.');
            }
            const localVarPath = `/api/v1/rollout/retry/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rollout 
         * @param {string} container 
         * @param {string} image 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceSetRolloutImage(rollout: string, container: string, image: string, tag: string, options: any = {}): FetchArgs {
            // verify required parameter 'rollout' is not null or undefined
            if (rollout === null || rollout === undefined) {
                throw new RequiredError('rollout','Required parameter rollout was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'container' is not null or undefined
            if (container === null || container === undefined) {
                throw new RequiredError('container','Required parameter container was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'image' is not null or undefined
            if (image === null || image === undefined) {
                throw new RequiredError('image','Required parameter image was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling rolloutServiceSetRolloutImage.');
            }
            const localVarPath = `/api/v1/rollout/set/{rollout}/{container}/{image}/{tag}`
                .replace(`{${"rollout"}}`, encodeURIComponent(String(rollout)))
                .replace(`{${"container"}}`, encodeURIComponent(String(container)))
                .replace(`{${"image"}}`, encodeURIComponent(String(image)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rollout 
         * @param {string} revision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceUndoRollout(rollout: string, revision: string, options: any = {}): FetchArgs {
            // verify required parameter 'rollout' is not null or undefined
            if (rollout === null || rollout === undefined) {
                throw new RequiredError('rollout','Required parameter rollout was null or undefined when calling rolloutServiceUndoRollout.');
            }
            // verify required parameter 'revision' is not null or undefined
            if (revision === null || revision === undefined) {
                throw new RequiredError('revision','Required parameter revision was null or undefined when calling rolloutServiceUndoRollout.');
            }
            const localVarPath = `/api/v1/rollout/undo/{rollout}/{revision}`
                .replace(`{${"rollout"}}`, encodeURIComponent(String(rollout)))
                .replace(`{${"revision"}}`, encodeURIComponent(String(revision)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceVersion(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRollout(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rolloutServiceWatchRollout.');
            }
            const localVarPath = `/api/v1/rollout/watch/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRollouts(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/rollouts/watch`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolloutServiceApi - functional programming interface
 * @export
 */
export const RolloutServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceAbortRollout(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceAbortRollout(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetNamespace(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutNamespaceInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceGetNamespace(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get returns a rollout
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetRollout(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceGetRollout(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceListRollouts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutRolloutInfoList> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceListRollouts(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServicePromoteRollout(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServicePromoteRollout(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRestartRollout(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceRestartRollout(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRetryRollout(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceRetryRollout(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} rollout 
         * @param {string} container 
         * @param {string} image 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceSetRolloutImage(rollout: string, container: string, image: string, tag: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceSetRolloutImage(rollout, container, image, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} rollout 
         * @param {string} revision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceUndoRollout(rollout: string, revision: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceUndoRollout(rollout, revision, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceVersion(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RolloutVersionInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceVersion(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRollout(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfGithubComArgoprojArgoRolloutsPkgApisRolloutsV1alpha1RolloutInfo> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceWatchRollout(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRollouts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StreamResultOfRolloutRolloutWatchEvent> {
            const localVarFetchArgs = RolloutServiceApiFetchParamCreator(configuration).rolloutServiceWatchRollouts(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RolloutServiceApi - factory interface
 * @export
 */
export const RolloutServiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceAbortRollout(name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceAbortRollout(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetNamespace(options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceGetNamespace(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get returns a rollout
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceGetRollout(name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceGetRollout(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceListRollouts(options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceListRollouts(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServicePromoteRollout(name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServicePromoteRollout(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRestartRollout(name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceRestartRollout(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceRetryRollout(name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceRetryRollout(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} rollout 
         * @param {string} container 
         * @param {string} image 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceSetRolloutImage(rollout: string, container: string, image: string, tag: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceSetRolloutImage(rollout, container, image, tag, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} rollout 
         * @param {string} revision 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceUndoRollout(rollout: string, revision: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceUndoRollout(rollout, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceVersion(options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceVersion(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRollout(name: string, options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceWatchRollout(name, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolloutServiceWatchRollouts(options?: any) {
            return RolloutServiceApiFp(configuration).rolloutServiceWatchRollouts(options)(fetch, basePath);
        },
    };
};

/**
 * RolloutServiceApi - object-oriented interface
 * @export
 * @class RolloutServiceApi
 * @extends {BaseAPI}
 */
export class RolloutServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceAbortRollout(name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceAbortRollout(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceGetNamespace(options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceGetNamespace(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get returns a rollout
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceGetRollout(name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceGetRollout(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceListRollouts(options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceListRollouts(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServicePromoteRollout(name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServicePromoteRollout(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceRestartRollout(name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceRestartRollout(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceRetryRollout(name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceRetryRollout(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} rollout 
     * @param {string} container 
     * @param {string} image 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceSetRolloutImage(rollout: string, container: string, image: string, tag: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceSetRolloutImage(rollout, container, image, tag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} rollout 
     * @param {string} revision 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceUndoRollout(rollout: string, revision: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceUndoRollout(rollout, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceVersion(options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceVersion(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceWatchRollout(name: string, options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceWatchRollout(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolloutServiceApi
     */
    public rolloutServiceWatchRollouts(options?: any) {
        return RolloutServiceApiFp(this.configuration).rolloutServiceWatchRollouts(options)(this.fetch, this.basePath);
    }

}
